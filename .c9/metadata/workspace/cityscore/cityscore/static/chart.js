{"filter":false,"title":"chart.js","tooltip":"/cityscore/cityscore/static/chart.js","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":14281,"column":3},"action":"insert","lines":["/*!"," * Chart.js"," * http://chartjs.org/"," * Version: 2.1.6"," *"," * Copyright 2016 Nick Downie"," * Released under the MIT license"," * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md"," */","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){","/* MIT license */","var colorNames = require(5);","","module.exports = {","   getRgba: getRgba,","   getHsla: getHsla,","   getRgb: getRgb,","   getHsl: getHsl,","   getHwb: getHwb,","   getAlpha: getAlpha,","","   hexString: hexString,","   rgbString: rgbString,","   rgbaString: rgbaString,","   percentString: percentString,","   percentaString: percentaString,","   hslString: hslString,","   hslaString: hslaString,","   hwbString: hwbString,","   keyword: keyword","}","","function getRgba(string) {","   if (!string) {","      return;","   }","   var abbr =  /^#([a-fA-F0-9]{3})$/,","       hex =  /^#([a-fA-F0-9]{6})$/,","       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,","       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,","       keyword = /(\\w+)/;","","   var rgb = [0, 0, 0],","       a = 1,","       match = string.match(abbr);","   if (match) {","      match = match[1];","      for (var i = 0; i < rgb.length; i++) {","         rgb[i] = parseInt(match[i] + match[i], 16);","      }","   }","   else if (match = string.match(hex)) {","      match = match[1];","      for (var i = 0; i < rgb.length; i++) {","         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);","      }","   }","   else if (match = string.match(rgba)) {","      for (var i = 0; i < rgb.length; i++) {","         rgb[i] = parseInt(match[i + 1]);","      }","      a = parseFloat(match[4]);","   }","   else if (match = string.match(per)) {","      for (var i = 0; i < rgb.length; i++) {","         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);","      }","      a = parseFloat(match[4]);","   }","   else if (match = string.match(keyword)) {","      if (match[1] == \"transparent\") {","         return [0, 0, 0, 0];","      }","      rgb = colorNames[match[1]];","      if (!rgb) {","         return;","      }","   }","","   for (var i = 0; i < rgb.length; i++) {","      rgb[i] = scale(rgb[i], 0, 255);","   }","   if (!a && a != 0) {","      a = 1;","   }","   else {","      a = scale(a, 0, 1);","   }","   rgb[3] = a;","   return rgb;","}","","function getHsla(string) {","   if (!string) {","      return;","   }","   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;","   var match = string.match(hsl);","   if (match) {","      var alpha = parseFloat(match[4]);","      var h = scale(parseInt(match[1]), 0, 360),","          s = scale(parseFloat(match[2]), 0, 100),","          l = scale(parseFloat(match[3]), 0, 100),","          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);","      return [h, s, l, a];","   }","}","","function getHwb(string) {","   if (!string) {","      return;","   }","   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;","   var match = string.match(hwb);","   if (match) {","    var alpha = parseFloat(match[4]);","      var h = scale(parseInt(match[1]), 0, 360),","          w = scale(parseFloat(match[2]), 0, 100),","          b = scale(parseFloat(match[3]), 0, 100),","          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);","      return [h, w, b, a];","   }","}","","function getRgb(string) {","   var rgba = getRgba(string);","   return rgba && rgba.slice(0, 3);","}","","function getHsl(string) {","  var hsla = getHsla(string);","  return hsla && hsla.slice(0, 3);","}","","function getAlpha(string) {","   var vals = getRgba(string);","   if (vals) {","      return vals[3];","   }","   else if (vals = getHsla(string)) {","      return vals[3];","   }","   else if (vals = getHwb(string)) {","      return vals[3];","   }","}","","// generators","function hexString(rgb) {","   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])","              + hexDouble(rgb[2]);","}","","function rgbString(rgba, alpha) {","   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {","      return rgbaString(rgba, alpha);","   }","   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";","}","","function rgbaString(rgba, alpha) {","   if (alpha === undefined) {","      alpha = (rgba[3] !== undefined ? rgba[3] : 1);","   }","   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]","           + \", \" + alpha + \")\";","}","","function percentString(rgba, alpha) {","   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {","      return percentaString(rgba, alpha);","   }","   var r = Math.round(rgba[0]/255 * 100),","       g = Math.round(rgba[1]/255 * 100),","       b = Math.round(rgba[2]/255 * 100);","","   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";","}","","function percentaString(rgba, alpha) {","   var r = Math.round(rgba[0]/255 * 100),","       g = Math.round(rgba[1]/255 * 100),","       b = Math.round(rgba[2]/255 * 100);","   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";","}","","function hslString(hsla, alpha) {","   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {","      return hslaString(hsla, alpha);","   }","   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";","}","","function hslaString(hsla, alpha) {","   if (alpha === undefined) {","      alpha = (hsla[3] !== undefined ? hsla[3] : 1);","   }","   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"","           + alpha + \")\";","}","","// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax","// (hwb have alpha optional & 1 is default value)","function hwbString(hwb, alpha) {","   if (alpha === undefined) {","      alpha = (hwb[3] !== undefined ? hwb[3] : 1);","   }","   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"","           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";","}","","function keyword(rgb) {","  return reverseNames[rgb.slice(0, 3)];","}","","// helpers","function scale(num, min, max) {","   return Math.min(Math.max(min, num), max);","}","","function hexDouble(num) {","  var str = num.toString(16).toUpperCase();","  return (str.length < 2) ? \"0\" + str : str;","}","","","//create a list of reverse color names","var reverseNames = {};","for (var name in colorNames) {","   reverseNames[colorNames[name]] = name;","}","","},{\"5\":5}],2:[function(require,module,exports){","/* MIT license */","var convert = require(4);","var string = require(1);","","var Color = function (obj) {","\tif (obj instanceof Color) {","\t\treturn obj;","\t}","\tif (!(this instanceof Color)) {","\t\treturn new Color(obj);","\t}","","\tthis.values = {","\t\trgb: [0, 0, 0],","\t\thsl: [0, 0, 0],","\t\thsv: [0, 0, 0],","\t\thwb: [0, 0, 0],","\t\tcmyk: [0, 0, 0, 0],","\t\talpha: 1","\t};","","\t// parse Color() argument","\tvar vals;","\tif (typeof obj === 'string') {","\t\tvals = string.getRgba(obj);","\t\tif (vals) {","\t\t\tthis.setValues('rgb', vals);","\t\t} else if (vals = string.getHsla(obj)) {","\t\t\tthis.setValues('hsl', vals);","\t\t} else if (vals = string.getHwb(obj)) {","\t\t\tthis.setValues('hwb', vals);","\t\t} else {","\t\t\tthrow new Error('Unable to parse color from string \"' + obj + '\"');","\t\t}","\t} else if (typeof obj === 'object') {","\t\tvals = obj;","\t\tif (vals.r !== undefined || vals.red !== undefined) {","\t\t\tthis.setValues('rgb', vals);","\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {","\t\t\tthis.setValues('hsl', vals);","\t\t} else if (vals.v !== undefined || vals.value !== undefined) {","\t\t\tthis.setValues('hsv', vals);","\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {","\t\t\tthis.setValues('hwb', vals);","\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {","\t\t\tthis.setValues('cmyk', vals);","\t\t} else {","\t\t\tthrow new Error('Unable to parse color from object ' + JSON.stringify(obj));","\t\t}","\t}","};","","Color.prototype = {","\trgb: function () {","\t\treturn this.setSpace('rgb', arguments);","\t},","\thsl: function () {","\t\treturn this.setSpace('hsl', arguments);","\t},","\thsv: function () {","\t\treturn this.setSpace('hsv', arguments);","\t},","\thwb: function () {","\t\treturn this.setSpace('hwb', arguments);","\t},","\tcmyk: function () {","\t\treturn this.setSpace('cmyk', arguments);","\t},","","\trgbArray: function () {","\t\treturn this.values.rgb;","\t},","\thslArray: function () {","\t\treturn this.values.hsl;","\t},","\thsvArray: function () {","\t\treturn this.values.hsv;","\t},","\thwbArray: function () {","\t\tvar values = this.values;","\t\tif (values.alpha !== 1) {","\t\t\treturn values.hwb.concat([values.alpha]);","\t\t}","\t\treturn values.hwb;","\t},","\tcmykArray: function () {","\t\treturn this.values.cmyk;","\t},","\trgbaArray: function () {","\t\tvar values = this.values;","\t\treturn values.rgb.concat([values.alpha]);","\t},","\thslaArray: function () {","\t\tvar values = this.values;","\t\treturn values.hsl.concat([values.alpha]);","\t},","\talpha: function (val) {","\t\tif (val === undefined) {","\t\t\treturn this.values.alpha;","\t\t}","\t\tthis.setValues('alpha', val);","\t\treturn this;","\t},","","\tred: function (val) {","\t\treturn this.setChannel('rgb', 0, val);","\t},","\tgreen: function (val) {","\t\treturn this.setChannel('rgb', 1, val);","\t},","\tblue: function (val) {","\t\treturn this.setChannel('rgb', 2, val);","\t},","\thue: function (val) {","\t\tif (val) {","\t\t\tval %= 360;","\t\t\tval = val < 0 ? 360 + val : val;","\t\t}","\t\treturn this.setChannel('hsl', 0, val);","\t},","\tsaturation: function (val) {","\t\treturn this.setChannel('hsl', 1, val);","\t},","\tlightness: function (val) {","\t\treturn this.setChannel('hsl', 2, val);","\t},","\tsaturationv: function (val) {","\t\treturn this.setChannel('hsv', 1, val);","\t},","\twhiteness: function (val) {","\t\treturn this.setChannel('hwb', 1, val);","\t},","\tblackness: function (val) {","\t\treturn this.setChannel('hwb', 2, val);","\t},","\tvalue: function (val) {","\t\treturn this.setChannel('hsv', 2, val);","\t},","\tcyan: function (val) {","\t\treturn this.setChannel('cmyk', 0, val);","\t},","\tmagenta: function (val) {","\t\treturn this.setChannel('cmyk', 1, val);","\t},","\tyellow: function (val) {","\t\treturn this.setChannel('cmyk', 2, val);","\t},","\tblack: function (val) {","\t\treturn this.setChannel('cmyk', 3, val);","\t},","","\thexString: function () {","\t\treturn string.hexString(this.values.rgb);","\t},","\trgbString: function () {","\t\treturn string.rgbString(this.values.rgb, this.values.alpha);","\t},","\trgbaString: function () {","\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);","\t},","\tpercentString: function () {","\t\treturn string.percentString(this.values.rgb, this.values.alpha);","\t},","\thslString: function () {","\t\treturn string.hslString(this.values.hsl, this.values.alpha);","\t},","\thslaString: function () {","\t\treturn string.hslaString(this.values.hsl, this.values.alpha);","\t},","\thwbString: function () {","\t\treturn string.hwbString(this.values.hwb, this.values.alpha);","\t},","\tkeyword: function () {","\t\treturn string.keyword(this.values.rgb, this.values.alpha);","\t},","","\trgbNumber: function () {","\t\tvar rgb = this.values.rgb;","\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];","\t},","","\tluminosity: function () {","\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef","\t\tvar rgb = this.values.rgb;","\t\tvar lum = [];","\t\tfor (var i = 0; i < rgb.length; i++) {","\t\t\tvar chan = rgb[i] / 255;","\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);","\t\t}","\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];","\t},","","\tcontrast: function (color2) {","\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef","\t\tvar lum1 = this.luminosity();","\t\tvar lum2 = color2.luminosity();","\t\tif (lum1 > lum2) {","\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);","\t\t}","\t\treturn (lum2 + 0.05) / (lum1 + 0.05);","\t},","","\tlevel: function (color2) {","\t\tvar contrastRatio = this.contrast(color2);","\t\tif (contrastRatio >= 7.1) {","\t\t\treturn 'AAA';","\t\t}","","\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';","\t},","","\tdark: function () {","\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast","\t\tvar rgb = this.values.rgb;","\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;","\t\treturn yiq < 128;","\t},","","\tlight: function () {","\t\treturn !this.dark();","\t},","","\tnegate: function () {","\t\tvar rgb = [];","\t\tfor (var i = 0; i < 3; i++) {","\t\t\trgb[i] = 255 - this.values.rgb[i];","\t\t}","\t\tthis.setValues('rgb', rgb);","\t\treturn this;","\t},","","\tlighten: function (ratio) {","\t\tvar hsl = this.values.hsl;","\t\thsl[2] += hsl[2] * ratio;","\t\tthis.setValues('hsl', hsl);","\t\treturn this;","\t},","","\tdarken: function (ratio) {","\t\tvar hsl = this.values.hsl;","\t\thsl[2] -= hsl[2] * ratio;","\t\tthis.setValues('hsl', hsl);","\t\treturn this;","\t},","","\tsaturate: function (ratio) {","\t\tvar hsl = this.values.hsl;","\t\thsl[1] += hsl[1] * ratio;","\t\tthis.setValues('hsl', hsl);","\t\treturn this;","\t},","","\tdesaturate: function (ratio) {","\t\tvar hsl = this.values.hsl;","\t\thsl[1] -= hsl[1] * ratio;","\t\tthis.setValues('hsl', hsl);","\t\treturn this;","\t},","","\twhiten: function (ratio) {","\t\tvar hwb = this.values.hwb;","\t\thwb[1] += hwb[1] * ratio;","\t\tthis.setValues('hwb', hwb);","\t\treturn this;","\t},","","\tblacken: function (ratio) {","\t\tvar hwb = this.values.hwb;","\t\thwb[2] += hwb[2] * ratio;","\t\tthis.setValues('hwb', hwb);","\t\treturn this;","\t},","","\tgreyscale: function () {","\t\tvar rgb = this.values.rgb;","\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale","\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;","\t\tthis.setValues('rgb', [val, val, val]);","\t\treturn this;","\t},","","\tclearer: function (ratio) {","\t\tvar alpha = this.values.alpha;","\t\tthis.setValues('alpha', alpha - (alpha * ratio));","\t\treturn this;","\t},","","\topaquer: function (ratio) {","\t\tvar alpha = this.values.alpha;","\t\tthis.setValues('alpha', alpha + (alpha * ratio));","\t\treturn this;","\t},","","\trotate: function (degrees) {","\t\tvar hsl = this.values.hsl;","\t\tvar hue = (hsl[0] + degrees) % 360;","\t\thsl[0] = hue < 0 ? 360 + hue : hue;","\t\tthis.setValues('hsl', hsl);","\t\treturn this;","\t},","","\t/**","\t * Ported from sass implementation in C","\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209","\t */","\tmix: function (mixinColor, weight) {","\t\tvar color1 = this;","\t\tvar color2 = mixinColor;","\t\tvar p = weight === undefined ? 0.5 : weight;","","\t\tvar w = 2 * p - 1;","\t\tvar a = color1.alpha() - color2.alpha();","","\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;","\t\tvar w2 = 1 - w1;","","\t\treturn this","\t\t\t.rgb(","\t\t\t\tw1 * color1.red() + w2 * color2.red(),","\t\t\t\tw1 * color1.green() + w2 * color2.green(),","\t\t\t\tw1 * color1.blue() + w2 * color2.blue()","\t\t\t)","\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));","\t},","","\ttoJSON: function () {","\t\treturn this.rgb();","\t},","","\tclone: function () {","\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,","\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,","\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,","\t\t// except 'alpha' which is a number.","\t\tvar result = new Color();","\t\tvar source = this.values;","\t\tvar target = result.values;","\t\tvar value, type;","","\t\tfor (var prop in source) {","\t\t\tif (source.hasOwnProperty(prop)) {","\t\t\t\tvalue = source[prop];","\t\t\t\ttype = ({}).toString.call(value);","\t\t\t\tif (type === '[object Array]') {","\t\t\t\t\ttarget[prop] = value.slice(0);","\t\t\t\t} else if (type === '[object Number]') {","\t\t\t\t\ttarget[prop] = value;","\t\t\t\t} else {","\t\t\t\t\tconsole.error('unexpected color value:', value);","\t\t\t\t}","\t\t\t}","\t\t}","","\t\treturn result;","\t}","};","","Color.prototype.spaces = {","\trgb: ['red', 'green', 'blue'],","\thsl: ['hue', 'saturation', 'lightness'],","\thsv: ['hue', 'saturation', 'value'],","\thwb: ['hue', 'whiteness', 'blackness'],","\tcmyk: ['cyan', 'magenta', 'yellow', 'black']","};","","Color.prototype.maxes = {","\trgb: [255, 255, 255],","\thsl: [360, 100, 100],","\thsv: [360, 100, 100],","\thwb: [360, 100, 100],","\tcmyk: [100, 100, 100, 100]","};","","Color.prototype.getValues = function (space) {","\tvar values = this.values;","\tvar vals = {};","","\tfor (var i = 0; i < space.length; i++) {","\t\tvals[space.charAt(i)] = values[space][i];","\t}","","\tif (values.alpha !== 1) {","\t\tvals.a = values.alpha;","\t}","","\t// {r: 255, g: 255, b: 255, a: 0.4}","\treturn vals;","};","","Color.prototype.setValues = function (space, vals) {","\tvar values = this.values;","\tvar spaces = this.spaces;","\tvar maxes = this.maxes;","\tvar alpha = 1;","\tvar i;","","\tif (space === 'alpha') {","\t\talpha = vals;","\t} else if (vals.length) {","\t\t// [10, 10, 10]","\t\tvalues[space] = vals.slice(0, space.length);","\t\talpha = vals[space.length];","\t} else if (vals[space.charAt(0)] !== undefined) {","\t\t// {r: 10, g: 10, b: 10}","\t\tfor (i = 0; i < space.length; i++) {","\t\t\tvalues[space][i] = vals[space.charAt(i)];","\t\t}","","\t\talpha = vals.a;","\t} else if (vals[spaces[space][0]] !== undefined) {","\t\t// {red: 10, green: 10, blue: 10}","\t\tvar chans = spaces[space];","","\t\tfor (i = 0; i < space.length; i++) {","\t\t\tvalues[space][i] = vals[chans[i]];","\t\t}","","\t\talpha = vals.alpha;","\t}","","\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));","","\tif (space === 'alpha') {","\t\treturn false;","\t}","","\tvar capped;","","\t// cap values of the space prior converting all values","\tfor (i = 0; i < space.length; i++) {","\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));","\t\tvalues[space][i] = Math.round(capped);","\t}","","\t// convert to all the other color spaces","\tfor (var sname in spaces) {","\t\tif (sname !== space) {","\t\t\tvalues[sname] = convert[space][sname](values[space]);","\t\t}","\t}","","\treturn true;","};","","Color.prototype.setSpace = function (space, args) {","\tvar vals = args[0];","","\tif (vals === undefined) {","\t\t// color.rgb()","\t\treturn this.getValues(space);","\t}","","\t// color.rgb(10, 10, 10)","\tif (typeof vals === 'number') {","\t\tvals = Array.prototype.slice.call(args);","\t}","","\tthis.setValues(space, vals);","\treturn this;","};","","Color.prototype.setChannel = function (space, index, val) {","\tvar svalues = this.values[space];","\tif (val === undefined) {","\t\t// color.red()","\t\treturn svalues[index];","\t} else if (val === svalues[index]) {","\t\t// color.red(color.red())","\t\treturn this;","\t}","","\t// color.red(100)","\tsvalues[index] = val;","\tthis.setValues(space, svalues);","","\treturn this;","};","","if (typeof window !== 'undefined') {","\twindow.Color = Color;","}","","module.exports = Color;","","},{\"1\":1,\"4\":4}],3:[function(require,module,exports){","/* MIT license */","","module.exports = {","  rgb2hsl: rgb2hsl,","  rgb2hsv: rgb2hsv,","  rgb2hwb: rgb2hwb,","  rgb2cmyk: rgb2cmyk,","  rgb2keyword: rgb2keyword,","  rgb2xyz: rgb2xyz,","  rgb2lab: rgb2lab,","  rgb2lch: rgb2lch,","","  hsl2rgb: hsl2rgb,","  hsl2hsv: hsl2hsv,","  hsl2hwb: hsl2hwb,","  hsl2cmyk: hsl2cmyk,","  hsl2keyword: hsl2keyword,","","  hsv2rgb: hsv2rgb,","  hsv2hsl: hsv2hsl,","  hsv2hwb: hsv2hwb,","  hsv2cmyk: hsv2cmyk,","  hsv2keyword: hsv2keyword,","","  hwb2rgb: hwb2rgb,","  hwb2hsl: hwb2hsl,","  hwb2hsv: hwb2hsv,","  hwb2cmyk: hwb2cmyk,","  hwb2keyword: hwb2keyword,","","  cmyk2rgb: cmyk2rgb,","  cmyk2hsl: cmyk2hsl,","  cmyk2hsv: cmyk2hsv,","  cmyk2hwb: cmyk2hwb,","  cmyk2keyword: cmyk2keyword,","","  keyword2rgb: keyword2rgb,","  keyword2hsl: keyword2hsl,","  keyword2hsv: keyword2hsv,","  keyword2hwb: keyword2hwb,","  keyword2cmyk: keyword2cmyk,","  keyword2lab: keyword2lab,","  keyword2xyz: keyword2xyz,","","  xyz2rgb: xyz2rgb,","  xyz2lab: xyz2lab,","  xyz2lch: xyz2lch,","","  lab2xyz: lab2xyz,","  lab2rgb: lab2rgb,","  lab2lch: lab2lch,","","  lch2lab: lch2lab,","  lch2xyz: lch2xyz,","  lch2rgb: lch2rgb","}","","","function rgb2hsl(rgb) {","  var r = rgb[0]/255,","      g = rgb[1]/255,","      b = rgb[2]/255,","      min = Math.min(r, g, b),","      max = Math.max(r, g, b),","      delta = max - min,","      h, s, l;","","  if (max == min)","    h = 0;","  else if (r == max)","    h = (g - b) / delta;","  else if (g == max)","    h = 2 + (b - r) / delta;","  else if (b == max)","    h = 4 + (r - g)/ delta;","","  h = Math.min(h * 60, 360);","","  if (h < 0)","    h += 360;","","  l = (min + max) / 2;","","  if (max == min)","    s = 0;","  else if (l <= 0.5)","    s = delta / (max + min);","  else","    s = delta / (2 - max - min);","","  return [h, s * 100, l * 100];","}","","function rgb2hsv(rgb) {","  var r = rgb[0],","      g = rgb[1],","      b = rgb[2],","      min = Math.min(r, g, b),","      max = Math.max(r, g, b),","      delta = max - min,","      h, s, v;","","  if (max == 0)","    s = 0;","  else","    s = (delta/max * 1000)/10;","","  if (max == min)","    h = 0;","  else if (r == max)","    h = (g - b) / delta;","  else if (g == max)","    h = 2 + (b - r) / delta;","  else if (b == max)","    h = 4 + (r - g) / delta;","","  h = Math.min(h * 60, 360);","","  if (h < 0)","    h += 360;","","  v = ((max / 255) * 1000) / 10;","","  return [h, s, v];","}","","function rgb2hwb(rgb) {","  var r = rgb[0],","      g = rgb[1],","      b = rgb[2],","      h = rgb2hsl(rgb)[0],","      w = 1/255 * Math.min(r, Math.min(g, b)),","      b = 1 - 1/255 * Math.max(r, Math.max(g, b));","","  return [h, w * 100, b * 100];","}","","function rgb2cmyk(rgb) {","  var r = rgb[0] / 255,","      g = rgb[1] / 255,","      b = rgb[2] / 255,","      c, m, y, k;","","  k = Math.min(1 - r, 1 - g, 1 - b);","  c = (1 - r - k) / (1 - k) || 0;","  m = (1 - g - k) / (1 - k) || 0;","  y = (1 - b - k) / (1 - k) || 0;","  return [c * 100, m * 100, y * 100, k * 100];","}","","function rgb2keyword(rgb) {","  return reverseKeywords[JSON.stringify(rgb)];","}","","function rgb2xyz(rgb) {","  var r = rgb[0] / 255,","      g = rgb[1] / 255,","      b = rgb[2] / 255;","","  // assume sRGB","  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);","  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);","  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);","","  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);","  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);","  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);","","  return [x * 100, y *100, z * 100];","}","","function rgb2lab(rgb) {","  var xyz = rgb2xyz(rgb),","        x = xyz[0],","        y = xyz[1],","        z = xyz[2],","        l, a, b;","","  x /= 95.047;","  y /= 100;","  z /= 108.883;","","  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);","  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);","  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);","","  l = (116 * y) - 16;","  a = 500 * (x - y);","  b = 200 * (y - z);","","  return [l, a, b];","}","","function rgb2lch(args) {","  return lab2lch(rgb2lab(args));","}","","function hsl2rgb(hsl) {","  var h = hsl[0] / 360,","      s = hsl[1] / 100,","      l = hsl[2] / 100,","      t1, t2, t3, rgb, val;","","  if (s == 0) {","    val = l * 255;","    return [val, val, val];","  }","","  if (l < 0.5)","    t2 = l * (1 + s);","  else","    t2 = l + s - l * s;","  t1 = 2 * l - t2;","","  rgb = [0, 0, 0];","  for (var i = 0; i < 3; i++) {","    t3 = h + 1 / 3 * - (i - 1);","    t3 < 0 && t3++;","    t3 > 1 && t3--;","","    if (6 * t3 < 1)","      val = t1 + (t2 - t1) * 6 * t3;","    else if (2 * t3 < 1)","      val = t2;","    else if (3 * t3 < 2)","      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;","    else","      val = t1;","","    rgb[i] = val * 255;","  }","","  return rgb;","}","","function hsl2hsv(hsl) {","  var h = hsl[0],","      s = hsl[1] / 100,","      l = hsl[2] / 100,","      sv, v;","","  if(l === 0) {","      // no need to do calc on black","      // also avoids divide by 0 error","      return [0, 0, 0];","  }","","  l *= 2;","  s *= (l <= 1) ? l : 2 - l;","  v = (l + s) / 2;","  sv = (2 * s) / (l + s);","  return [h, sv * 100, v * 100];","}","","function hsl2hwb(args) {","  return rgb2hwb(hsl2rgb(args));","}","","function hsl2cmyk(args) {","  return rgb2cmyk(hsl2rgb(args));","}","","function hsl2keyword(args) {","  return rgb2keyword(hsl2rgb(args));","}","","","function hsv2rgb(hsv) {","  var h = hsv[0] / 60,","      s = hsv[1] / 100,","      v = hsv[2] / 100,","      hi = Math.floor(h) % 6;","","  var f = h - Math.floor(h),","      p = 255 * v * (1 - s),","      q = 255 * v * (1 - (s * f)),","      t = 255 * v * (1 - (s * (1 - f))),","      v = 255 * v;","","  switch(hi) {","    case 0:","      return [v, t, p];","    case 1:","      return [q, v, p];","    case 2:","      return [p, v, t];","    case 3:","      return [p, q, v];","    case 4:","      return [t, p, v];","    case 5:","      return [v, p, q];","  }","}","","function hsv2hsl(hsv) {","  var h = hsv[0],","      s = hsv[1] / 100,","      v = hsv[2] / 100,","      sl, l;","","  l = (2 - s) * v;","  sl = s * v;","  sl /= (l <= 1) ? l : 2 - l;","  sl = sl || 0;","  l /= 2;","  return [h, sl * 100, l * 100];","}","","function hsv2hwb(args) {","  return rgb2hwb(hsv2rgb(args))","}","","function hsv2cmyk(args) {","  return rgb2cmyk(hsv2rgb(args));","}","","function hsv2keyword(args) {","  return rgb2keyword(hsv2rgb(args));","}","","// http://dev.w3.org/csswg/css-color/#hwb-to-rgb","function hwb2rgb(hwb) {","  var h = hwb[0] / 360,","      wh = hwb[1] / 100,","      bl = hwb[2] / 100,","      ratio = wh + bl,","      i, v, f, n;","","  // wh + bl cant be > 1","  if (ratio > 1) {","    wh /= ratio;","    bl /= ratio;","  }","","  i = Math.floor(6 * h);","  v = 1 - bl;","  f = 6 * h - i;","  if ((i & 0x01) != 0) {","    f = 1 - f;","  }","  n = wh + f * (v - wh);  // linear interpolation","","  switch (i) {","    default:","    case 6:","    case 0: r = v; g = n; b = wh; break;","    case 1: r = n; g = v; b = wh; break;","    case 2: r = wh; g = v; b = n; break;","    case 3: r = wh; g = n; b = v; break;","    case 4: r = n; g = wh; b = v; break;","    case 5: r = v; g = wh; b = n; break;","  }","","  return [r * 255, g * 255, b * 255];","}","","function hwb2hsl(args) {","  return rgb2hsl(hwb2rgb(args));","}","","function hwb2hsv(args) {","  return rgb2hsv(hwb2rgb(args));","}","","function hwb2cmyk(args) {","  return rgb2cmyk(hwb2rgb(args));","}","","function hwb2keyword(args) {","  return rgb2keyword(hwb2rgb(args));","}","","function cmyk2rgb(cmyk) {","  var c = cmyk[0] / 100,","      m = cmyk[1] / 100,","      y = cmyk[2] / 100,","      k = cmyk[3] / 100,","      r, g, b;","","  r = 1 - Math.min(1, c * (1 - k) + k);","  g = 1 - Math.min(1, m * (1 - k) + k);","  b = 1 - Math.min(1, y * (1 - k) + k);","  return [r * 255, g * 255, b * 255];","}","","function cmyk2hsl(args) {","  return rgb2hsl(cmyk2rgb(args));","}","","function cmyk2hsv(args) {","  return rgb2hsv(cmyk2rgb(args));","}","","function cmyk2hwb(args) {","  return rgb2hwb(cmyk2rgb(args));","}","","function cmyk2keyword(args) {","  return rgb2keyword(cmyk2rgb(args));","}","","","function xyz2rgb(xyz) {","  var x = xyz[0] / 100,","      y = xyz[1] / 100,","      z = xyz[2] / 100,","      r, g, b;","","  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);","  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);","  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);","","  // assume sRGB","  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)","    : r = (r * 12.92);","","  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)","    : g = (g * 12.92);","","  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)","    : b = (b * 12.92);","","  r = Math.min(Math.max(0, r), 1);","  g = Math.min(Math.max(0, g), 1);","  b = Math.min(Math.max(0, b), 1);","","  return [r * 255, g * 255, b * 255];","}","","function xyz2lab(xyz) {","  var x = xyz[0],","      y = xyz[1],","      z = xyz[2],","      l, a, b;","","  x /= 95.047;","  y /= 100;","  z /= 108.883;","","  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);","  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);","  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);","","  l = (116 * y) - 16;","  a = 500 * (x - y);","  b = 200 * (y - z);","","  return [l, a, b];","}","","function xyz2lch(args) {","  return lab2lch(xyz2lab(args));","}","","function lab2xyz(lab) {","  var l = lab[0],","      a = lab[1],","      b = lab[2],","      x, y, z, y2;","","  if (l <= 8) {","    y = (l * 100) / 903.3;","    y2 = (7.787 * (y / 100)) + (16 / 116);","  } else {","    y = 100 * Math.pow((l + 16) / 116, 3);","    y2 = Math.pow(y / 100, 1/3);","  }","","  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);","","  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);","","  return [x, y, z];","}","","function lab2lch(lab) {","  var l = lab[0],","      a = lab[1],","      b = lab[2],","      hr, h, c;","","  hr = Math.atan2(b, a);","  h = hr * 360 / 2 / Math.PI;","  if (h < 0) {","    h += 360;","  }","  c = Math.sqrt(a * a + b * b);","  return [l, c, h];","}","","function lab2rgb(args) {","  return xyz2rgb(lab2xyz(args));","}","","function lch2lab(lch) {","  var l = lch[0],","      c = lch[1],","      h = lch[2],","      a, b, hr;","","  hr = h / 360 * 2 * Math.PI;","  a = c * Math.cos(hr);","  b = c * Math.sin(hr);","  return [l, a, b];","}","","function lch2xyz(args) {","  return lab2xyz(lch2lab(args));","}","","function lch2rgb(args) {","  return lab2rgb(lch2lab(args));","}","","function keyword2rgb(keyword) {","  return cssKeywords[keyword];","}","","function keyword2hsl(args) {","  return rgb2hsl(keyword2rgb(args));","}","","function keyword2hsv(args) {","  return rgb2hsv(keyword2rgb(args));","}","","function keyword2hwb(args) {","  return rgb2hwb(keyword2rgb(args));","}","","function keyword2cmyk(args) {","  return rgb2cmyk(keyword2rgb(args));","}","","function keyword2lab(args) {","  return rgb2lab(keyword2rgb(args));","}","","function keyword2xyz(args) {","  return rgb2xyz(keyword2rgb(args));","}","","var cssKeywords = {","  aliceblue:  [240,248,255],","  antiquewhite: [250,235,215],","  aqua: [0,255,255],","  aquamarine: [127,255,212],","  azure:  [240,255,255],","  beige:  [245,245,220],","  bisque: [255,228,196],","  black:  [0,0,0],","  blanchedalmond: [255,235,205],","  blue: [0,0,255],","  blueviolet: [138,43,226],","  brown:  [165,42,42],","  burlywood:  [222,184,135],","  cadetblue:  [95,158,160],","  chartreuse: [127,255,0],","  chocolate:  [210,105,30],","  coral:  [255,127,80],","  cornflowerblue: [100,149,237],","  cornsilk: [255,248,220],","  crimson:  [220,20,60],","  cyan: [0,255,255],","  darkblue: [0,0,139],","  darkcyan: [0,139,139],","  darkgoldenrod:  [184,134,11],","  darkgray: [169,169,169],","  darkgreen:  [0,100,0],","  darkgrey: [169,169,169],","  darkkhaki:  [189,183,107],","  darkmagenta:  [139,0,139],","  darkolivegreen: [85,107,47],","  darkorange: [255,140,0],","  darkorchid: [153,50,204],","  darkred:  [139,0,0],","  darksalmon: [233,150,122],","  darkseagreen: [143,188,143],","  darkslateblue:  [72,61,139],","  darkslategray:  [47,79,79],","  darkslategrey:  [47,79,79],","  darkturquoise:  [0,206,209],","  darkviolet: [148,0,211],","  deeppink: [255,20,147],","  deepskyblue:  [0,191,255],","  dimgray:  [105,105,105],","  dimgrey:  [105,105,105],","  dodgerblue: [30,144,255],","  firebrick:  [178,34,34],","  floralwhite:  [255,250,240],","  forestgreen:  [34,139,34],","  fuchsia:  [255,0,255],","  gainsboro:  [220,220,220],","  ghostwhite: [248,248,255],","  gold: [255,215,0],","  goldenrod:  [218,165,32],","  gray: [128,128,128],","  green:  [0,128,0],","  greenyellow:  [173,255,47],","  grey: [128,128,128],","  honeydew: [240,255,240],","  hotpink:  [255,105,180],","  indianred:  [205,92,92],","  indigo: [75,0,130],","  ivory:  [255,255,240],","  khaki:  [240,230,140],","  lavender: [230,230,250],","  lavenderblush:  [255,240,245],","  lawngreen:  [124,252,0],","  lemonchiffon: [255,250,205],","  lightblue:  [173,216,230],","  lightcoral: [240,128,128],","  lightcyan:  [224,255,255],","  lightgoldenrodyellow: [250,250,210],","  lightgray:  [211,211,211],","  lightgreen: [144,238,144],","  lightgrey:  [211,211,211],","  lightpink:  [255,182,193],","  lightsalmon:  [255,160,122],","  lightseagreen:  [32,178,170],","  lightskyblue: [135,206,250],","  lightslategray: [119,136,153],","  lightslategrey: [119,136,153],","  lightsteelblue: [176,196,222],","  lightyellow:  [255,255,224],","  lime: [0,255,0],","  limegreen:  [50,205,50],","  linen:  [250,240,230],","  magenta:  [255,0,255],","  maroon: [128,0,0],","  mediumaquamarine: [102,205,170],","  mediumblue: [0,0,205],","  mediumorchid: [186,85,211],","  mediumpurple: [147,112,219],","  mediumseagreen: [60,179,113],","  mediumslateblue:  [123,104,238],","  mediumspringgreen:  [0,250,154],","  mediumturquoise:  [72,209,204],","  mediumvioletred:  [199,21,133],","  midnightblue: [25,25,112],","  mintcream:  [245,255,250],","  mistyrose:  [255,228,225],","  moccasin: [255,228,181],","  navajowhite:  [255,222,173],","  navy: [0,0,128],","  oldlace:  [253,245,230],","  olive:  [128,128,0],","  olivedrab:  [107,142,35],","  orange: [255,165,0],","  orangered:  [255,69,0],","  orchid: [218,112,214],","  palegoldenrod:  [238,232,170],","  palegreen:  [152,251,152],","  paleturquoise:  [175,238,238],","  palevioletred:  [219,112,147],","  papayawhip: [255,239,213],","  peachpuff:  [255,218,185],","  peru: [205,133,63],","  pink: [255,192,203],","  plum: [221,160,221],","  powderblue: [176,224,230],","  purple: [128,0,128],","  rebeccapurple: [102, 51, 153],","  red:  [255,0,0],","  rosybrown:  [188,143,143],","  royalblue:  [65,105,225],","  saddlebrown:  [139,69,19],","  salmon: [250,128,114],","  sandybrown: [244,164,96],","  seagreen: [46,139,87],","  seashell: [255,245,238],","  sienna: [160,82,45],","  silver: [192,192,192],","  skyblue:  [135,206,235],","  slateblue:  [106,90,205],","  slategray:  [112,128,144],","  slategrey:  [112,128,144],","  snow: [255,250,250],","  springgreen:  [0,255,127],","  steelblue:  [70,130,180],","  tan:  [210,180,140],","  teal: [0,128,128],","  thistle:  [216,191,216],","  tomato: [255,99,71],","  turquoise:  [64,224,208],","  violet: [238,130,238],","  wheat:  [245,222,179],","  white:  [255,255,255],","  whitesmoke: [245,245,245],","  yellow: [255,255,0],","  yellowgreen:  [154,205,50]","};","","var reverseKeywords = {};","for (var key in cssKeywords) {","  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;","}","","},{}],4:[function(require,module,exports){","var conversions = require(3);","","var convert = function() {","   return new Converter();","}","","for (var func in conversions) {","  // export Raw versions","  convert[func + \"Raw\"] =  (function(func) {","    // accept array or plain args","    return function(arg) {","      if (typeof arg == \"number\")","        arg = Array.prototype.slice.call(arguments);","      return conversions[func](arg);","    }","  })(func);","","  var pair = /(\\w+)2(\\w+)/.exec(func),","      from = pair[1],","      to = pair[2];","","  // export rgb2hsl and [\"rgb\"][\"hsl\"]","  convert[from] = convert[from] || {};","","  convert[from][to] = convert[func] = (function(func) { ","    return function(arg) {","      if (typeof arg == \"number\")","        arg = Array.prototype.slice.call(arguments);","      ","      var val = conversions[func](arg);","      if (typeof val == \"string\" || val === undefined)","        return val; // keyword","","      for (var i = 0; i < val.length; i++)","        val[i] = Math.round(val[i]);","      return val;","    }","  })(func);","}","","","/* Converter does lazy conversion and caching */","var Converter = function() {","   this.convs = {};","};","","/* Either get the values for a space or","  set the values for a space, depending on args */","Converter.prototype.routeSpace = function(space, args) {","   var values = args[0];","   if (values === undefined) {","      // color.rgb()","      return this.getValues(space);","   }","   // color.rgb(10, 10, 10)","   if (typeof values == \"number\") {","      values = Array.prototype.slice.call(args);        ","   }","","   return this.setValues(space, values);","};","  ","/* Set the values for a space, invalidating cache */","Converter.prototype.setValues = function(space, values) {","   this.space = space;","   this.convs = {};","   this.convs[space] = values;","   return this;","};","","/* Get the values for a space. If there's already","  a conversion for the space, fetch it, otherwise","  compute it */","Converter.prototype.getValues = function(space) {","   var vals = this.convs[space];","   if (!vals) {","      var fspace = this.space,","          from = this.convs[fspace];","      vals = convert[fspace][space](from);","","      this.convs[space] = vals;","   }","  return vals;","};","","[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {","   Converter.prototype[space] = function(vals) {","      return this.routeSpace(space, arguments);","   }","});","","module.exports = convert;","},{\"3\":3}],5:[function(require,module,exports){","module.exports = {","\t\"aliceblue\": [240, 248, 255],","\t\"antiquewhite\": [250, 235, 215],","\t\"aqua\": [0, 255, 255],","\t\"aquamarine\": [127, 255, 212],","\t\"azure\": [240, 255, 255],","\t\"beige\": [245, 245, 220],","\t\"bisque\": [255, 228, 196],","\t\"black\": [0, 0, 0],","\t\"blanchedalmond\": [255, 235, 205],","\t\"blue\": [0, 0, 255],","\t\"blueviolet\": [138, 43, 226],","\t\"brown\": [165, 42, 42],","\t\"burlywood\": [222, 184, 135],","\t\"cadetblue\": [95, 158, 160],","\t\"chartreuse\": [127, 255, 0],","\t\"chocolate\": [210, 105, 30],","\t\"coral\": [255, 127, 80],","\t\"cornflowerblue\": [100, 149, 237],","\t\"cornsilk\": [255, 248, 220],","\t\"crimson\": [220, 20, 60],","\t\"cyan\": [0, 255, 255],","\t\"darkblue\": [0, 0, 139],","\t\"darkcyan\": [0, 139, 139],","\t\"darkgoldenrod\": [184, 134, 11],","\t\"darkgray\": [169, 169, 169],","\t\"darkgreen\": [0, 100, 0],","\t\"darkgrey\": [169, 169, 169],","\t\"darkkhaki\": [189, 183, 107],","\t\"darkmagenta\": [139, 0, 139],","\t\"darkolivegreen\": [85, 107, 47],","\t\"darkorange\": [255, 140, 0],","\t\"darkorchid\": [153, 50, 204],","\t\"darkred\": [139, 0, 0],","\t\"darksalmon\": [233, 150, 122],","\t\"darkseagreen\": [143, 188, 143],","\t\"darkslateblue\": [72, 61, 139],","\t\"darkslategray\": [47, 79, 79],","\t\"darkslategrey\": [47, 79, 79],","\t\"darkturquoise\": [0, 206, 209],","\t\"darkviolet\": [148, 0, 211],","\t\"deeppink\": [255, 20, 147],","\t\"deepskyblue\": [0, 191, 255],","\t\"dimgray\": [105, 105, 105],","\t\"dimgrey\": [105, 105, 105],","\t\"dodgerblue\": [30, 144, 255],","\t\"firebrick\": [178, 34, 34],","\t\"floralwhite\": [255, 250, 240],","\t\"forestgreen\": [34, 139, 34],","\t\"fuchsia\": [255, 0, 255],","\t\"gainsboro\": [220, 220, 220],","\t\"ghostwhite\": [248, 248, 255],","\t\"gold\": [255, 215, 0],","\t\"goldenrod\": [218, 165, 32],","\t\"gray\": [128, 128, 128],","\t\"green\": [0, 128, 0],","\t\"greenyellow\": [173, 255, 47],","\t\"grey\": [128, 128, 128],","\t\"honeydew\": [240, 255, 240],","\t\"hotpink\": [255, 105, 180],","\t\"indianred\": [205, 92, 92],","\t\"indigo\": [75, 0, 130],","\t\"ivory\": [255, 255, 240],","\t\"khaki\": [240, 230, 140],","\t\"lavender\": [230, 230, 250],","\t\"lavenderblush\": [255, 240, 245],","\t\"lawngreen\": [124, 252, 0],","\t\"lemonchiffon\": [255, 250, 205],","\t\"lightblue\": [173, 216, 230],","\t\"lightcoral\": [240, 128, 128],","\t\"lightcyan\": [224, 255, 255],","\t\"lightgoldenrodyellow\": [250, 250, 210],","\t\"lightgray\": [211, 211, 211],","\t\"lightgreen\": [144, 238, 144],","\t\"lightgrey\": [211, 211, 211],","\t\"lightpink\": [255, 182, 193],","\t\"lightsalmon\": [255, 160, 122],","\t\"lightseagreen\": [32, 178, 170],","\t\"lightskyblue\": [135, 206, 250],","\t\"lightslategray\": [119, 136, 153],","\t\"lightslategrey\": [119, 136, 153],","\t\"lightsteelblue\": [176, 196, 222],","\t\"lightyellow\": [255, 255, 224],","\t\"lime\": [0, 255, 0],","\t\"limegreen\": [50, 205, 50],","\t\"linen\": [250, 240, 230],","\t\"magenta\": [255, 0, 255],","\t\"maroon\": [128, 0, 0],","\t\"mediumaquamarine\": [102, 205, 170],","\t\"mediumblue\": [0, 0, 205],","\t\"mediumorchid\": [186, 85, 211],","\t\"mediumpurple\": [147, 112, 219],","\t\"mediumseagreen\": [60, 179, 113],","\t\"mediumslateblue\": [123, 104, 238],","\t\"mediumspringgreen\": [0, 250, 154],","\t\"mediumturquoise\": [72, 209, 204],","\t\"mediumvioletred\": [199, 21, 133],","\t\"midnightblue\": [25, 25, 112],","\t\"mintcream\": [245, 255, 250],","\t\"mistyrose\": [255, 228, 225],","\t\"moccasin\": [255, 228, 181],","\t\"navajowhite\": [255, 222, 173],","\t\"navy\": [0, 0, 128],","\t\"oldlace\": [253, 245, 230],","\t\"olive\": [128, 128, 0],","\t\"olivedrab\": [107, 142, 35],","\t\"orange\": [255, 165, 0],","\t\"orangered\": [255, 69, 0],","\t\"orchid\": [218, 112, 214],","\t\"palegoldenrod\": [238, 232, 170],","\t\"palegreen\": [152, 251, 152],","\t\"paleturquoise\": [175, 238, 238],","\t\"palevioletred\": [219, 112, 147],","\t\"papayawhip\": [255, 239, 213],","\t\"peachpuff\": [255, 218, 185],","\t\"peru\": [205, 133, 63],","\t\"pink\": [255, 192, 203],","\t\"plum\": [221, 160, 221],","\t\"powderblue\": [176, 224, 230],","\t\"purple\": [128, 0, 128],","\t\"rebeccapurple\": [102, 51, 153],","\t\"red\": [255, 0, 0],","\t\"rosybrown\": [188, 143, 143],","\t\"royalblue\": [65, 105, 225],","\t\"saddlebrown\": [139, 69, 19],","\t\"salmon\": [250, 128, 114],","\t\"sandybrown\": [244, 164, 96],","\t\"seagreen\": [46, 139, 87],","\t\"seashell\": [255, 245, 238],","\t\"sienna\": [160, 82, 45],","\t\"silver\": [192, 192, 192],","\t\"skyblue\": [135, 206, 235],","\t\"slateblue\": [106, 90, 205],","\t\"slategray\": [112, 128, 144],","\t\"slategrey\": [112, 128, 144],","\t\"snow\": [255, 250, 250],","\t\"springgreen\": [0, 255, 127],","\t\"steelblue\": [70, 130, 180],","\t\"tan\": [210, 180, 140],","\t\"teal\": [0, 128, 128],","\t\"thistle\": [216, 191, 216],","\t\"tomato\": [255, 99, 71],","\t\"turquoise\": [64, 224, 208],","\t\"violet\": [238, 130, 238],","\t\"wheat\": [245, 222, 179],","\t\"white\": [255, 255, 255],","\t\"whitesmoke\": [245, 245, 245],","\t\"yellow\": [255, 255, 0],","\t\"yellowgreen\": [154, 205, 50]","};","},{}],6:[function(require,module,exports){","//! moment.js","//! version : 2.13.0","//! authors : Tim Wood, Iskren Chernev, Moment.js contributors","//! license : MIT","//! momentjs.com","",";(function (global, factory) {","    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :","    typeof define === 'function' && define.amd ? define(factory) :","    global.moment = factory()","}(this, function () { 'use strict';","","    var hookCallback;","","    function utils_hooks__hooks () {","        return hookCallback.apply(null, arguments);","    }","","    // This is done to register the method called with moment()","    // without creating circular dependencies.","    function setHookCallback (callback) {","        hookCallback = callback;","    }","","    function isArray(input) {","        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';","    }","","    function isDate(input) {","        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';","    }","","    function map(arr, fn) {","        var res = [], i;","        for (i = 0; i < arr.length; ++i) {","            res.push(fn(arr[i], i));","        }","        return res;","    }","","    function hasOwnProp(a, b) {","        return Object.prototype.hasOwnProperty.call(a, b);","    }","","    function extend(a, b) {","        for (var i in b) {","            if (hasOwnProp(b, i)) {","                a[i] = b[i];","            }","        }","","        if (hasOwnProp(b, 'toString')) {","            a.toString = b.toString;","        }","","        if (hasOwnProp(b, 'valueOf')) {","            a.valueOf = b.valueOf;","        }","","        return a;","    }","","    function create_utc__createUTC (input, format, locale, strict) {","        return createLocalOrUTC(input, format, locale, strict, true).utc();","    }","","    function defaultParsingFlags() {","        // We need to deep clone this object.","        return {","            empty           : false,","            unusedTokens    : [],","            unusedInput     : [],","            overflow        : -2,","            charsLeftOver   : 0,","            nullInput       : false,","            invalidMonth    : null,","            invalidFormat   : false,","            userInvalidated : false,","            iso             : false,","            parsedDateParts : [],","            meridiem        : null","        };","    }","","    function getParsingFlags(m) {","        if (m._pf == null) {","            m._pf = defaultParsingFlags();","        }","        return m._pf;","    }","","    var some;","    if (Array.prototype.some) {","        some = Array.prototype.some;","    } else {","        some = function (fun) {","            var t = Object(this);","            var len = t.length >>> 0;","","            for (var i = 0; i < len; i++) {","                if (i in t && fun.call(this, t[i], i, t)) {","                    return true;","                }","            }","","            return false;","        };","    }","","    function valid__isValid(m) {","        if (m._isValid == null) {","            var flags = getParsingFlags(m);","            var parsedParts = some.call(flags.parsedDateParts, function (i) {","                return i != null;","            });","            m._isValid = !isNaN(m._d.getTime()) &&","                flags.overflow < 0 &&","                !flags.empty &&","                !flags.invalidMonth &&","                !flags.invalidWeekday &&","                !flags.nullInput &&","                !flags.invalidFormat &&","                !flags.userInvalidated &&","                (!flags.meridiem || (flags.meridiem && parsedParts));","","            if (m._strict) {","                m._isValid = m._isValid &&","                    flags.charsLeftOver === 0 &&","                    flags.unusedTokens.length === 0 &&","                    flags.bigHour === undefined;","            }","        }","        return m._isValid;","    }","","    function valid__createInvalid (flags) {","        var m = create_utc__createUTC(NaN);","        if (flags != null) {","            extend(getParsingFlags(m), flags);","        }","        else {","            getParsingFlags(m).userInvalidated = true;","        }","","        return m;","    }","","    function isUndefined(input) {","        return input === void 0;","    }","","    // Plugins that add properties should also add the key here (null value),","    // so we can properly clone ourselves.","    var momentProperties = utils_hooks__hooks.momentProperties = [];","","    function copyConfig(to, from) {","        var i, prop, val;","","        if (!isUndefined(from._isAMomentObject)) {","            to._isAMomentObject = from._isAMomentObject;","        }","        if (!isUndefined(from._i)) {","            to._i = from._i;","        }","        if (!isUndefined(from._f)) {","            to._f = from._f;","        }","        if (!isUndefined(from._l)) {","            to._l = from._l;","        }","        if (!isUndefined(from._strict)) {","            to._strict = from._strict;","        }","        if (!isUndefined(from._tzm)) {","            to._tzm = from._tzm;","        }","        if (!isUndefined(from._isUTC)) {","            to._isUTC = from._isUTC;","        }","        if (!isUndefined(from._offset)) {","            to._offset = from._offset;","        }","        if (!isUndefined(from._pf)) {","            to._pf = getParsingFlags(from);","        }","        if (!isUndefined(from._locale)) {","            to._locale = from._locale;","        }","","        if (momentProperties.length > 0) {","            for (i in momentProperties) {","                prop = momentProperties[i];","                val = from[prop];","                if (!isUndefined(val)) {","                    to[prop] = val;","                }","            }","        }","","        return to;","    }","","    var updateInProgress = false;","","    // Moment prototype object","    function Moment(config) {","        copyConfig(this, config);","        this._d = new Date(config._d != null ? config._d.getTime() : NaN);","        // Prevent infinite loop in case updateOffset creates new moment","        // objects.","        if (updateInProgress === false) {","            updateInProgress = true;","            utils_hooks__hooks.updateOffset(this);","            updateInProgress = false;","        }","    }","","    function isMoment (obj) {","        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);","    }","","    function absFloor (number) {","        if (number < 0) {","            return Math.ceil(number);","        } else {","            return Math.floor(number);","        }","    }","","    function toInt(argumentForCoercion) {","        var coercedNumber = +argumentForCoercion,","            value = 0;","","        if (coercedNumber !== 0 && isFinite(coercedNumber)) {","            value = absFloor(coercedNumber);","        }","","        return value;","    }","","    // compare two arrays, return the number of differences","    function compareArrays(array1, array2, dontConvert) {","        var len = Math.min(array1.length, array2.length),","            lengthDiff = Math.abs(array1.length - array2.length),","            diffs = 0,","            i;","        for (i = 0; i < len; i++) {","            if ((dontConvert && array1[i] !== array2[i]) ||","                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {","                diffs++;","            }","        }","        return diffs + lengthDiff;","    }","","    function warn(msg) {","        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&","                (typeof console !==  'undefined') && console.warn) {","            console.warn('Deprecation warning: ' + msg);","        }","    }","","    function deprecate(msg, fn) {","        var firstTime = true;","","        return extend(function () {","            if (utils_hooks__hooks.deprecationHandler != null) {","                utils_hooks__hooks.deprecationHandler(null, msg);","            }","            if (firstTime) {","                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\\n' + (new Error()).stack);","                firstTime = false;","            }","            return fn.apply(this, arguments);","        }, fn);","    }","","    var deprecations = {};","","    function deprecateSimple(name, msg) {","        if (utils_hooks__hooks.deprecationHandler != null) {","            utils_hooks__hooks.deprecationHandler(name, msg);","        }","        if (!deprecations[name]) {","            warn(msg);","            deprecations[name] = true;","        }","    }","","    utils_hooks__hooks.suppressDeprecationWarnings = false;","    utils_hooks__hooks.deprecationHandler = null;","","    function isFunction(input) {","        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';","    }","","    function isObject(input) {","        return Object.prototype.toString.call(input) === '[object Object]';","    }","","    function locale_set__set (config) {","        var prop, i;","        for (i in config) {","            prop = config[i];","            if (isFunction(prop)) {","                this[i] = prop;","            } else {","                this['_' + i] = prop;","            }","        }","        this._config = config;","        // Lenient ordinal parsing accepts just a number in addition to","        // number + (possibly) stuff coming from _ordinalParseLenient.","        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\\d{1,2}/).source);","    }","","    function mergeConfigs(parentConfig, childConfig) {","        var res = extend({}, parentConfig), prop;","        for (prop in childConfig) {","            if (hasOwnProp(childConfig, prop)) {","                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {","                    res[prop] = {};","                    extend(res[prop], parentConfig[prop]);","                    extend(res[prop], childConfig[prop]);","                } else if (childConfig[prop] != null) {","                    res[prop] = childConfig[prop];","                } else {","                    delete res[prop];","                }","            }","        }","        return res;","    }","","    function Locale(config) {","        if (config != null) {","            this.set(config);","        }","    }","","    var keys;","","    if (Object.keys) {","        keys = Object.keys;","    } else {","        keys = function (obj) {","            var i, res = [];","            for (i in obj) {","                if (hasOwnProp(obj, i)) {","                    res.push(i);","                }","            }","            return res;","        };","    }","","    // internal storage for locale config files","    var locales = {};","    var globalLocale;","","    function normalizeLocale(key) {","        return key ? key.toLowerCase().replace('_', '-') : key;","    }","","    // pick the locale from the array","    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each","    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root","    function chooseLocale(names) {","        var i = 0, j, next, locale, split;","","        while (i < names.length) {","            split = normalizeLocale(names[i]).split('-');","            j = split.length;","            next = normalizeLocale(names[i + 1]);","            next = next ? next.split('-') : null;","            while (j > 0) {","                locale = loadLocale(split.slice(0, j).join('-'));","                if (locale) {","                    return locale;","                }","                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {","                    //the next array item is better than a shallower substring of this one","                    break;","                }","                j--;","            }","            i++;","        }","        return null;","    }","","    function loadLocale(name) {","        var oldLocale = null;","        // TODO: Find a better way to register and load all the locales in Node","        if (!locales[name] && (typeof module !== 'undefined') &&","                module && module.exports) {","            try {","                oldLocale = globalLocale._abbr;","                require('./locale/' + name);","                // because defineLocale currently also sets the global locale, we","                // want to undo that for lazy loaded locales","                locale_locales__getSetGlobalLocale(oldLocale);","            } catch (e) { }","        }","        return locales[name];","    }","","    // This function will load locale and then set the global locale.  If","    // no arguments are passed in, it will simply return the current global","    // locale key.","    function locale_locales__getSetGlobalLocale (key, values) {","        var data;","        if (key) {","            if (isUndefined(values)) {","                data = locale_locales__getLocale(key);","            }","            else {","                data = defineLocale(key, values);","            }","","            if (data) {","                // moment.duration._locale = moment._locale = data;","                globalLocale = data;","            }","        }","","        return globalLocale._abbr;","    }","","    function defineLocale (name, config) {","        if (config !== null) {","            config.abbr = name;","            if (locales[name] != null) {","                deprecateSimple('defineLocaleOverride',","                        'use moment.updateLocale(localeName, config) to change ' +","                        'an existing locale. moment.defineLocale(localeName, ' +","                        'config) should only be used for creating a new locale');","                config = mergeConfigs(locales[name]._config, config);","            } else if (config.parentLocale != null) {","                if (locales[config.parentLocale] != null) {","                    config = mergeConfigs(locales[config.parentLocale]._config, config);","                } else {","                    // treat as if there is no base config","                    deprecateSimple('parentLocaleUndefined',","                            'specified parentLocale is not defined yet');","                }","            }","            locales[name] = new Locale(config);","","            // backwards compat for now: also set the locale","            locale_locales__getSetGlobalLocale(name);","","            return locales[name];","        } else {","            // useful for testing","            delete locales[name];","            return null;","        }","    }","","    function updateLocale(name, config) {","        if (config != null) {","            var locale;","            if (locales[name] != null) {","                config = mergeConfigs(locales[name]._config, config);","            }","            locale = new Locale(config);","            locale.parentLocale = locales[name];","            locales[name] = locale;","","            // backwards compat for now: also set the locale","            locale_locales__getSetGlobalLocale(name);","        } else {","            // pass null for config to unupdate, useful for tests","            if (locales[name] != null) {","                if (locales[name].parentLocale != null) {","                    locales[name] = locales[name].parentLocale;","                } else if (locales[name] != null) {","                    delete locales[name];","                }","            }","        }","        return locales[name];","    }","","    // returns locale data","    function locale_locales__getLocale (key) {","        var locale;","","        if (key && key._locale && key._locale._abbr) {","            key = key._locale._abbr;","        }","","        if (!key) {","            return globalLocale;","        }","","        if (!isArray(key)) {","            //short-circuit everything else","            locale = loadLocale(key);","            if (locale) {","                return locale;","            }","            key = [key];","        }","","        return chooseLocale(key);","    }","","    function locale_locales__listLocales() {","        return keys(locales);","    }","","    var aliases = {};","","    function addUnitAlias (unit, shorthand) {","        var lowerCase = unit.toLowerCase();","        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;","    }","","    function normalizeUnits(units) {","        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;","    }","","    function normalizeObjectUnits(inputObject) {","        var normalizedInput = {},","            normalizedProp,","            prop;","","        for (prop in inputObject) {","            if (hasOwnProp(inputObject, prop)) {","                normalizedProp = normalizeUnits(prop);","                if (normalizedProp) {","                    normalizedInput[normalizedProp] = inputObject[prop];","                }","            }","        }","","        return normalizedInput;","    }","","    function makeGetSet (unit, keepTime) {","        return function (value) {","            if (value != null) {","                get_set__set(this, unit, value);","                utils_hooks__hooks.updateOffset(this, keepTime);","                return this;","            } else {","                return get_set__get(this, unit);","            }","        };","    }","","    function get_set__get (mom, unit) {","        return mom.isValid() ?","            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;","    }","","    function get_set__set (mom, unit, value) {","        if (mom.isValid()) {","            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);","        }","    }","","    // MOMENTS","","    function getSet (units, value) {","        var unit;","        if (typeof units === 'object') {","            for (unit in units) {","                this.set(unit, units[unit]);","            }","        } else {","            units = normalizeUnits(units);","            if (isFunction(this[units])) {","                return this[units](value);","            }","        }","        return this;","    }","","    function zeroFill(number, targetLength, forceSign) {","        var absNumber = '' + Math.abs(number),","            zerosToFill = targetLength - absNumber.length,","            sign = number >= 0;","        return (sign ? (forceSign ? '+' : '') : '-') +","            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;","    }","","    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;","","    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;","","    var formatFunctions = {};","","    var formatTokenFunctions = {};","","    // token:    'M'","    // padded:   ['MM', 2]","    // ordinal:  'Mo'","    // callback: function () { this.month() + 1 }","    function addFormatToken (token, padded, ordinal, callback) {","        var func = callback;","        if (typeof callback === 'string') {","            func = function () {","                return this[callback]();","            };","        }","        if (token) {","            formatTokenFunctions[token] = func;","        }","        if (padded) {","            formatTokenFunctions[padded[0]] = function () {","                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);","            };","        }","        if (ordinal) {","            formatTokenFunctions[ordinal] = function () {","                return this.localeData().ordinal(func.apply(this, arguments), token);","            };","        }","    }","","    function removeFormattingTokens(input) {","        if (input.match(/\\[[\\s\\S]/)) {","            return input.replace(/^\\[|\\]$/g, '');","        }","        return input.replace(/\\\\/g, '');","    }","","    function makeFormatFunction(format) {","        var array = format.match(formattingTokens), i, length;","","        for (i = 0, length = array.length; i < length; i++) {","            if (formatTokenFunctions[array[i]]) {","                array[i] = formatTokenFunctions[array[i]];","            } else {","                array[i] = removeFormattingTokens(array[i]);","            }","        }","","        return function (mom) {","            var output = '', i;","            for (i = 0; i < length; i++) {","                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];","            }","            return output;","        };","    }","","    // format date using native date object","    function formatMoment(m, format) {","        if (!m.isValid()) {","            return m.localeData().invalidDate();","        }","","        format = expandFormat(format, m.localeData());","        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);","","        return formatFunctions[format](m);","    }","","    function expandFormat(format, locale) {","        var i = 5;","","        function replaceLongDateFormatTokens(input) {","            return locale.longDateFormat(input) || input;","        }","","        localFormattingTokens.lastIndex = 0;","        while (i >= 0 && localFormattingTokens.test(format)) {","            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);","            localFormattingTokens.lastIndex = 0;","            i -= 1;","        }","","        return format;","    }","","    var match1         = /\\d/;            //       0 - 9","    var match2         = /\\d\\d/;          //      00 - 99","    var match3         = /\\d{3}/;         //     000 - 999","    var match4         = /\\d{4}/;         //    0000 - 9999","    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999","    var match1to2      = /\\d\\d?/;         //       0 - 99","    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999","    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999","    var match1to3      = /\\d{1,3}/;       //       0 - 999","    var match1to4      = /\\d{1,4}/;       //       0 - 9999","    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999","","    var matchUnsigned  = /\\d+/;           //       0 - inf","    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf","","    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z","    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z","","    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123","","    // any word (or two) characters or numbers including two/three word month in arabic.","    // includes scottish gaelic two word and hyphenated months","    var matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;","","","    var regexes = {};","","    function addRegexToken (token, regex, strictRegex) {","        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {","            return (isStrict && strictRegex) ? strictRegex : regex;","        };","    }","","    function getParseRegexForToken (token, config) {","        if (!hasOwnProp(regexes, token)) {","            return new RegExp(unescapeFormat(token));","        }","","        return regexes[token](config._strict, config._locale);","    }","","    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript","    function unescapeFormat(s) {","        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {","            return p1 || p2 || p3 || p4;","        }));","    }","","    function regexEscape(s) {","        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');","    }","","    var tokens = {};","","    function addParseToken (token, callback) {","        var i, func = callback;","        if (typeof token === 'string') {","            token = [token];","        }","        if (typeof callback === 'number') {","            func = function (input, array) {","                array[callback] = toInt(input);","            };","        }","        for (i = 0; i < token.length; i++) {","            tokens[token[i]] = func;","        }","    }","","    function addWeekParseToken (token, callback) {","        addParseToken(token, function (input, array, config, token) {","            config._w = config._w || {};","            callback(input, config._w, config, token);","        });","    }","","    function addTimeToArrayFromToken(token, input, config) {","        if (input != null && hasOwnProp(tokens, token)) {","            tokens[token](input, config._a, config, token);","        }","    }","","    var YEAR = 0;","    var MONTH = 1;","    var DATE = 2;","    var HOUR = 3;","    var MINUTE = 4;","    var SECOND = 5;","    var MILLISECOND = 6;","    var WEEK = 7;","    var WEEKDAY = 8;","","    var indexOf;","","    if (Array.prototype.indexOf) {","        indexOf = Array.prototype.indexOf;","    } else {","        indexOf = function (o) {","            // I know","            var i;","            for (i = 0; i < this.length; ++i) {","                if (this[i] === o) {","                    return i;","                }","            }","            return -1;","        };","    }","","    function daysInMonth(year, month) {","        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();","    }","","    // FORMATTING","","    addFormatToken('M', ['MM', 2], 'Mo', function () {","        return this.month() + 1;","    });","","    addFormatToken('MMM', 0, 0, function (format) {","        return this.localeData().monthsShort(this, format);","    });","","    addFormatToken('MMMM', 0, 0, function (format) {","        return this.localeData().months(this, format);","    });","","    // ALIASES","","    addUnitAlias('month', 'M');","","    // PARSING","","    addRegexToken('M',    match1to2);","    addRegexToken('MM',   match1to2, match2);","    addRegexToken('MMM',  function (isStrict, locale) {","        return locale.monthsShortRegex(isStrict);","    });","    addRegexToken('MMMM', function (isStrict, locale) {","        return locale.monthsRegex(isStrict);","    });","","    addParseToken(['M', 'MM'], function (input, array) {","        array[MONTH] = toInt(input) - 1;","    });","","    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {","        var month = config._locale.monthsParse(input, token, config._strict);","        // if we didn't find a month name, mark the date as invalid.","        if (month != null) {","            array[MONTH] = month;","        } else {","            getParsingFlags(config).invalidMonth = input;","        }","    });","","    // LOCALES","","    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s+)+MMMM?/;","    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');","    function localeMonths (m, format) {","        return isArray(this._months) ? this._months[m.month()] :","            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];","    }","","    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');","    function localeMonthsShort (m, format) {","        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :","            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];","    }","","    function units_month__handleStrictParse(monthName, format, strict) {","        var i, ii, mom, llc = monthName.toLocaleLowerCase();","        if (!this._monthsParse) {","            // this is not used","            this._monthsParse = [];","            this._longMonthsParse = [];","            this._shortMonthsParse = [];","            for (i = 0; i < 12; ++i) {","                mom = create_utc__createUTC([2000, i]);","                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();","                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();","            }","        }","","        if (strict) {","            if (format === 'MMM') {","                ii = indexOf.call(this._shortMonthsParse, llc);","                return ii !== -1 ? ii : null;","            } else {","                ii = indexOf.call(this._longMonthsParse, llc);","                return ii !== -1 ? ii : null;","            }","        } else {","            if (format === 'MMM') {","                ii = indexOf.call(this._shortMonthsParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._longMonthsParse, llc);","                return ii !== -1 ? ii : null;","            } else {","                ii = indexOf.call(this._longMonthsParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._shortMonthsParse, llc);","                return ii !== -1 ? ii : null;","            }","        }","    }","","    function localeMonthsParse (monthName, format, strict) {","        var i, mom, regex;","","        if (this._monthsParseExact) {","            return units_month__handleStrictParse.call(this, monthName, format, strict);","        }","","        if (!this._monthsParse) {","            this._monthsParse = [];","            this._longMonthsParse = [];","            this._shortMonthsParse = [];","        }","","        // TODO: add sorting","        // Sorting makes sure if one month (or abbr) is a prefix of another","        // see sorting in computeMonthsParse","        for (i = 0; i < 12; i++) {","            // make the regex if we don't have it already","            mom = create_utc__createUTC([2000, i]);","            if (strict && !this._longMonthsParse[i]) {","                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');","                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');","            }","            if (!strict && !this._monthsParse[i]) {","                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');","                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');","            }","            // test the regex","            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {","                return i;","            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {","                return i;","            } else if (!strict && this._monthsParse[i].test(monthName)) {","                return i;","            }","        }","    }","","    // MOMENTS","","    function setMonth (mom, value) {","        var dayOfMonth;","","        if (!mom.isValid()) {","            // No op","            return mom;","        }","","        if (typeof value === 'string') {","            if (/^\\d+$/.test(value)) {","                value = toInt(value);","            } else {","                value = mom.localeData().monthsParse(value);","                // TODO: Another silent failure?","                if (typeof value !== 'number') {","                    return mom;","                }","            }","        }","","        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));","        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);","        return mom;","    }","","    function getSetMonth (value) {","        if (value != null) {","            setMonth(this, value);","            utils_hooks__hooks.updateOffset(this, true);","            return this;","        } else {","            return get_set__get(this, 'Month');","        }","    }","","    function getDaysInMonth () {","        return daysInMonth(this.year(), this.month());","    }","","    var defaultMonthsShortRegex = matchWord;","    function monthsShortRegex (isStrict) {","        if (this._monthsParseExact) {","            if (!hasOwnProp(this, '_monthsRegex')) {","                computeMonthsParse.call(this);","            }","            if (isStrict) {","                return this._monthsShortStrictRegex;","            } else {","                return this._monthsShortRegex;","            }","        } else {","            return this._monthsShortStrictRegex && isStrict ?","                this._monthsShortStrictRegex : this._monthsShortRegex;","        }","    }","","    var defaultMonthsRegex = matchWord;","    function monthsRegex (isStrict) {","        if (this._monthsParseExact) {","            if (!hasOwnProp(this, '_monthsRegex')) {","                computeMonthsParse.call(this);","            }","            if (isStrict) {","                return this._monthsStrictRegex;","            } else {","                return this._monthsRegex;","            }","        } else {","            return this._monthsStrictRegex && isStrict ?","                this._monthsStrictRegex : this._monthsRegex;","        }","    }","","    function computeMonthsParse () {","        function cmpLenRev(a, b) {","            return b.length - a.length;","        }","","        var shortPieces = [], longPieces = [], mixedPieces = [],","            i, mom;","        for (i = 0; i < 12; i++) {","            // make the regex if we don't have it already","            mom = create_utc__createUTC([2000, i]);","            shortPieces.push(this.monthsShort(mom, ''));","            longPieces.push(this.months(mom, ''));","            mixedPieces.push(this.months(mom, ''));","            mixedPieces.push(this.monthsShort(mom, ''));","        }","        // Sorting makes sure if one month (or abbr) is a prefix of another it","        // will match the longer piece.","        shortPieces.sort(cmpLenRev);","        longPieces.sort(cmpLenRev);","        mixedPieces.sort(cmpLenRev);","        for (i = 0; i < 12; i++) {","            shortPieces[i] = regexEscape(shortPieces[i]);","            longPieces[i] = regexEscape(longPieces[i]);","            mixedPieces[i] = regexEscape(mixedPieces[i]);","        }","","        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');","        this._monthsShortRegex = this._monthsRegex;","        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');","        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');","    }","","    function checkOverflow (m) {","        var overflow;","        var a = m._a;","","        if (a && getParsingFlags(m).overflow === -2) {","            overflow =","                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :","                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :","                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :","                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :","                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :","                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :","                -1;","","            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {","                overflow = DATE;","            }","            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {","                overflow = WEEK;","            }","            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {","                overflow = WEEKDAY;","            }","","            getParsingFlags(m).overflow = overflow;","        }","","        return m;","    }","","    // iso 8601 regex","    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)","    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;","    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?/;","","    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;","","    var isoDates = [","        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],","        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],","        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],","        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],","        ['YYYY-DDD', /\\d{4}-\\d{3}/],","        ['YYYY-MM', /\\d{4}-\\d\\d/, false],","        ['YYYYYYMMDD', /[+-]\\d{10}/],","        ['YYYYMMDD', /\\d{8}/],","        // YYYYMM is NOT allowed by the standard","        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],","        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],","        ['YYYYDDD', /\\d{7}/]","    ];","","    // iso time formats and regexes","    var isoTimes = [","        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],","        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],","        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],","        ['HH:mm', /\\d\\d:\\d\\d/],","        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],","        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],","        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],","        ['HHmm', /\\d\\d\\d\\d/],","        ['HH', /\\d\\d/]","    ];","","    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;","","    // date from iso format","    function configFromISO(config) {","        var i, l,","            string = config._i,","            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),","            allowTime, dateFormat, timeFormat, tzFormat;","","        if (match) {","            getParsingFlags(config).iso = true;","","            for (i = 0, l = isoDates.length; i < l; i++) {","                if (isoDates[i][1].exec(match[1])) {","                    dateFormat = isoDates[i][0];","                    allowTime = isoDates[i][2] !== false;","                    break;","                }","            }","            if (dateFormat == null) {","                config._isValid = false;","                return;","            }","            if (match[3]) {","                for (i = 0, l = isoTimes.length; i < l; i++) {","                    if (isoTimes[i][1].exec(match[3])) {","                        // match[2] should be 'T' or space","                        timeFormat = (match[2] || ' ') + isoTimes[i][0];","                        break;","                    }","                }","                if (timeFormat == null) {","                    config._isValid = false;","                    return;","                }","            }","            if (!allowTime && timeFormat != null) {","                config._isValid = false;","                return;","            }","            if (match[4]) {","                if (tzRegex.exec(match[4])) {","                    tzFormat = 'Z';","                } else {","                    config._isValid = false;","                    return;","                }","            }","            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');","            configFromStringAndFormat(config);","        } else {","            config._isValid = false;","        }","    }","","    // date from iso format or fallback","    function configFromString(config) {","        var matched = aspNetJsonRegex.exec(config._i);","","        if (matched !== null) {","            config._d = new Date(+matched[1]);","            return;","        }","","        configFromISO(config);","        if (config._isValid === false) {","            delete config._isValid;","            utils_hooks__hooks.createFromInputFallback(config);","        }","    }","","    utils_hooks__hooks.createFromInputFallback = deprecate(","        'moment construction falls back to js Date. This is ' +","        'discouraged and will be removed in upcoming major ' +","        'release. Please refer to ' +","        'https://github.com/moment/moment/issues/1407 for more info.',","        function (config) {","            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));","        }","    );","","    function createDate (y, m, d, h, M, s, ms) {","        //can't just apply() to create a date:","        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply","        var date = new Date(y, m, d, h, M, s, ms);","","        //the date constructor remaps years 0-99 to 1900-1999","        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {","            date.setFullYear(y);","        }","        return date;","    }","","    function createUTCDate (y) {","        var date = new Date(Date.UTC.apply(null, arguments));","","        //the Date.UTC function remaps years 0-99 to 1900-1999","        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {","            date.setUTCFullYear(y);","        }","        return date;","    }","","    // FORMATTING","","    addFormatToken('Y', 0, 0, function () {","        var y = this.year();","        return y <= 9999 ? '' + y : '+' + y;","    });","","    addFormatToken(0, ['YY', 2], 0, function () {","        return this.year() % 100;","    });","","    addFormatToken(0, ['YYYY',   4],       0, 'year');","    addFormatToken(0, ['YYYYY',  5],       0, 'year');","    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');","","    // ALIASES","","    addUnitAlias('year', 'y');","","    // PARSING","","    addRegexToken('Y',      matchSigned);","    addRegexToken('YY',     match1to2, match2);","    addRegexToken('YYYY',   match1to4, match4);","    addRegexToken('YYYYY',  match1to6, match6);","    addRegexToken('YYYYYY', match1to6, match6);","","    addParseToken(['YYYYY', 'YYYYYY'], YEAR);","    addParseToken('YYYY', function (input, array) {","        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);","    });","    addParseToken('YY', function (input, array) {","        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);","    });","    addParseToken('Y', function (input, array) {","        array[YEAR] = parseInt(input, 10);","    });","","    // HELPERS","","    function daysInYear(year) {","        return isLeapYear(year) ? 366 : 365;","    }","","    function isLeapYear(year) {","        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;","    }","","    // HOOKS","","    utils_hooks__hooks.parseTwoDigitYear = function (input) {","        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);","    };","","    // MOMENTS","","    var getSetYear = makeGetSet('FullYear', true);","","    function getIsLeapYear () {","        return isLeapYear(this.year());","    }","","    // start-of-first-week - start-of-year","    function firstWeekOffset(year, dow, doy) {","        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)","            fwd = 7 + dow - doy,","            // first-week day local weekday -- which local weekday is fwd","            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;","","        return -fwdlw + fwd - 1;","    }","","    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday","    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {","        var localWeekday = (7 + weekday - dow) % 7,","            weekOffset = firstWeekOffset(year, dow, doy),","            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,","            resYear, resDayOfYear;","","        if (dayOfYear <= 0) {","            resYear = year - 1;","            resDayOfYear = daysInYear(resYear) + dayOfYear;","        } else if (dayOfYear > daysInYear(year)) {","            resYear = year + 1;","            resDayOfYear = dayOfYear - daysInYear(year);","        } else {","            resYear = year;","            resDayOfYear = dayOfYear;","        }","","        return {","            year: resYear,","            dayOfYear: resDayOfYear","        };","    }","","    function weekOfYear(mom, dow, doy) {","        var weekOffset = firstWeekOffset(mom.year(), dow, doy),","            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,","            resWeek, resYear;","","        if (week < 1) {","            resYear = mom.year() - 1;","            resWeek = week + weeksInYear(resYear, dow, doy);","        } else if (week > weeksInYear(mom.year(), dow, doy)) {","            resWeek = week - weeksInYear(mom.year(), dow, doy);","            resYear = mom.year() + 1;","        } else {","            resYear = mom.year();","            resWeek = week;","        }","","        return {","            week: resWeek,","            year: resYear","        };","    }","","    function weeksInYear(year, dow, doy) {","        var weekOffset = firstWeekOffset(year, dow, doy),","            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);","        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;","    }","","    // Pick the first defined of two or three arguments.","    function defaults(a, b, c) {","        if (a != null) {","            return a;","        }","        if (b != null) {","            return b;","        }","        return c;","    }","","    function currentDateArray(config) {","        // hooks is actually the exported moment object","        var nowValue = new Date(utils_hooks__hooks.now());","        if (config._useUTC) {","            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];","        }","        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];","    }","","    // convert an array to a date.","    // the array should mirror the parameters below","    // note: all values past the year are optional and will default to the lowest possible value.","    // [year, month, day , hour, minute, second, millisecond]","    function configFromArray (config) {","        var i, date, input = [], currentDate, yearToUse;","","        if (config._d) {","            return;","        }","","        currentDate = currentDateArray(config);","","        //compute day of the year from weeks and weekdays","        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {","            dayOfYearFromWeekInfo(config);","        }","","        //if the day of the year is set, figure out what it is","        if (config._dayOfYear) {","            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);","","            if (config._dayOfYear > daysInYear(yearToUse)) {","                getParsingFlags(config)._overflowDayOfYear = true;","            }","","            date = createUTCDate(yearToUse, 0, config._dayOfYear);","            config._a[MONTH] = date.getUTCMonth();","            config._a[DATE] = date.getUTCDate();","        }","","        // Default to current date.","        // * if no year, month, day of month are given, default to today","        // * if day of month is given, default month and year","        // * if month is given, default only year","        // * if year is given, don't default anything","        for (i = 0; i < 3 && config._a[i] == null; ++i) {","            config._a[i] = input[i] = currentDate[i];","        }","","        // Zero out whatever was not defaulted, including time","        for (; i < 7; i++) {","            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];","        }","","        // Check for 24:00:00.000","        if (config._a[HOUR] === 24 &&","                config._a[MINUTE] === 0 &&","                config._a[SECOND] === 0 &&","                config._a[MILLISECOND] === 0) {","            config._nextDay = true;","            config._a[HOUR] = 0;","        }","","        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);","        // Apply timezone offset from input. The actual utcOffset can be changed","        // with parseZone.","        if (config._tzm != null) {","            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);","        }","","        if (config._nextDay) {","            config._a[HOUR] = 24;","        }","    }","","    function dayOfYearFromWeekInfo(config) {","        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;","","        w = config._w;","        if (w.GG != null || w.W != null || w.E != null) {","            dow = 1;","            doy = 4;","","            // TODO: We need to take the current isoWeekYear, but that depends on","            // how we interpret now (local, utc, fixed offset). So create","            // a now version of current config (take local/utc/offset flags, and","            // create now).","            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);","            week = defaults(w.W, 1);","            weekday = defaults(w.E, 1);","            if (weekday < 1 || weekday > 7) {","                weekdayOverflow = true;","            }","        } else {","            dow = config._locale._week.dow;","            doy = config._locale._week.doy;","","            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);","            week = defaults(w.w, 1);","","            if (w.d != null) {","                // weekday -- low day numbers are considered next week","                weekday = w.d;","                if (weekday < 0 || weekday > 6) {","                    weekdayOverflow = true;","                }","            } else if (w.e != null) {","                // local weekday -- counting starts from begining of week","                weekday = w.e + dow;","                if (w.e < 0 || w.e > 6) {","                    weekdayOverflow = true;","                }","            } else {","                // default to begining of week","                weekday = dow;","            }","        }","        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {","            getParsingFlags(config)._overflowWeeks = true;","        } else if (weekdayOverflow != null) {","            getParsingFlags(config)._overflowWeekday = true;","        } else {","            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);","            config._a[YEAR] = temp.year;","            config._dayOfYear = temp.dayOfYear;","        }","    }","","    // constant that refers to the ISO standard","    utils_hooks__hooks.ISO_8601 = function () {};","","    // date from string and format string","    function configFromStringAndFormat(config) {","        // TODO: Move this to another part of the creation flow to prevent circular deps","        if (config._f === utils_hooks__hooks.ISO_8601) {","            configFromISO(config);","            return;","        }","","        config._a = [];","        getParsingFlags(config).empty = true;","","        // This array is used to make a Date, either with `new Date` or `Date.UTC`","        var string = '' + config._i,","            i, parsedInput, tokens, token, skipped,","            stringLength = string.length,","            totalParsedInputLength = 0;","","        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];","","        for (i = 0; i < tokens.length; i++) {","            token = tokens[i];","            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];","            // console.log('token', token, 'parsedInput', parsedInput,","            //         'regex', getParseRegexForToken(token, config));","            if (parsedInput) {","                skipped = string.substr(0, string.indexOf(parsedInput));","                if (skipped.length > 0) {","                    getParsingFlags(config).unusedInput.push(skipped);","                }","                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);","                totalParsedInputLength += parsedInput.length;","            }","            // don't parse if it's not a known token","            if (formatTokenFunctions[token]) {","                if (parsedInput) {","                    getParsingFlags(config).empty = false;","                }","                else {","                    getParsingFlags(config).unusedTokens.push(token);","                }","                addTimeToArrayFromToken(token, parsedInput, config);","            }","            else if (config._strict && !parsedInput) {","                getParsingFlags(config).unusedTokens.push(token);","            }","        }","","        // add remaining unparsed input length to the string","        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;","        if (string.length > 0) {","            getParsingFlags(config).unusedInput.push(string);","        }","","        // clear _12h flag if hour is <= 12","        if (getParsingFlags(config).bigHour === true &&","                config._a[HOUR] <= 12 &&","                config._a[HOUR] > 0) {","            getParsingFlags(config).bigHour = undefined;","        }","","        getParsingFlags(config).parsedDateParts = config._a.slice(0);","        getParsingFlags(config).meridiem = config._meridiem;","        // handle meridiem","        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);","","        configFromArray(config);","        checkOverflow(config);","    }","","","    function meridiemFixWrap (locale, hour, meridiem) {","        var isPm;","","        if (meridiem == null) {","            // nothing to do","            return hour;","        }","        if (locale.meridiemHour != null) {","            return locale.meridiemHour(hour, meridiem);","        } else if (locale.isPM != null) {","            // Fallback","            isPm = locale.isPM(meridiem);","            if (isPm && hour < 12) {","                hour += 12;","            }","            if (!isPm && hour === 12) {","                hour = 0;","            }","            return hour;","        } else {","            // this is not supposed to happen","            return hour;","        }","    }","","    // date from string and array of format strings","    function configFromStringAndArray(config) {","        var tempConfig,","            bestMoment,","","            scoreToBeat,","            i,","            currentScore;","","        if (config._f.length === 0) {","            getParsingFlags(config).invalidFormat = true;","            config._d = new Date(NaN);","            return;","        }","","        for (i = 0; i < config._f.length; i++) {","            currentScore = 0;","            tempConfig = copyConfig({}, config);","            if (config._useUTC != null) {","                tempConfig._useUTC = config._useUTC;","            }","            tempConfig._f = config._f[i];","            configFromStringAndFormat(tempConfig);","","            if (!valid__isValid(tempConfig)) {","                continue;","            }","","            // if there is any input that was not parsed add a penalty for that format","            currentScore += getParsingFlags(tempConfig).charsLeftOver;","","            //or tokens","            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;","","            getParsingFlags(tempConfig).score = currentScore;","","            if (scoreToBeat == null || currentScore < scoreToBeat) {","                scoreToBeat = currentScore;","                bestMoment = tempConfig;","            }","        }","","        extend(config, bestMoment || tempConfig);","    }","","    function configFromObject(config) {","        if (config._d) {","            return;","        }","","        var i = normalizeObjectUnits(config._i);","        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {","            return obj && parseInt(obj, 10);","        });","","        configFromArray(config);","    }","","    function createFromConfig (config) {","        var res = new Moment(checkOverflow(prepareConfig(config)));","        if (res._nextDay) {","            // Adding is smart enough around DST","            res.add(1, 'd');","            res._nextDay = undefined;","        }","","        return res;","    }","","    function prepareConfig (config) {","        var input = config._i,","            format = config._f;","","        config._locale = config._locale || locale_locales__getLocale(config._l);","","        if (input === null || (format === undefined && input === '')) {","            return valid__createInvalid({nullInput: true});","        }","","        if (typeof input === 'string') {","            config._i = input = config._locale.preparse(input);","        }","","        if (isMoment(input)) {","            return new Moment(checkOverflow(input));","        } else if (isArray(format)) {","            configFromStringAndArray(config);","        } else if (format) {","            configFromStringAndFormat(config);","        } else if (isDate(input)) {","            config._d = input;","        } else {","            configFromInput(config);","        }","","        if (!valid__isValid(config)) {","            config._d = null;","        }","","        return config;","    }","","    function configFromInput(config) {","        var input = config._i;","        if (input === undefined) {","            config._d = new Date(utils_hooks__hooks.now());","        } else if (isDate(input)) {","            config._d = new Date(input.valueOf());","        } else if (typeof input === 'string') {","            configFromString(config);","        } else if (isArray(input)) {","            config._a = map(input.slice(0), function (obj) {","                return parseInt(obj, 10);","            });","            configFromArray(config);","        } else if (typeof(input) === 'object') {","            configFromObject(config);","        } else if (typeof(input) === 'number') {","            // from milliseconds","            config._d = new Date(input);","        } else {","            utils_hooks__hooks.createFromInputFallback(config);","        }","    }","","    function createLocalOrUTC (input, format, locale, strict, isUTC) {","        var c = {};","","        if (typeof(locale) === 'boolean') {","            strict = locale;","            locale = undefined;","        }","        // object construction must be done this way.","        // https://github.com/moment/moment/issues/1423","        c._isAMomentObject = true;","        c._useUTC = c._isUTC = isUTC;","        c._l = locale;","        c._i = input;","        c._f = format;","        c._strict = strict;","","        return createFromConfig(c);","    }","","    function local__createLocal (input, format, locale, strict) {","        return createLocalOrUTC(input, format, locale, strict, false);","    }","","    var prototypeMin = deprecate(","         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',","         function () {","             var other = local__createLocal.apply(null, arguments);","             if (this.isValid() && other.isValid()) {","                 return other < this ? this : other;","             } else {","                 return valid__createInvalid();","             }","         }","     );","","    var prototypeMax = deprecate(","        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',","        function () {","            var other = local__createLocal.apply(null, arguments);","            if (this.isValid() && other.isValid()) {","                return other > this ? this : other;","            } else {","                return valid__createInvalid();","            }","        }","    );","","    // Pick a moment m from moments so that m[fn](other) is true for all","    // other. This relies on the function fn to be transitive.","    //","    // moments should either be an array of moment objects or an array, whose","    // first element is an array of moment objects.","    function pickBy(fn, moments) {","        var res, i;","        if (moments.length === 1 && isArray(moments[0])) {","            moments = moments[0];","        }","        if (!moments.length) {","            return local__createLocal();","        }","        res = moments[0];","        for (i = 1; i < moments.length; ++i) {","            if (!moments[i].isValid() || moments[i][fn](res)) {","                res = moments[i];","            }","        }","        return res;","    }","","    // TODO: Use [].sort instead?","    function min () {","        var args = [].slice.call(arguments, 0);","","        return pickBy('isBefore', args);","    }","","    function max () {","        var args = [].slice.call(arguments, 0);","","        return pickBy('isAfter', args);","    }","","    var now = function () {","        return Date.now ? Date.now() : +(new Date());","    };","","    function Duration (duration) {","        var normalizedInput = normalizeObjectUnits(duration),","            years = normalizedInput.year || 0,","            quarters = normalizedInput.quarter || 0,","            months = normalizedInput.month || 0,","            weeks = normalizedInput.week || 0,","            days = normalizedInput.day || 0,","            hours = normalizedInput.hour || 0,","            minutes = normalizedInput.minute || 0,","            seconds = normalizedInput.second || 0,","            milliseconds = normalizedInput.millisecond || 0;","","        // representation for dateAddRemove","        this._milliseconds = +milliseconds +","            seconds * 1e3 + // 1000","            minutes * 6e4 + // 1000 * 60","            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978","        // Because of dateAddRemove treats 24 hours as different from a","        // day when working around DST, we need to store them separately","        this._days = +days +","            weeks * 7;","        // It is impossible translate months into days without knowing","        // which months you are are talking about, so we have to store","        // it separately.","        this._months = +months +","            quarters * 3 +","            years * 12;","","        this._data = {};","","        this._locale = locale_locales__getLocale();","","        this._bubble();","    }","","    function isDuration (obj) {","        return obj instanceof Duration;","    }","","    // FORMATTING","","    function offset (token, separator) {","        addFormatToken(token, 0, 0, function () {","            var offset = this.utcOffset();","            var sign = '+';","            if (offset < 0) {","                offset = -offset;","                sign = '-';","            }","            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);","        });","    }","","    offset('Z', ':');","    offset('ZZ', '');","","    // PARSING","","    addRegexToken('Z',  matchShortOffset);","    addRegexToken('ZZ', matchShortOffset);","    addParseToken(['Z', 'ZZ'], function (input, array, config) {","        config._useUTC = true;","        config._tzm = offsetFromString(matchShortOffset, input);","    });","","    // HELPERS","","    // timezone chunker","    // '+10:00' > ['10',  '00']","    // '-1530'  > ['-15', '30']","    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;","","    function offsetFromString(matcher, string) {","        var matches = ((string || '').match(matcher) || []);","        var chunk   = matches[matches.length - 1] || [];","        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];","        var minutes = +(parts[1] * 60) + toInt(parts[2]);","","        return parts[0] === '+' ? minutes : -minutes;","    }","","    // Return a moment from input, that is local/utc/zone equivalent to model.","    function cloneWithOffset(input, model) {","        var res, diff;","        if (model._isUTC) {","            res = model.clone();","            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();","            // Use low-level api, because this fn is low-level api.","            res._d.setTime(res._d.valueOf() + diff);","            utils_hooks__hooks.updateOffset(res, false);","            return res;","        } else {","            return local__createLocal(input).local();","        }","    }","","    function getDateOffset (m) {","        // On Firefox.24 Date#getTimezoneOffset returns a floating point.","        // https://github.com/moment/moment/pull/1871","        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;","    }","","    // HOOKS","","    // This function will be called whenever a moment is mutated.","    // It is intended to keep the offset in sync with the timezone.","    utils_hooks__hooks.updateOffset = function () {};","","    // MOMENTS","","    // keepLocalTime = true means only change the timezone, without","    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->","    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset","    // +0200, so we adjust the time as needed, to be valid.","    //","    // Keeping the time actually adds/subtracts (one hour)","    // from the actual represented time. That is why we call updateOffset","    // a second time. In case it wants us to change the offset again","    // _changeInProgress == true case, then we have to adjust, because","    // there is no such time in the given timezone.","    function getSetOffset (input, keepLocalTime) {","        var offset = this._offset || 0,","            localAdjust;","        if (!this.isValid()) {","            return input != null ? this : NaN;","        }","        if (input != null) {","            if (typeof input === 'string') {","                input = offsetFromString(matchShortOffset, input);","            } else if (Math.abs(input) < 16) {","                input = input * 60;","            }","            if (!this._isUTC && keepLocalTime) {","                localAdjust = getDateOffset(this);","            }","            this._offset = input;","            this._isUTC = true;","            if (localAdjust != null) {","                this.add(localAdjust, 'm');","            }","            if (offset !== input) {","                if (!keepLocalTime || this._changeInProgress) {","                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);","                } else if (!this._changeInProgress) {","                    this._changeInProgress = true;","                    utils_hooks__hooks.updateOffset(this, true);","                    this._changeInProgress = null;","                }","            }","            return this;","        } else {","            return this._isUTC ? offset : getDateOffset(this);","        }","    }","","    function getSetZone (input, keepLocalTime) {","        if (input != null) {","            if (typeof input !== 'string') {","                input = -input;","            }","","            this.utcOffset(input, keepLocalTime);","","            return this;","        } else {","            return -this.utcOffset();","        }","    }","","    function setOffsetToUTC (keepLocalTime) {","        return this.utcOffset(0, keepLocalTime);","    }","","    function setOffsetToLocal (keepLocalTime) {","        if (this._isUTC) {","            this.utcOffset(0, keepLocalTime);","            this._isUTC = false;","","            if (keepLocalTime) {","                this.subtract(getDateOffset(this), 'm');","            }","        }","        return this;","    }","","    function setOffsetToParsedOffset () {","        if (this._tzm) {","            this.utcOffset(this._tzm);","        } else if (typeof this._i === 'string') {","            this.utcOffset(offsetFromString(matchOffset, this._i));","        }","        return this;","    }","","    function hasAlignedHourOffset (input) {","        if (!this.isValid()) {","            return false;","        }","        input = input ? local__createLocal(input).utcOffset() : 0;","","        return (this.utcOffset() - input) % 60 === 0;","    }","","    function isDaylightSavingTime () {","        return (","            this.utcOffset() > this.clone().month(0).utcOffset() ||","            this.utcOffset() > this.clone().month(5).utcOffset()","        );","    }","","    function isDaylightSavingTimeShifted () {","        if (!isUndefined(this._isDSTShifted)) {","            return this._isDSTShifted;","        }","","        var c = {};","","        copyConfig(c, this);","        c = prepareConfig(c);","","        if (c._a) {","            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);","            this._isDSTShifted = this.isValid() &&","                compareArrays(c._a, other.toArray()) > 0;","        } else {","            this._isDSTShifted = false;","        }","","        return this._isDSTShifted;","    }","","    function isLocal () {","        return this.isValid() ? !this._isUTC : false;","    }","","    function isUtcOffset () {","        return this.isValid() ? this._isUTC : false;","    }","","    function isUtc () {","        return this.isValid() ? this._isUTC && this._offset === 0 : false;","    }","","    // ASP.NET json date format regex","    var aspNetRegex = /^(\\-)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?\\d*)?$/;","","    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html","    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere","    // and further modified to allow for strings containing both week and day","    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;","","    function create__createDuration (input, key) {","        var duration = input,","            // matching against regexp is expensive, do it on demand","            match = null,","            sign,","            ret,","            diffRes;","","        if (isDuration(input)) {","            duration = {","                ms : input._milliseconds,","                d  : input._days,","                M  : input._months","            };","        } else if (typeof input === 'number') {","            duration = {};","            if (key) {","                duration[key] = input;","            } else {","                duration.milliseconds = input;","            }","        } else if (!!(match = aspNetRegex.exec(input))) {","            sign = (match[1] === '-') ? -1 : 1;","            duration = {","                y  : 0,","                d  : toInt(match[DATE])        * sign,","                h  : toInt(match[HOUR])        * sign,","                m  : toInt(match[MINUTE])      * sign,","                s  : toInt(match[SECOND])      * sign,","                ms : toInt(match[MILLISECOND]) * sign","            };","        } else if (!!(match = isoRegex.exec(input))) {","            sign = (match[1] === '-') ? -1 : 1;","            duration = {","                y : parseIso(match[2], sign),","                M : parseIso(match[3], sign),","                w : parseIso(match[4], sign),","                d : parseIso(match[5], sign),","                h : parseIso(match[6], sign),","                m : parseIso(match[7], sign),","                s : parseIso(match[8], sign)","            };","        } else if (duration == null) {// checks for null or undefined","            duration = {};","        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {","            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));","","            duration = {};","            duration.ms = diffRes.milliseconds;","            duration.M = diffRes.months;","        }","","        ret = new Duration(duration);","","        if (isDuration(input) && hasOwnProp(input, '_locale')) {","            ret._locale = input._locale;","        }","","        return ret;","    }","","    create__createDuration.fn = Duration.prototype;","","    function parseIso (inp, sign) {","        // We'd normally use ~~inp for this, but unfortunately it also","        // converts floats to ints.","        // inp may be undefined, so careful calling replace on it.","        var res = inp && parseFloat(inp.replace(',', '.'));","        // apply sign while we're at it","        return (isNaN(res) ? 0 : res) * sign;","    }","","    function positiveMomentsDifference(base, other) {","        var res = {milliseconds: 0, months: 0};","","        res.months = other.month() - base.month() +","            (other.year() - base.year()) * 12;","        if (base.clone().add(res.months, 'M').isAfter(other)) {","            --res.months;","        }","","        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));","","        return res;","    }","","    function momentsDifference(base, other) {","        var res;","        if (!(base.isValid() && other.isValid())) {","            return {milliseconds: 0, months: 0};","        }","","        other = cloneWithOffset(other, base);","        if (base.isBefore(other)) {","            res = positiveMomentsDifference(base, other);","        } else {","            res = positiveMomentsDifference(other, base);","            res.milliseconds = -res.milliseconds;","            res.months = -res.months;","        }","","        return res;","    }","","    function absRound (number) {","        if (number < 0) {","            return Math.round(-1 * number) * -1;","        } else {","            return Math.round(number);","        }","    }","","    // TODO: remove 'name' arg after deprecation is removed","    function createAdder(direction, name) {","        return function (val, period) {","            var dur, tmp;","            //invert the arguments, but complain about it","            if (period !== null && !isNaN(+period)) {","                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');","                tmp = val; val = period; period = tmp;","            }","","            val = typeof val === 'string' ? +val : val;","            dur = create__createDuration(val, period);","            add_subtract__addSubtract(this, dur, direction);","            return this;","        };","    }","","    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {","        var milliseconds = duration._milliseconds,","            days = absRound(duration._days),","            months = absRound(duration._months);","","        if (!mom.isValid()) {","            // No op","            return;","        }","","        updateOffset = updateOffset == null ? true : updateOffset;","","        if (milliseconds) {","            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);","        }","        if (days) {","            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);","        }","        if (months) {","            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);","        }","        if (updateOffset) {","            utils_hooks__hooks.updateOffset(mom, days || months);","        }","    }","","    var add_subtract__add      = createAdder(1, 'add');","    var add_subtract__subtract = createAdder(-1, 'subtract');","","    function moment_calendar__calendar (time, formats) {","        // We want to compare the start of today, vs this.","        // Getting start-of-today depends on whether we're local/utc/offset or not.","        var now = time || local__createLocal(),","            sod = cloneWithOffset(now, this).startOf('day'),","            diff = this.diff(sod, 'days', true),","            format = diff < -6 ? 'sameElse' :","                diff < -1 ? 'lastWeek' :","                diff < 0 ? 'lastDay' :","                diff < 1 ? 'sameDay' :","                diff < 2 ? 'nextDay' :","                diff < 7 ? 'nextWeek' : 'sameElse';","","        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);","","        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));","    }","","    function clone () {","        return new Moment(this);","    }","","    function isAfter (input, units) {","        var localInput = isMoment(input) ? input : local__createLocal(input);","        if (!(this.isValid() && localInput.isValid())) {","            return false;","        }","        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');","        if (units === 'millisecond') {","            return this.valueOf() > localInput.valueOf();","        } else {","            return localInput.valueOf() < this.clone().startOf(units).valueOf();","        }","    }","","    function isBefore (input, units) {","        var localInput = isMoment(input) ? input : local__createLocal(input);","        if (!(this.isValid() && localInput.isValid())) {","            return false;","        }","        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');","        if (units === 'millisecond') {","            return this.valueOf() < localInput.valueOf();","        } else {","            return this.clone().endOf(units).valueOf() < localInput.valueOf();","        }","    }","","    function isBetween (from, to, units, inclusivity) {","        inclusivity = inclusivity || '()';","        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&","            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));","    }","","    function isSame (input, units) {","        var localInput = isMoment(input) ? input : local__createLocal(input),","            inputMs;","        if (!(this.isValid() && localInput.isValid())) {","            return false;","        }","        units = normalizeUnits(units || 'millisecond');","        if (units === 'millisecond') {","            return this.valueOf() === localInput.valueOf();","        } else {","            inputMs = localInput.valueOf();","            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();","        }","    }","","    function isSameOrAfter (input, units) {","        return this.isSame(input, units) || this.isAfter(input,units);","    }","","    function isSameOrBefore (input, units) {","        return this.isSame(input, units) || this.isBefore(input,units);","    }","","    function diff (input, units, asFloat) {","        var that,","            zoneDelta,","            delta, output;","","        if (!this.isValid()) {","            return NaN;","        }","","        that = cloneWithOffset(input, this);","","        if (!that.isValid()) {","            return NaN;","        }","","        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;","","        units = normalizeUnits(units);","","        if (units === 'year' || units === 'month' || units === 'quarter') {","            output = monthDiff(this, that);","            if (units === 'quarter') {","                output = output / 3;","            } else if (units === 'year') {","                output = output / 12;","            }","        } else {","            delta = this - that;","            output = units === 'second' ? delta / 1e3 : // 1000","                units === 'minute' ? delta / 6e4 : // 1000 * 60","                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60","                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst","                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst","                delta;","        }","        return asFloat ? output : absFloor(output);","    }","","    function monthDiff (a, b) {","        // difference in months","        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),","            // b is in (anchor - 1 month, anchor + 1 month)","            anchor = a.clone().add(wholeMonthDiff, 'months'),","            anchor2, adjust;","","        if (b - anchor < 0) {","            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');","            // linear across the month","            adjust = (b - anchor) / (anchor - anchor2);","        } else {","            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');","            // linear across the month","            adjust = (b - anchor) / (anchor2 - anchor);","        }","","        //check for negative zero, return zero if negative zero","        return -(wholeMonthDiff + adjust) || 0;","    }","","    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';","    utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';","","    function toString () {","        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');","    }","","    function moment_format__toISOString () {","        var m = this.clone().utc();","        if (0 < m.year() && m.year() <= 9999) {","            if (isFunction(Date.prototype.toISOString)) {","                // native implementation is ~50x faster, use it when we can","                return this.toDate().toISOString();","            } else {","                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');","            }","        } else {","            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');","        }","    }","","    function format (inputString) {","        if (!inputString) {","            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;","        }","        var output = formatMoment(this, inputString);","        return this.localeData().postformat(output);","    }","","    function from (time, withoutSuffix) {","        if (this.isValid() &&","                ((isMoment(time) && time.isValid()) ||","                 local__createLocal(time).isValid())) {","            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);","        } else {","            return this.localeData().invalidDate();","        }","    }","","    function fromNow (withoutSuffix) {","        return this.from(local__createLocal(), withoutSuffix);","    }","","    function to (time, withoutSuffix) {","        if (this.isValid() &&","                ((isMoment(time) && time.isValid()) ||","                 local__createLocal(time).isValid())) {","            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);","        } else {","            return this.localeData().invalidDate();","        }","    }","","    function toNow (withoutSuffix) {","        return this.to(local__createLocal(), withoutSuffix);","    }","","    // If passed a locale key, it will set the locale for this","    // instance.  Otherwise, it will return the locale configuration","    // variables for this instance.","    function locale (key) {","        var newLocaleData;","","        if (key === undefined) {","            return this._locale._abbr;","        } else {","            newLocaleData = locale_locales__getLocale(key);","            if (newLocaleData != null) {","                this._locale = newLocaleData;","            }","            return this;","        }","    }","","    var lang = deprecate(","        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',","        function (key) {","            if (key === undefined) {","                return this.localeData();","            } else {","                return this.locale(key);","            }","        }","    );","","    function localeData () {","        return this._locale;","    }","","    function startOf (units) {","        units = normalizeUnits(units);","        // the following switch intentionally omits break keywords","        // to utilize falling through the cases.","        switch (units) {","        case 'year':","            this.month(0);","            /* falls through */","        case 'quarter':","        case 'month':","            this.date(1);","            /* falls through */","        case 'week':","        case 'isoWeek':","        case 'day':","        case 'date':","            this.hours(0);","            /* falls through */","        case 'hour':","            this.minutes(0);","            /* falls through */","        case 'minute':","            this.seconds(0);","            /* falls through */","        case 'second':","            this.milliseconds(0);","        }","","        // weeks are a special case","        if (units === 'week') {","            this.weekday(0);","        }","        if (units === 'isoWeek') {","            this.isoWeekday(1);","        }","","        // quarters are also special","        if (units === 'quarter') {","            this.month(Math.floor(this.month() / 3) * 3);","        }","","        return this;","    }","","    function endOf (units) {","        units = normalizeUnits(units);","        if (units === undefined || units === 'millisecond') {","            return this;","        }","","        // 'date' is an alias for 'day', so it should be considered as such.","        if (units === 'date') {","            units = 'day';","        }","","        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');","    }","","    function to_type__valueOf () {","        return this._d.valueOf() - ((this._offset || 0) * 60000);","    }","","    function unix () {","        return Math.floor(this.valueOf() / 1000);","    }","","    function toDate () {","        return this._offset ? new Date(this.valueOf()) : this._d;","    }","","    function toArray () {","        var m = this;","        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];","    }","","    function toObject () {","        var m = this;","        return {","            years: m.year(),","            months: m.month(),","            date: m.date(),","            hours: m.hours(),","            minutes: m.minutes(),","            seconds: m.seconds(),","            milliseconds: m.milliseconds()","        };","    }","","    function toJSON () {","        // new Date(NaN).toJSON() === null","        return this.isValid() ? this.toISOString() : null;","    }","","    function moment_valid__isValid () {","        return valid__isValid(this);","    }","","    function parsingFlags () {","        return extend({}, getParsingFlags(this));","    }","","    function invalidAt () {","        return getParsingFlags(this).overflow;","    }","","    function creationData() {","        return {","            input: this._i,","            format: this._f,","            locale: this._locale,","            isUTC: this._isUTC,","            strict: this._strict","        };","    }","","    // FORMATTING","","    addFormatToken(0, ['gg', 2], 0, function () {","        return this.weekYear() % 100;","    });","","    addFormatToken(0, ['GG', 2], 0, function () {","        return this.isoWeekYear() % 100;","    });","","    function addWeekYearFormatToken (token, getter) {","        addFormatToken(0, [token, token.length], 0, getter);","    }","","    addWeekYearFormatToken('gggg',     'weekYear');","    addWeekYearFormatToken('ggggg',    'weekYear');","    addWeekYearFormatToken('GGGG',  'isoWeekYear');","    addWeekYearFormatToken('GGGGG', 'isoWeekYear');","","    // ALIASES","","    addUnitAlias('weekYear', 'gg');","    addUnitAlias('isoWeekYear', 'GG');","","    // PARSING","","    addRegexToken('G',      matchSigned);","    addRegexToken('g',      matchSigned);","    addRegexToken('GG',     match1to2, match2);","    addRegexToken('gg',     match1to2, match2);","    addRegexToken('GGGG',   match1to4, match4);","    addRegexToken('gggg',   match1to4, match4);","    addRegexToken('GGGGG',  match1to6, match6);","    addRegexToken('ggggg',  match1to6, match6);","","    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {","        week[token.substr(0, 2)] = toInt(input);","    });","","    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {","        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);","    });","","    // MOMENTS","","    function getSetWeekYear (input) {","        return getSetWeekYearHelper.call(this,","                input,","                this.week(),","                this.weekday(),","                this.localeData()._week.dow,","                this.localeData()._week.doy);","    }","","    function getSetISOWeekYear (input) {","        return getSetWeekYearHelper.call(this,","                input, this.isoWeek(), this.isoWeekday(), 1, 4);","    }","","    function getISOWeeksInYear () {","        return weeksInYear(this.year(), 1, 4);","    }","","    function getWeeksInYear () {","        var weekInfo = this.localeData()._week;","        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);","    }","","    function getSetWeekYearHelper(input, week, weekday, dow, doy) {","        var weeksTarget;","        if (input == null) {","            return weekOfYear(this, dow, doy).year;","        } else {","            weeksTarget = weeksInYear(input, dow, doy);","            if (week > weeksTarget) {","                week = weeksTarget;","            }","            return setWeekAll.call(this, input, week, weekday, dow, doy);","        }","    }","","    function setWeekAll(weekYear, week, weekday, dow, doy) {","        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),","            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);","","        this.year(date.getUTCFullYear());","        this.month(date.getUTCMonth());","        this.date(date.getUTCDate());","        return this;","    }","","    // FORMATTING","","    addFormatToken('Q', 0, 'Qo', 'quarter');","","    // ALIASES","","    addUnitAlias('quarter', 'Q');","","    // PARSING","","    addRegexToken('Q', match1);","    addParseToken('Q', function (input, array) {","        array[MONTH] = (toInt(input) - 1) * 3;","    });","","    // MOMENTS","","    function getSetQuarter (input) {","        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);","    }","","    // FORMATTING","","    addFormatToken('w', ['ww', 2], 'wo', 'week');","    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');","","    // ALIASES","","    addUnitAlias('week', 'w');","    addUnitAlias('isoWeek', 'W');","","    // PARSING","","    addRegexToken('w',  match1to2);","    addRegexToken('ww', match1to2, match2);","    addRegexToken('W',  match1to2);","    addRegexToken('WW', match1to2, match2);","","    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {","        week[token.substr(0, 1)] = toInt(input);","    });","","    // HELPERS","","    // LOCALES","","    function localeWeek (mom) {","        return weekOfYear(mom, this._week.dow, this._week.doy).week;","    }","","    var defaultLocaleWeek = {","        dow : 0, // Sunday is the first day of the week.","        doy : 6  // The week that contains Jan 1st is the first week of the year.","    };","","    function localeFirstDayOfWeek () {","        return this._week.dow;","    }","","    function localeFirstDayOfYear () {","        return this._week.doy;","    }","","    // MOMENTS","","    function getSetWeek (input) {","        var week = this.localeData().week(this);","        return input == null ? week : this.add((input - week) * 7, 'd');","    }","","    function getSetISOWeek (input) {","        var week = weekOfYear(this, 1, 4).week;","        return input == null ? week : this.add((input - week) * 7, 'd');","    }","","    // FORMATTING","","    addFormatToken('D', ['DD', 2], 'Do', 'date');","","    // ALIASES","","    addUnitAlias('date', 'D');","","    // PARSING","","    addRegexToken('D',  match1to2);","    addRegexToken('DD', match1to2, match2);","    addRegexToken('Do', function (isStrict, locale) {","        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;","    });","","    addParseToken(['D', 'DD'], DATE);","    addParseToken('Do', function (input, array) {","        array[DATE] = toInt(input.match(match1to2)[0], 10);","    });","","    // MOMENTS","","    var getSetDayOfMonth = makeGetSet('Date', true);","","    // FORMATTING","","    addFormatToken('d', 0, 'do', 'day');","","    addFormatToken('dd', 0, 0, function (format) {","        return this.localeData().weekdaysMin(this, format);","    });","","    addFormatToken('ddd', 0, 0, function (format) {","        return this.localeData().weekdaysShort(this, format);","    });","","    addFormatToken('dddd', 0, 0, function (format) {","        return this.localeData().weekdays(this, format);","    });","","    addFormatToken('e', 0, 0, 'weekday');","    addFormatToken('E', 0, 0, 'isoWeekday');","","    // ALIASES","","    addUnitAlias('day', 'd');","    addUnitAlias('weekday', 'e');","    addUnitAlias('isoWeekday', 'E');","","    // PARSING","","    addRegexToken('d',    match1to2);","    addRegexToken('e',    match1to2);","    addRegexToken('E',    match1to2);","    addRegexToken('dd',   function (isStrict, locale) {","        return locale.weekdaysMinRegex(isStrict);","    });","    addRegexToken('ddd',   function (isStrict, locale) {","        return locale.weekdaysShortRegex(isStrict);","    });","    addRegexToken('dddd',   function (isStrict, locale) {","        return locale.weekdaysRegex(isStrict);","    });","","    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {","        var weekday = config._locale.weekdaysParse(input, token, config._strict);","        // if we didn't get a weekday name, mark the date as invalid","        if (weekday != null) {","            week.d = weekday;","        } else {","            getParsingFlags(config).invalidWeekday = input;","        }","    });","","    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {","        week[token] = toInt(input);","    });","","    // HELPERS","","    function parseWeekday(input, locale) {","        if (typeof input !== 'string') {","            return input;","        }","","        if (!isNaN(input)) {","            return parseInt(input, 10);","        }","","        input = locale.weekdaysParse(input);","        if (typeof input === 'number') {","            return input;","        }","","        return null;","    }","","    // LOCALES","","    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');","    function localeWeekdays (m, format) {","        return isArray(this._weekdays) ? this._weekdays[m.day()] :","            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];","    }","","    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');","    function localeWeekdaysShort (m) {","        return this._weekdaysShort[m.day()];","    }","","    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');","    function localeWeekdaysMin (m) {","        return this._weekdaysMin[m.day()];","    }","","    function day_of_week__handleStrictParse(weekdayName, format, strict) {","        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();","        if (!this._weekdaysParse) {","            this._weekdaysParse = [];","            this._shortWeekdaysParse = [];","            this._minWeekdaysParse = [];","","            for (i = 0; i < 7; ++i) {","                mom = create_utc__createUTC([2000, 1]).day(i);","                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();","                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();","                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();","            }","        }","","        if (strict) {","            if (format === 'dddd') {","                ii = indexOf.call(this._weekdaysParse, llc);","                return ii !== -1 ? ii : null;","            } else if (format === 'ddd') {","                ii = indexOf.call(this._shortWeekdaysParse, llc);","                return ii !== -1 ? ii : null;","            } else {","                ii = indexOf.call(this._minWeekdaysParse, llc);","                return ii !== -1 ? ii : null;","            }","        } else {","            if (format === 'dddd') {","                ii = indexOf.call(this._weekdaysParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._shortWeekdaysParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._minWeekdaysParse, llc);","                return ii !== -1 ? ii : null;","            } else if (format === 'ddd') {","                ii = indexOf.call(this._shortWeekdaysParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._weekdaysParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._minWeekdaysParse, llc);","                return ii !== -1 ? ii : null;","            } else {","                ii = indexOf.call(this._minWeekdaysParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._weekdaysParse, llc);","                if (ii !== -1) {","                    return ii;","                }","                ii = indexOf.call(this._shortWeekdaysParse, llc);","                return ii !== -1 ? ii : null;","            }","        }","    }","","    function localeWeekdaysParse (weekdayName, format, strict) {","        var i, mom, regex;","","        if (this._weekdaysParseExact) {","            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);","        }","","        if (!this._weekdaysParse) {","            this._weekdaysParse = [];","            this._minWeekdaysParse = [];","            this._shortWeekdaysParse = [];","            this._fullWeekdaysParse = [];","        }","","        for (i = 0; i < 7; i++) {","            // make the regex if we don't have it already","","            mom = create_utc__createUTC([2000, 1]).day(i);","            if (strict && !this._fullWeekdaysParse[i]) {","                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');","                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');","                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');","            }","            if (!this._weekdaysParse[i]) {","                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');","                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');","            }","            // test the regex","            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {","                return i;","            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {","                return i;","            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {","                return i;","            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {","                return i;","            }","        }","    }","","    // MOMENTS","","    function getSetDayOfWeek (input) {","        if (!this.isValid()) {","            return input != null ? this : NaN;","        }","        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();","        if (input != null) {","            input = parseWeekday(input, this.localeData());","            return this.add(input - day, 'd');","        } else {","            return day;","        }","    }","","    function getSetLocaleDayOfWeek (input) {","        if (!this.isValid()) {","            return input != null ? this : NaN;","        }","        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;","        return input == null ? weekday : this.add(input - weekday, 'd');","    }","","    function getSetISODayOfWeek (input) {","        if (!this.isValid()) {","            return input != null ? this : NaN;","        }","        // behaves the same as moment#day except","        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)","        // as a setter, sunday should belong to the previous week.","        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);","    }","","    var defaultWeekdaysRegex = matchWord;","    function weekdaysRegex (isStrict) {","        if (this._weekdaysParseExact) {","            if (!hasOwnProp(this, '_weekdaysRegex')) {","                computeWeekdaysParse.call(this);","            }","            if (isStrict) {","                return this._weekdaysStrictRegex;","            } else {","                return this._weekdaysRegex;","            }","        } else {","            return this._weekdaysStrictRegex && isStrict ?","                this._weekdaysStrictRegex : this._weekdaysRegex;","        }","    }","","    var defaultWeekdaysShortRegex = matchWord;","    function weekdaysShortRegex (isStrict) {","        if (this._weekdaysParseExact) {","            if (!hasOwnProp(this, '_weekdaysRegex')) {","                computeWeekdaysParse.call(this);","            }","            if (isStrict) {","                return this._weekdaysShortStrictRegex;","            } else {","                return this._weekdaysShortRegex;","            }","        } else {","            return this._weekdaysShortStrictRegex && isStrict ?","                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;","        }","    }","","    var defaultWeekdaysMinRegex = matchWord;","    function weekdaysMinRegex (isStrict) {","        if (this._weekdaysParseExact) {","            if (!hasOwnProp(this, '_weekdaysRegex')) {","                computeWeekdaysParse.call(this);","            }","            if (isStrict) {","                return this._weekdaysMinStrictRegex;","            } else {","                return this._weekdaysMinRegex;","            }","        } else {","            return this._weekdaysMinStrictRegex && isStrict ?","                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;","        }","    }","","","    function computeWeekdaysParse () {","        function cmpLenRev(a, b) {","            return b.length - a.length;","        }","","        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],","            i, mom, minp, shortp, longp;","        for (i = 0; i < 7; i++) {","            // make the regex if we don't have it already","            mom = create_utc__createUTC([2000, 1]).day(i);","            minp = this.weekdaysMin(mom, '');","            shortp = this.weekdaysShort(mom, '');","            longp = this.weekdays(mom, '');","            minPieces.push(minp);","            shortPieces.push(shortp);","            longPieces.push(longp);","            mixedPieces.push(minp);","            mixedPieces.push(shortp);","            mixedPieces.push(longp);","        }","        // Sorting makes sure if one weekday (or abbr) is a prefix of another it","        // will match the longer piece.","        minPieces.sort(cmpLenRev);","        shortPieces.sort(cmpLenRev);","        longPieces.sort(cmpLenRev);","        mixedPieces.sort(cmpLenRev);","        for (i = 0; i < 7; i++) {","            shortPieces[i] = regexEscape(shortPieces[i]);","            longPieces[i] = regexEscape(longPieces[i]);","            mixedPieces[i] = regexEscape(mixedPieces[i]);","        }","","        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');","        this._weekdaysShortRegex = this._weekdaysRegex;","        this._weekdaysMinRegex = this._weekdaysRegex;","","        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');","        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');","        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');","    }","","    // FORMATTING","","    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');","","    // ALIASES","","    addUnitAlias('dayOfYear', 'DDD');","","    // PARSING","","    addRegexToken('DDD',  match1to3);","    addRegexToken('DDDD', match3);","    addParseToken(['DDD', 'DDDD'], function (input, array, config) {","        config._dayOfYear = toInt(input);","    });","","    // HELPERS","","    // MOMENTS","","    function getSetDayOfYear (input) {","        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;","        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');","    }","","    // FORMATTING","","    function hFormat() {","        return this.hours() % 12 || 12;","    }","","    function kFormat() {","        return this.hours() || 24;","    }","","    addFormatToken('H', ['HH', 2], 0, 'hour');","    addFormatToken('h', ['hh', 2], 0, hFormat);","    addFormatToken('k', ['kk', 2], 0, kFormat);","","    addFormatToken('hmm', 0, 0, function () {","        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);","    });","","    addFormatToken('hmmss', 0, 0, function () {","        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +","            zeroFill(this.seconds(), 2);","    });","","    addFormatToken('Hmm', 0, 0, function () {","        return '' + this.hours() + zeroFill(this.minutes(), 2);","    });","","    addFormatToken('Hmmss', 0, 0, function () {","        return '' + this.hours() + zeroFill(this.minutes(), 2) +","            zeroFill(this.seconds(), 2);","    });","","    function meridiem (token, lowercase) {","        addFormatToken(token, 0, 0, function () {","            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);","        });","    }","","    meridiem('a', true);","    meridiem('A', false);","","    // ALIASES","","    addUnitAlias('hour', 'h');","","    // PARSING","","    function matchMeridiem (isStrict, locale) {","        return locale._meridiemParse;","    }","","    addRegexToken('a',  matchMeridiem);","    addRegexToken('A',  matchMeridiem);","    addRegexToken('H',  match1to2);","    addRegexToken('h',  match1to2);","    addRegexToken('HH', match1to2, match2);","    addRegexToken('hh', match1to2, match2);","","    addRegexToken('hmm', match3to4);","    addRegexToken('hmmss', match5to6);","    addRegexToken('Hmm', match3to4);","    addRegexToken('Hmmss', match5to6);","","    addParseToken(['H', 'HH'], HOUR);","    addParseToken(['a', 'A'], function (input, array, config) {","        config._isPm = config._locale.isPM(input);","        config._meridiem = input;","    });","    addParseToken(['h', 'hh'], function (input, array, config) {","        array[HOUR] = toInt(input);","        getParsingFlags(config).bigHour = true;","    });","    addParseToken('hmm', function (input, array, config) {","        var pos = input.length - 2;","        array[HOUR] = toInt(input.substr(0, pos));","        array[MINUTE] = toInt(input.substr(pos));","        getParsingFlags(config).bigHour = true;","    });","    addParseToken('hmmss', function (input, array, config) {","        var pos1 = input.length - 4;","        var pos2 = input.length - 2;","        array[HOUR] = toInt(input.substr(0, pos1));","        array[MINUTE] = toInt(input.substr(pos1, 2));","        array[SECOND] = toInt(input.substr(pos2));","        getParsingFlags(config).bigHour = true;","    });","    addParseToken('Hmm', function (input, array, config) {","        var pos = input.length - 2;","        array[HOUR] = toInt(input.substr(0, pos));","        array[MINUTE] = toInt(input.substr(pos));","    });","    addParseToken('Hmmss', function (input, array, config) {","        var pos1 = input.length - 4;","        var pos2 = input.length - 2;","        array[HOUR] = toInt(input.substr(0, pos1));","        array[MINUTE] = toInt(input.substr(pos1, 2));","        array[SECOND] = toInt(input.substr(pos2));","    });","","    // LOCALES","","    function localeIsPM (input) {","        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays","        // Using charAt should be more compatible.","        return ((input + '').toLowerCase().charAt(0) === 'p');","    }","","    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;","    function localeMeridiem (hours, minutes, isLower) {","        if (hours > 11) {","            return isLower ? 'pm' : 'PM';","        } else {","            return isLower ? 'am' : 'AM';","        }","    }","","","    // MOMENTS","","    // Setting the hour should keep the time, because the user explicitly","    // specified which hour he wants. So trying to maintain the same hour (in","    // a new timezone) makes sense. Adding/subtracting hours does not follow","    // this rule.","    var getSetHour = makeGetSet('Hours', true);","","    // FORMATTING","","    addFormatToken('m', ['mm', 2], 0, 'minute');","","    // ALIASES","","    addUnitAlias('minute', 'm');","","    // PARSING","","    addRegexToken('m',  match1to2);","    addRegexToken('mm', match1to2, match2);","    addParseToken(['m', 'mm'], MINUTE);","","    // MOMENTS","","    var getSetMinute = makeGetSet('Minutes', false);","","    // FORMATTING","","    addFormatToken('s', ['ss', 2], 0, 'second');","","    // ALIASES","","    addUnitAlias('second', 's');","","    // PARSING","","    addRegexToken('s',  match1to2);","    addRegexToken('ss', match1to2, match2);","    addParseToken(['s', 'ss'], SECOND);","","    // MOMENTS","","    var getSetSecond = makeGetSet('Seconds', false);","","    // FORMATTING","","    addFormatToken('S', 0, 0, function () {","        return ~~(this.millisecond() / 100);","    });","","    addFormatToken(0, ['SS', 2], 0, function () {","        return ~~(this.millisecond() / 10);","    });","","    addFormatToken(0, ['SSS', 3], 0, 'millisecond');","    addFormatToken(0, ['SSSS', 4], 0, function () {","        return this.millisecond() * 10;","    });","    addFormatToken(0, ['SSSSS', 5], 0, function () {","        return this.millisecond() * 100;","    });","    addFormatToken(0, ['SSSSSS', 6], 0, function () {","        return this.millisecond() * 1000;","    });","    addFormatToken(0, ['SSSSSSS', 7], 0, function () {","        return this.millisecond() * 10000;","    });","    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {","        return this.millisecond() * 100000;","    });","    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {","        return this.millisecond() * 1000000;","    });","","","    // ALIASES","","    addUnitAlias('millisecond', 'ms');","","    // PARSING","","    addRegexToken('S',    match1to3, match1);","    addRegexToken('SS',   match1to3, match2);","    addRegexToken('SSS',  match1to3, match3);","","    var token;","    for (token = 'SSSS'; token.length <= 9; token += 'S') {","        addRegexToken(token, matchUnsigned);","    }","","    function parseMs(input, array) {","        array[MILLISECOND] = toInt(('0.' + input) * 1000);","    }","","    for (token = 'S'; token.length <= 9; token += 'S') {","        addParseToken(token, parseMs);","    }","    // MOMENTS","","    var getSetMillisecond = makeGetSet('Milliseconds', false);","","    // FORMATTING","","    addFormatToken('z',  0, 0, 'zoneAbbr');","    addFormatToken('zz', 0, 0, 'zoneName');","","    // MOMENTS","","    function getZoneAbbr () {","        return this._isUTC ? 'UTC' : '';","    }","","    function getZoneName () {","        return this._isUTC ? 'Coordinated Universal Time' : '';","    }","","    var momentPrototype__proto = Moment.prototype;","","    momentPrototype__proto.add               = add_subtract__add;","    momentPrototype__proto.calendar          = moment_calendar__calendar;","    momentPrototype__proto.clone             = clone;","    momentPrototype__proto.diff              = diff;","    momentPrototype__proto.endOf             = endOf;","    momentPrototype__proto.format            = format;","    momentPrototype__proto.from              = from;","    momentPrototype__proto.fromNow           = fromNow;","    momentPrototype__proto.to                = to;","    momentPrototype__proto.toNow             = toNow;","    momentPrototype__proto.get               = getSet;","    momentPrototype__proto.invalidAt         = invalidAt;","    momentPrototype__proto.isAfter           = isAfter;","    momentPrototype__proto.isBefore          = isBefore;","    momentPrototype__proto.isBetween         = isBetween;","    momentPrototype__proto.isSame            = isSame;","    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;","    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;","    momentPrototype__proto.isValid           = moment_valid__isValid;","    momentPrototype__proto.lang              = lang;","    momentPrototype__proto.locale            = locale;","    momentPrototype__proto.localeData        = localeData;","    momentPrototype__proto.max               = prototypeMax;","    momentPrototype__proto.min               = prototypeMin;","    momentPrototype__proto.parsingFlags      = parsingFlags;","    momentPrototype__proto.set               = getSet;","    momentPrototype__proto.startOf           = startOf;","    momentPrototype__proto.subtract          = add_subtract__subtract;","    momentPrototype__proto.toArray           = toArray;","    momentPrototype__proto.toObject          = toObject;","    momentPrototype__proto.toDate            = toDate;","    momentPrototype__proto.toISOString       = moment_format__toISOString;","    momentPrototype__proto.toJSON            = toJSON;","    momentPrototype__proto.toString          = toString;","    momentPrototype__proto.unix              = unix;","    momentPrototype__proto.valueOf           = to_type__valueOf;","    momentPrototype__proto.creationData      = creationData;","","    // Year","    momentPrototype__proto.year       = getSetYear;","    momentPrototype__proto.isLeapYear = getIsLeapYear;","","    // Week Year","    momentPrototype__proto.weekYear    = getSetWeekYear;","    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;","","    // Quarter","    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;","","    // Month","    momentPrototype__proto.month       = getSetMonth;","    momentPrototype__proto.daysInMonth = getDaysInMonth;","","    // Week","    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;","    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;","    momentPrototype__proto.weeksInYear    = getWeeksInYear;","    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;","","    // Day","    momentPrototype__proto.date       = getSetDayOfMonth;","    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;","    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;","    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;","    momentPrototype__proto.dayOfYear  = getSetDayOfYear;","","    // Hour","    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;","","    // Minute","    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;","","    // Second","    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;","","    // Millisecond","    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;","","    // Offset","    momentPrototype__proto.utcOffset            = getSetOffset;","    momentPrototype__proto.utc                  = setOffsetToUTC;","    momentPrototype__proto.local                = setOffsetToLocal;","    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;","    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;","    momentPrototype__proto.isDST                = isDaylightSavingTime;","    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;","    momentPrototype__proto.isLocal              = isLocal;","    momentPrototype__proto.isUtcOffset          = isUtcOffset;","    momentPrototype__proto.isUtc                = isUtc;","    momentPrototype__proto.isUTC                = isUtc;","","    // Timezone","    momentPrototype__proto.zoneAbbr = getZoneAbbr;","    momentPrototype__proto.zoneName = getZoneName;","","    // Deprecations","    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);","    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);","    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);","    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);","","    var momentPrototype = momentPrototype__proto;","","    function moment__createUnix (input) {","        return local__createLocal(input * 1000);","    }","","    function moment__createInZone () {","        return local__createLocal.apply(null, arguments).parseZone();","    }","","    var defaultCalendar = {","        sameDay : '[Today at] LT',","        nextDay : '[Tomorrow at] LT',","        nextWeek : 'dddd [at] LT',","        lastDay : '[Yesterday at] LT',","        lastWeek : '[Last] dddd [at] LT',","        sameElse : 'L'","    };","","    function locale_calendar__calendar (key, mom, now) {","        var output = this._calendar[key];","        return isFunction(output) ? output.call(mom, now) : output;","    }","","    var defaultLongDateFormat = {","        LTS  : 'h:mm:ss A',","        LT   : 'h:mm A',","        L    : 'MM/DD/YYYY',","        LL   : 'MMMM D, YYYY',","        LLL  : 'MMMM D, YYYY h:mm A',","        LLLL : 'dddd, MMMM D, YYYY h:mm A'","    };","","    function longDateFormat (key) {","        var format = this._longDateFormat[key],","            formatUpper = this._longDateFormat[key.toUpperCase()];","","        if (format || !formatUpper) {","            return format;","        }","","        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {","            return val.slice(1);","        });","","        return this._longDateFormat[key];","    }","","    var defaultInvalidDate = 'Invalid date';","","    function invalidDate () {","        return this._invalidDate;","    }","","    var defaultOrdinal = '%d';","    var defaultOrdinalParse = /\\d{1,2}/;","","    function ordinal (number) {","        return this._ordinal.replace('%d', number);","    }","","    function preParsePostFormat (string) {","        return string;","    }","","    var defaultRelativeTime = {","        future : 'in %s',","        past   : '%s ago',","        s  : 'a few seconds',","        m  : 'a minute',","        mm : '%d minutes',","        h  : 'an hour',","        hh : '%d hours',","        d  : 'a day',","        dd : '%d days',","        M  : 'a month',","        MM : '%d months',","        y  : 'a year',","        yy : '%d years'","    };","","    function relative__relativeTime (number, withoutSuffix, string, isFuture) {","        var output = this._relativeTime[string];","        return (isFunction(output)) ?","            output(number, withoutSuffix, string, isFuture) :","            output.replace(/%d/i, number);","    }","","    function pastFuture (diff, output) {","        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];","        return isFunction(format) ? format(output) : format.replace(/%s/i, output);","    }","","    var prototype__proto = Locale.prototype;","","    prototype__proto._calendar       = defaultCalendar;","    prototype__proto.calendar        = locale_calendar__calendar;","    prototype__proto._longDateFormat = defaultLongDateFormat;","    prototype__proto.longDateFormat  = longDateFormat;","    prototype__proto._invalidDate    = defaultInvalidDate;","    prototype__proto.invalidDate     = invalidDate;","    prototype__proto._ordinal        = defaultOrdinal;","    prototype__proto.ordinal         = ordinal;","    prototype__proto._ordinalParse   = defaultOrdinalParse;","    prototype__proto.preparse        = preParsePostFormat;","    prototype__proto.postformat      = preParsePostFormat;","    prototype__proto._relativeTime   = defaultRelativeTime;","    prototype__proto.relativeTime    = relative__relativeTime;","    prototype__proto.pastFuture      = pastFuture;","    prototype__proto.set             = locale_set__set;","","    // Month","    prototype__proto.months            =        localeMonths;","    prototype__proto._months           = defaultLocaleMonths;","    prototype__proto.monthsShort       =        localeMonthsShort;","    prototype__proto._monthsShort      = defaultLocaleMonthsShort;","    prototype__proto.monthsParse       =        localeMonthsParse;","    prototype__proto._monthsRegex      = defaultMonthsRegex;","    prototype__proto.monthsRegex       = monthsRegex;","    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;","    prototype__proto.monthsShortRegex  = monthsShortRegex;","","    // Week","    prototype__proto.week = localeWeek;","    prototype__proto._week = defaultLocaleWeek;","    prototype__proto.firstDayOfYear = localeFirstDayOfYear;","    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;","","    // Day of Week","    prototype__proto.weekdays       =        localeWeekdays;","    prototype__proto._weekdays      = defaultLocaleWeekdays;","    prototype__proto.weekdaysMin    =        localeWeekdaysMin;","    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;","    prototype__proto.weekdaysShort  =        localeWeekdaysShort;","    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;","    prototype__proto.weekdaysParse  =        localeWeekdaysParse;","","    prototype__proto._weekdaysRegex      = defaultWeekdaysRegex;","    prototype__proto.weekdaysRegex       =        weekdaysRegex;","    prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;","    prototype__proto.weekdaysShortRegex  =        weekdaysShortRegex;","    prototype__proto._weekdaysMinRegex   = defaultWeekdaysMinRegex;","    prototype__proto.weekdaysMinRegex    =        weekdaysMinRegex;","","    // Hours","    prototype__proto.isPM = localeIsPM;","    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;","    prototype__proto.meridiem = localeMeridiem;","","    function lists__get (format, index, field, setter) {","        var locale = locale_locales__getLocale();","        var utc = create_utc__createUTC().set(setter, index);","        return locale[field](utc, format);","    }","","    function listMonthsImpl (format, index, field) {","        if (typeof format === 'number') {","            index = format;","            format = undefined;","        }","","        format = format || '';","","        if (index != null) {","            return lists__get(format, index, field, 'month');","        }","","        var i;","        var out = [];","        for (i = 0; i < 12; i++) {","            out[i] = lists__get(format, i, field, 'month');","        }","        return out;","    }","","    // ()","    // (5)","    // (fmt, 5)","    // (fmt)","    // (true)","    // (true, 5)","    // (true, fmt, 5)","    // (true, fmt)","    function listWeekdaysImpl (localeSorted, format, index, field) {","        if (typeof localeSorted === 'boolean') {","            if (typeof format === 'number') {","                index = format;","                format = undefined;","            }","","            format = format || '';","        } else {","            format = localeSorted;","            index = format;","            localeSorted = false;","","            if (typeof format === 'number') {","                index = format;","                format = undefined;","            }","","            format = format || '';","        }","","        var locale = locale_locales__getLocale(),","            shift = localeSorted ? locale._week.dow : 0;","","        if (index != null) {","            return lists__get(format, (index + shift) % 7, field, 'day');","        }","","        var i;","        var out = [];","        for (i = 0; i < 7; i++) {","            out[i] = lists__get(format, (i + shift) % 7, field, 'day');","        }","        return out;","    }","","    function lists__listMonths (format, index) {","        return listMonthsImpl(format, index, 'months');","    }","","    function lists__listMonthsShort (format, index) {","        return listMonthsImpl(format, index, 'monthsShort');","    }","","    function lists__listWeekdays (localeSorted, format, index) {","        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');","    }","","    function lists__listWeekdaysShort (localeSorted, format, index) {","        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');","    }","","    function lists__listWeekdaysMin (localeSorted, format, index) {","        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');","    }","","    locale_locales__getSetGlobalLocale('en', {","        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,","        ordinal : function (number) {","            var b = number % 10,","                output = (toInt(number % 100 / 10) === 1) ? 'th' :","                (b === 1) ? 'st' :","                (b === 2) ? 'nd' :","                (b === 3) ? 'rd' : 'th';","            return number + output;","        }","    });","","    // Side effect imports","    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);","    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);","","    var mathAbs = Math.abs;","","    function duration_abs__abs () {","        var data           = this._data;","","        this._milliseconds = mathAbs(this._milliseconds);","        this._days         = mathAbs(this._days);","        this._months       = mathAbs(this._months);","","        data.milliseconds  = mathAbs(data.milliseconds);","        data.seconds       = mathAbs(data.seconds);","        data.minutes       = mathAbs(data.minutes);","        data.hours         = mathAbs(data.hours);","        data.months        = mathAbs(data.months);","        data.years         = mathAbs(data.years);","","        return this;","    }","","    function duration_add_subtract__addSubtract (duration, input, value, direction) {","        var other = create__createDuration(input, value);","","        duration._milliseconds += direction * other._milliseconds;","        duration._days         += direction * other._days;","        duration._months       += direction * other._months;","","        return duration._bubble();","    }","","    // supports only 2.0-style add(1, 's') or add(duration)","    function duration_add_subtract__add (input, value) {","        return duration_add_subtract__addSubtract(this, input, value, 1);","    }","","    // supports only 2.0-style subtract(1, 's') or subtract(duration)","    function duration_add_subtract__subtract (input, value) {","        return duration_add_subtract__addSubtract(this, input, value, -1);","    }","","    function absCeil (number) {","        if (number < 0) {","            return Math.floor(number);","        } else {","            return Math.ceil(number);","        }","    }","","    function bubble () {","        var milliseconds = this._milliseconds;","        var days         = this._days;","        var months       = this._months;","        var data         = this._data;","        var seconds, minutes, hours, years, monthsFromDays;","","        // if we have a mix of positive and negative values, bubble down first","        // check: https://github.com/moment/moment/issues/2166","        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||","                (milliseconds <= 0 && days <= 0 && months <= 0))) {","            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;","            days = 0;","            months = 0;","        }","","        // The following code bubbles up values, see the tests for","        // examples of what that means.","        data.milliseconds = milliseconds % 1000;","","        seconds           = absFloor(milliseconds / 1000);","        data.seconds      = seconds % 60;","","        minutes           = absFloor(seconds / 60);","        data.minutes      = minutes % 60;","","        hours             = absFloor(minutes / 60);","        data.hours        = hours % 24;","","        days += absFloor(hours / 24);","","        // convert days to months","        monthsFromDays = absFloor(daysToMonths(days));","        months += monthsFromDays;","        days -= absCeil(monthsToDays(monthsFromDays));","","        // 12 months -> 1 year","        years = absFloor(months / 12);","        months %= 12;","","        data.days   = days;","        data.months = months;","        data.years  = years;","","        return this;","    }","","    function daysToMonths (days) {","        // 400 years have 146097 days (taking into account leap year rules)","        // 400 years have 12 months === 4800","        return days * 4800 / 146097;","    }","","    function monthsToDays (months) {","        // the reverse of daysToMonths","        return months * 146097 / 4800;","    }","","    function as (units) {","        var days;","        var months;","        var milliseconds = this._milliseconds;","","        units = normalizeUnits(units);","","        if (units === 'month' || units === 'year') {","            days   = this._days   + milliseconds / 864e5;","            months = this._months + daysToMonths(days);","            return units === 'month' ? months : months / 12;","        } else {","            // handle milliseconds separately because of floating point math errors (issue #1867)","            days = this._days + Math.round(monthsToDays(this._months));","            switch (units) {","                case 'week'   : return days / 7     + milliseconds / 6048e5;","                case 'day'    : return days         + milliseconds / 864e5;","                case 'hour'   : return days * 24    + milliseconds / 36e5;","                case 'minute' : return days * 1440  + milliseconds / 6e4;","                case 'second' : return days * 86400 + milliseconds / 1000;","                // Math.floor prevents floating point math errors here","                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;","                default: throw new Error('Unknown unit ' + units);","            }","        }","    }","","    // TODO: Use this.as('ms')?","    function duration_as__valueOf () {","        return (","            this._milliseconds +","            this._days * 864e5 +","            (this._months % 12) * 2592e6 +","            toInt(this._months / 12) * 31536e6","        );","    }","","    function makeAs (alias) {","        return function () {","            return this.as(alias);","        };","    }","","    var asMilliseconds = makeAs('ms');","    var asSeconds      = makeAs('s');","    var asMinutes      = makeAs('m');","    var asHours        = makeAs('h');","    var asDays         = makeAs('d');","    var asWeeks        = makeAs('w');","    var asMonths       = makeAs('M');","    var asYears        = makeAs('y');","","    function duration_get__get (units) {","        units = normalizeUnits(units);","        return this[units + 's']();","    }","","    function makeGetter(name) {","        return function () {","            return this._data[name];","        };","    }","","    var milliseconds = makeGetter('milliseconds');","    var seconds      = makeGetter('seconds');","    var minutes      = makeGetter('minutes');","    var hours        = makeGetter('hours');","    var days         = makeGetter('days');","    var months       = makeGetter('months');","    var years        = makeGetter('years');","","    function weeks () {","        return absFloor(this.days() / 7);","    }","","    var round = Math.round;","    var thresholds = {","        s: 45,  // seconds to minute","        m: 45,  // minutes to hour","        h: 22,  // hours to day","        d: 26,  // days to month","        M: 11   // months to year","    };","","    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize","    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {","        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);","    }","","    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {","        var duration = create__createDuration(posNegDuration).abs();","        var seconds  = round(duration.as('s'));","        var minutes  = round(duration.as('m'));","        var hours    = round(duration.as('h'));","        var days     = round(duration.as('d'));","        var months   = round(duration.as('M'));","        var years    = round(duration.as('y'));","","        var a = seconds < thresholds.s && ['s', seconds]  ||","                minutes <= 1           && ['m']           ||","                minutes < thresholds.m && ['mm', minutes] ||","                hours   <= 1           && ['h']           ||","                hours   < thresholds.h && ['hh', hours]   ||","                days    <= 1           && ['d']           ||","                days    < thresholds.d && ['dd', days]    ||","                months  <= 1           && ['M']           ||","                months  < thresholds.M && ['MM', months]  ||","                years   <= 1           && ['y']           || ['yy', years];","","        a[2] = withoutSuffix;","        a[3] = +posNegDuration > 0;","        a[4] = locale;","        return substituteTimeAgo.apply(null, a);","    }","","    // This function allows you to set a threshold for relative time strings","    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {","        if (thresholds[threshold] === undefined) {","            return false;","        }","        if (limit === undefined) {","            return thresholds[threshold];","        }","        thresholds[threshold] = limit;","        return true;","    }","","    function humanize (withSuffix) {","        var locale = this.localeData();","        var output = duration_humanize__relativeTime(this, !withSuffix, locale);","","        if (withSuffix) {","            output = locale.pastFuture(+this, output);","        }","","        return locale.postformat(output);","    }","","    var iso_string__abs = Math.abs;","","    function iso_string__toISOString() {","        // for ISO strings we do not use the normal bubbling rules:","        //  * milliseconds bubble up until they become hours","        //  * days do not bubble at all","        //  * months bubble up until they become years","        // This is because there is no context-free conversion between hours and days","        // (think of clock changes)","        // and also not between days and months (28-31 days per month)","        var seconds = iso_string__abs(this._milliseconds) / 1000;","        var days         = iso_string__abs(this._days);","        var months       = iso_string__abs(this._months);","        var minutes, hours, years;","","        // 3600 seconds -> 60 minutes -> 1 hour","        minutes           = absFloor(seconds / 60);","        hours             = absFloor(minutes / 60);","        seconds %= 60;","        minutes %= 60;","","        // 12 months -> 1 year","        years  = absFloor(months / 12);","        months %= 12;","","","        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js","        var Y = years;","        var M = months;","        var D = days;","        var h = hours;","        var m = minutes;","        var s = seconds;","        var total = this.asSeconds();","","        if (!total) {","            // this is the same as C#'s (Noda) and python (isodate)...","            // but not other JS (goog.date)","            return 'P0D';","        }","","        return (total < 0 ? '-' : '') +","            'P' +","            (Y ? Y + 'Y' : '') +","            (M ? M + 'M' : '') +","            (D ? D + 'D' : '') +","            ((h || m || s) ? 'T' : '') +","            (h ? h + 'H' : '') +","            (m ? m + 'M' : '') +","            (s ? s + 'S' : '');","    }","","    var duration_prototype__proto = Duration.prototype;","","    duration_prototype__proto.abs            = duration_abs__abs;","    duration_prototype__proto.add            = duration_add_subtract__add;","    duration_prototype__proto.subtract       = duration_add_subtract__subtract;","    duration_prototype__proto.as             = as;","    duration_prototype__proto.asMilliseconds = asMilliseconds;","    duration_prototype__proto.asSeconds      = asSeconds;","    duration_prototype__proto.asMinutes      = asMinutes;","    duration_prototype__proto.asHours        = asHours;","    duration_prototype__proto.asDays         = asDays;","    duration_prototype__proto.asWeeks        = asWeeks;","    duration_prototype__proto.asMonths       = asMonths;","    duration_prototype__proto.asYears        = asYears;","    duration_prototype__proto.valueOf        = duration_as__valueOf;","    duration_prototype__proto._bubble        = bubble;","    duration_prototype__proto.get            = duration_get__get;","    duration_prototype__proto.milliseconds   = milliseconds;","    duration_prototype__proto.seconds        = seconds;","    duration_prototype__proto.minutes        = minutes;","    duration_prototype__proto.hours          = hours;","    duration_prototype__proto.days           = days;","    duration_prototype__proto.weeks          = weeks;","    duration_prototype__proto.months         = months;","    duration_prototype__proto.years          = years;","    duration_prototype__proto.humanize       = humanize;","    duration_prototype__proto.toISOString    = iso_string__toISOString;","    duration_prototype__proto.toString       = iso_string__toISOString;","    duration_prototype__proto.toJSON         = iso_string__toISOString;","    duration_prototype__proto.locale         = locale;","    duration_prototype__proto.localeData     = localeData;","","    // Deprecations","    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);","    duration_prototype__proto.lang = lang;","","    // Side effect imports","","    // FORMATTING","","    addFormatToken('X', 0, 0, 'unix');","    addFormatToken('x', 0, 0, 'valueOf');","","    // PARSING","","    addRegexToken('x', matchSigned);","    addRegexToken('X', matchTimestamp);","    addParseToken('X', function (input, array, config) {","        config._d = new Date(parseFloat(input, 10) * 1000);","    });","    addParseToken('x', function (input, array, config) {","        config._d = new Date(toInt(input));","    });","","    // Side effect imports","","","    utils_hooks__hooks.version = '2.13.0';","","    setHookCallback(local__createLocal);","","    utils_hooks__hooks.fn                    = momentPrototype;","    utils_hooks__hooks.min                   = min;","    utils_hooks__hooks.max                   = max;","    utils_hooks__hooks.now                   = now;","    utils_hooks__hooks.utc                   = create_utc__createUTC;","    utils_hooks__hooks.unix                  = moment__createUnix;","    utils_hooks__hooks.months                = lists__listMonths;","    utils_hooks__hooks.isDate                = isDate;","    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;","    utils_hooks__hooks.invalid               = valid__createInvalid;","    utils_hooks__hooks.duration              = create__createDuration;","    utils_hooks__hooks.isMoment              = isMoment;","    utils_hooks__hooks.weekdays              = lists__listWeekdays;","    utils_hooks__hooks.parseZone             = moment__createInZone;","    utils_hooks__hooks.localeData            = locale_locales__getLocale;","    utils_hooks__hooks.isDuration            = isDuration;","    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;","    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;","    utils_hooks__hooks.defineLocale          = defineLocale;","    utils_hooks__hooks.updateLocale          = updateLocale;","    utils_hooks__hooks.locales               = locale_locales__listLocales;","    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;","    utils_hooks__hooks.normalizeUnits        = normalizeUnits;","    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;","    utils_hooks__hooks.prototype             = momentPrototype;","","    var _moment = utils_hooks__hooks;","","    return _moment;","","}));","},{}],7:[function(require,module,exports){","/**"," * @namespace Chart"," */","var Chart = require(26)();","","require(25)(Chart);","require(24)(Chart);","require(21)(Chart);","require(22)(Chart);","require(23)(Chart);","require(27)(Chart);","require(31)(Chart);","require(29)(Chart);","require(30)(Chart);","require(32)(Chart);","require(28)(Chart);","require(33)(Chart);","","require(34)(Chart);","require(35)(Chart);","require(36)(Chart);","require(37)(Chart);","","require(40)(Chart);","require(38)(Chart);","require(39)(Chart);","require(41)(Chart);","require(42)(Chart);","require(43)(Chart);","","// Controllers must be loaded after elements","// See Chart.core.datasetController.dataElementType","require(15)(Chart);","require(16)(Chart);","require(17)(Chart);","require(18)(Chart);","require(19)(Chart);","require(20)(Chart);","","require(8)(Chart);","require(9)(Chart);","require(10)(Chart);","require(11)(Chart);","require(12)(Chart);","require(13)(Chart);","require(14)(Chart);","","window.Chart = module.exports = Chart;","","},{\"10\":10,\"11\":11,\"12\":12,\"13\":13,\"14\":14,\"15\":15,\"16\":16,\"17\":17,\"18\":18,\"19\":19,\"20\":20,\"21\":21,\"22\":22,\"23\":23,\"24\":24,\"25\":25,\"26\":26,\"27\":27,\"28\":28,\"29\":29,\"30\":30,\"31\":31,\"32\":32,\"33\":33,\"34\":34,\"35\":35,\"36\":36,\"37\":37,\"38\":38,\"39\":39,\"40\":40,\"41\":41,\"42\":42,\"43\":43,\"8\":8,\"9\":9}],8:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tChart.Bar = function(context, config) {","\t\tconfig.type = 'bar';","","\t\treturn new Chart(context, config);","\t};","","};","},{}],9:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tChart.Bubble = function(context, config) {","\t\tconfig.type = 'bubble';","\t\treturn new Chart(context, config);","\t};","","};","},{}],10:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tChart.Doughnut = function(context, config) {","\t\tconfig.type = 'doughnut';","","\t\treturn new Chart(context, config);","\t};","","};","},{}],11:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tChart.Line = function(context, config) {","\t\tconfig.type = 'line';","","\t\treturn new Chart(context, config);","\t};","","};","},{}],12:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tChart.PolarArea = function(context, config) {","\t\tconfig.type = 'polarArea';","","\t\treturn new Chart(context, config);","\t};","","};","},{}],13:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","\t","\tChart.Radar = function(context, config) {","\t\tconfig.options = Chart.helpers.configMerge({ aspectRatio: 1 }, config.options);","\t\tconfig.type = 'radar';","","\t\treturn new Chart(context, config);","\t};","","};","","},{}],14:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar defaultConfig = {","\t\thover: {","\t\t\tmode: 'single'","\t\t},","","\t\tscales: {","\t\t\txAxes: [{","\t\t\t\ttype: \"linear\", // scatter should not use a category axis","\t\t\t\tposition: \"bottom\",","\t\t\t\tid: \"x-axis-1\" // need an ID so datasets can reference the scale","\t\t\t}],","\t\t\tyAxes: [{","\t\t\t\ttype: \"linear\",","\t\t\t\tposition: \"left\",","\t\t\t\tid: \"y-axis-1\"","\t\t\t}]","\t\t},","","\t\ttooltips: {","\t\t\tcallbacks: {","\t\t\t\ttitle: function(tooltipItems, data) {","\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point","\t\t\t\t\treturn '';","\t\t\t\t},","\t\t\t\tlabel: function(tooltipItem, data) {","\t\t\t\t\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\t// Register the default config for this type","\tChart.defaults.scatter = defaultConfig;","","\t// Scatter charts use line controllers","\tChart.controllers.scatter = Chart.controllers.line;","","\tChart.Scatter = function(context, config) {","\t\tconfig.type = 'scatter';","\t\treturn new Chart(context, config);","\t};","","};","},{}],15:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.bar = {","\t\thover: {","\t\t\tmode: \"label\"","\t\t},","","\t\tscales: {","\t\t\txAxes: [{","\t\t\t\ttype: \"category\",","","\t\t\t\t// Specific to Bar Controller","\t\t\t\tcategoryPercentage: 0.8,","\t\t\t\tbarPercentage: 0.9,","","\t\t\t\t// grid line settings","\t\t\t\tgridLines: {","\t\t\t\t\toffsetGridLines: true","\t\t\t\t}","\t\t\t}],","\t\t\tyAxes: [{","\t\t\t\ttype: \"linear\"","\t\t\t}]","\t\t}","\t};","","\tChart.controllers.bar = Chart.DatasetController.extend({","","\t\tdataElementType: Chart.elements.Rectangle,","","\t\tinitialize: function(chart, datasetIndex) {","\t\t\tChart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);","","\t\t\t// Use this to indicate that this is a bar dataset.","\t\t\tthis.getMeta().bar = true;","\t\t},","","\t\t// Get the number of datasets that display bars. We use this to correctly calculate the bar width","\t\tgetBarCount: function getBarCount() {","\t\t\tvar me = this;","\t\t\tvar barCount = 0;","\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tvar meta = me.chart.getDatasetMeta(datasetIndex);","\t\t\t\tif (meta.bar && me.chart.isDatasetVisible(datasetIndex)) {","\t\t\t\t\t++barCount;","\t\t\t\t}","\t\t\t}, me);","\t\t\treturn barCount;","\t\t},","","\t\tupdate: function update(reset) {","\t\t\tvar me = this;","\t\t\thelpers.each(me.getMeta().data, function(rectangle, index) {","\t\t\t\tme.updateElement(rectangle, index, reset);","\t\t\t}, me);","\t\t},","","\t\tupdateElement: function updateElement(rectangle, index, reset) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar scaleBase = yScale.getBasePixel();","\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;","\t\t\tvar custom = rectangle.custom || {};","\t\t\tvar dataset = me.getDataset();","","\t\t\thelpers.extend(rectangle, {","\t\t\t\t// Utility","\t\t\t\t_xScale: xScale,","\t\t\t\t_yScale: yScale,","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t_index: index,","","\t\t\t\t// Desired view properties","\t\t\t\t_model: {","\t\t\t\t\tx: me.calculateBarX(index, me.index),","\t\t\t\t\ty: reset ? scaleBase : me.calculateBarY(index, me.index),","","\t\t\t\t\t// Tooltip","\t\t\t\t\tlabel: me.chart.data.labels[index],","\t\t\t\t\tdatasetLabel: dataset.label,","","\t\t\t\t\t// Appearance","\t\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),","\t\t\t\t\twidth: me.calculateBarWidth(index),","\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),","\t\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,","\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),","\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)","\t\t\t\t}","\t\t\t});","\t\t\trectangle.pivot();","\t\t},","","\t\tcalculateBarBase: function(datasetIndex, index) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar base = 0;","","\t\t\tif (yScale.options.stacked) {","\t\t\t\tvar chart = me.chart;","\t\t\t\tvar datasets = chart.data.datasets;","\t\t\t\tvar value = datasets[datasetIndex].data[index];","","\t\t\t\tif (value < 0) {","\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {","\t\t\t\t\t\tvar negDS = datasets[i];","\t\t\t\t\t\tvar negDSMeta = chart.getDatasetMeta(i);","\t\t\t\t\t\tif (negDSMeta.bar && negDSMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {","\t\t\t\t\t\t\tbase += negDS.data[index] < 0 ? negDS.data[index] : 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t} else {","\t\t\t\t\tfor (var j = 0; j < datasetIndex; j++) {","\t\t\t\t\t\tvar posDS = datasets[j];","\t\t\t\t\t\tvar posDSMeta = chart.getDatasetMeta(j);","\t\t\t\t\t\tif (posDSMeta.bar && posDSMeta.yAxisID === yScale.id && chart.isDatasetVisible(j)) {","\t\t\t\t\t\t\tbase += posDS.data[index] > 0 ? posDS.data[index] : 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\treturn yScale.getPixelForValue(base);","\t\t\t}","","\t\t\treturn yScale.getBasePixel();","\t\t},","","\t\tgetRuler: function(index) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar datasetCount = me.getBarCount();","","\t\t\tvar tickWidth;","","\t\t\tif (xScale.options.type === 'category') {","\t\t\t\ttickWidth = xScale.getPixelForTick(index + 1) - xScale.getPixelForTick(index);","\t\t\t} else {","\t\t\t\t// Average width","\t\t\t\ttickWidth = xScale.width / xScale.ticks.length;","\t\t\t}","\t\t\tvar categoryWidth = tickWidth * xScale.options.categoryPercentage;","\t\t\tvar categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;","\t\t\tvar fullBarWidth = categoryWidth / datasetCount;","","\t\t\tif (xScale.ticks.length !== me.chart.data.labels.length) {","\t\t\t    var perc = xScale.ticks.length / me.chart.data.labels.length;","\t\t\t    fullBarWidth = fullBarWidth * perc;","\t\t\t}","","\t\t\tvar barWidth = fullBarWidth * xScale.options.barPercentage;","\t\t\tvar barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);","","\t\t\treturn {","\t\t\t\tdatasetCount: datasetCount,","\t\t\t\ttickWidth: tickWidth,","\t\t\t\tcategoryWidth: categoryWidth,","\t\t\t\tcategorySpacing: categorySpacing,","\t\t\t\tfullBarWidth: fullBarWidth,","\t\t\t\tbarWidth: barWidth,","\t\t\t\tbarSpacing: barSpacing","\t\t\t};","\t\t},","","\t\tcalculateBarWidth: function(index) {","\t\t\tvar xScale = this.getScaleForId(this.getMeta().xAxisID);","\t\t\tvar ruler = this.getRuler(index);","\t\t\treturn xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth;","\t\t},","","\t\t// Get bar index from the given dataset index accounting for the fact that not all bars are visible","\t\tgetBarIndex: function(datasetIndex) {","\t\t\tvar barIndex = 0;","\t\t\tvar meta, j;","","\t\t\tfor (j = 0; j < datasetIndex; ++j) {","\t\t\t\tmeta = this.chart.getDatasetMeta(j);","\t\t\t\tif (meta.bar && this.chart.isDatasetVisible(j)) {","\t\t\t\t\t++barIndex;","\t\t\t\t}","\t\t\t}","","\t\t\treturn barIndex;","\t\t},","","\t\tcalculateBarX: function(index, datasetIndex) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar barIndex = me.getBarIndex(datasetIndex);","","\t\t\tvar ruler = me.getRuler(index);","\t\t\tvar leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);","\t\t\tleftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;","","\t\t\tif (xScale.options.stacked) {","\t\t\t\treturn leftTick + (ruler.categoryWidth / 2) + ruler.categorySpacing;","\t\t\t}","","\t\t\treturn leftTick +","\t\t\t\t(ruler.barWidth / 2) +","\t\t\t\truler.categorySpacing +","\t\t\t\t(ruler.barWidth * barIndex) +","\t\t\t\t(ruler.barSpacing / 2) +","\t\t\t\t(ruler.barSpacing * barIndex);","\t\t},","","\t\tcalculateBarY: function(index, datasetIndex) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar value = me.getDataset().data[index];","","\t\t\tif (yScale.options.stacked) {","","\t\t\t\tvar sumPos = 0,","\t\t\t\t\tsumNeg = 0;","","\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {","\t\t\t\t\tvar ds = me.chart.data.datasets[i];","\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);","\t\t\t\t\tif (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i)) {","\t\t\t\t\t\tif (ds.data[index] < 0) {","\t\t\t\t\t\t\tsumNeg += ds.data[index] || 0;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tsumPos += ds.data[index] || 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tif (value < 0) {","\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + value);","\t\t\t\t} else {","\t\t\t\t\treturn yScale.getPixelForValue(sumPos + value);","\t\t\t\t}","\t\t\t}","","\t\t\treturn yScale.getPixelForValue(value);","\t\t},","","\t\tdraw: function(ease) {","\t\t\tvar me = this;","\t\t\tvar easingDecimal = ease || 1;","\t\t\thelpers.each(me.getMeta().data, function(rectangle, index) {","\t\t\t\tvar d = me.getDataset().data[index];","\t\t\t\tif (d !== null && d !== undefined && !isNaN(d)) {","\t\t\t\t\trectangle.transition(easingDecimal).draw();","\t\t\t\t}","\t\t\t}, me);","\t\t},","","\t\tsetHoverStyle: function(rectangle) {","\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];","\t\t\tvar index = rectangle._index;","","\t\t\tvar custom = rectangle.custom || {};","\t\t\tvar model = rectangle._model;","\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));","\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));","\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);","\t\t},","","\t\tremoveHoverStyle: function(rectangle) {","\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];","\t\t\tvar index = rectangle._index;","\t\t\tvar custom = rectangle.custom || {};","\t\t\tvar model = rectangle._model;","\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;","","\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);","\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);","\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);","\t\t}","","\t});","","","\t// including horizontalBar in the bar file, instead of a file of its own","\t// it extends bar (like pie extends doughnut)","\tChart.defaults.horizontalBar = {","\t\thover: {","\t\t\tmode: \"label\"","\t\t},","","\t\tscales: {","\t\t\txAxes: [{","\t\t\t\ttype: \"linear\",","\t\t\t\tposition: \"bottom\"","\t\t\t}],","\t\t\tyAxes: [{","\t\t\t\tposition: \"left\",","\t\t\t\ttype: \"category\",","","\t\t\t\t// Specific to Horizontal Bar Controller","\t\t\t\tcategoryPercentage: 0.8,","\t\t\t\tbarPercentage: 0.9,","","\t\t\t\t// grid line settings","\t\t\t\tgridLines: {","\t\t\t\t\toffsetGridLines: true","\t\t\t\t}","\t\t\t}]","\t\t},","\t\telements: {","\t\t\trectangle: {","\t\t\t\tborderSkipped: 'left'","\t\t\t}","\t\t},","\t\ttooltips: {","\t\t\tcallbacks: {","\t\t\t\ttitle: function(tooltipItems, data) {","\t\t\t\t\t// Pick first xLabel for now","\t\t\t\t\tvar title = '';","","\t\t\t\t\tif (tooltipItems.length > 0) {","\t\t\t\t\t\tif (tooltipItems[0].yLabel) {","\t\t\t\t\t\t\ttitle = tooltipItems[0].yLabel;","\t\t\t\t\t\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {","\t\t\t\t\t\t\ttitle = data.labels[tooltipItems[0].index];","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\treturn title;","\t\t\t\t},","\t\t\t\tlabel: function(tooltipItem, data) {","\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';","\t\t\t\treturn datasetLabel + ': ' + tooltipItem.xLabel;","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({","\t\tupdateElement: function updateElement(rectangle, index, reset, numBars) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar scaleBase = xScale.getBasePixel();","\t\t\tvar custom = rectangle.custom || {};","\t\t\tvar dataset = me.getDataset();","\t\t\tvar rectangleElementOptions = me.chart.options.elements.rectangle;","","\t\t\thelpers.extend(rectangle, {","\t\t\t\t// Utility","\t\t\t\t_xScale: xScale,","\t\t\t\t_yScale: yScale,","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t_index: index,","","\t\t\t\t// Desired view properties","\t\t\t\t_model: {","\t\t\t\t\tx: reset ? scaleBase : me.calculateBarX(index, me.index),","\t\t\t\t\ty: me.calculateBarY(index, me.index),","","\t\t\t\t\t// Tooltip","\t\t\t\t\tlabel: me.chart.data.labels[index],","\t\t\t\t\tdatasetLabel: dataset.label,","","\t\t\t\t\t// Appearance","\t\t\t\t\tbase: reset ? scaleBase : me.calculateBarBase(me.index, index),","\t\t\t\t\theight: me.calculateBarHeight(index),","\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),","\t\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,","\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),","\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)","\t\t\t\t},","","\t\t\t\tdraw: function () {","\t\t\t\t\tvar ctx = this._chart.ctx;","\t\t\t\t\tvar vm = this._view;","","\t\t\t\t\tvar halfHeight = vm.height / 2,","\t\t\t\t\t\ttopY = vm.y - halfHeight,","\t\t\t\t\t\tbottomY = vm.y + halfHeight,","\t\t\t\t\t\tright = vm.base - (vm.base - vm.x),","\t\t\t\t\t\thalfStroke = vm.borderWidth / 2;","","\t\t\t\t\t// Canvas doesn't allow us to stroke inside the width so we can","\t\t\t\t\t// adjust the sizes to fit if we're setting a stroke on the line","\t\t\t\t\tif (vm.borderWidth) {","\t\t\t\t\t\ttopY += halfStroke;","\t\t\t\t\t\tbottomY -= halfStroke;","\t\t\t\t\t\tright += halfStroke;","\t\t\t\t\t}","","\t\t\t\t\tctx.beginPath();","","\t\t\t\t\tctx.fillStyle = vm.backgroundColor;","\t\t\t\t\tctx.strokeStyle = vm.borderColor;","\t\t\t\t\tctx.lineWidth = vm.borderWidth;","","\t\t\t\t\t// Corner points, from bottom-left to bottom-right clockwise","\t\t\t\t\t// | 1 2 |","\t\t\t\t\t// | 0 3 |","\t\t\t\t\tvar corners = [","\t\t\t\t\t\t[vm.base, bottomY],","\t\t\t\t\t\t[vm.base, topY],","\t\t\t\t\t\t[right, topY],","\t\t\t\t\t\t[right, bottomY]","\t\t\t\t\t];","","\t\t\t\t\t// Find first (starting) corner with fallback to 'bottom'","\t\t\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];","\t\t\t\t\tvar startCorner = borders.indexOf(vm.borderSkipped, 0);","\t\t\t\t\tif (startCorner === -1)","\t\t\t\t\t\tstartCorner = 0;","","\t\t\t\t\tfunction cornerAt(index) {","\t\t\t\t\t\treturn corners[(startCorner + index) % 4];","\t\t\t\t\t}","","\t\t\t\t\t// Draw rectangle from 'startCorner'","\t\t\t\t\tctx.moveTo.apply(ctx, cornerAt(0));","\t\t\t\t\tfor (var i = 1; i < 4; i++)","\t\t\t\t\t\tctx.lineTo.apply(ctx, cornerAt(i));","","\t\t\t\t\tctx.fill();","\t\t\t\t\tif (vm.borderWidth) {","\t\t\t\t\t\tctx.stroke();","\t\t\t\t\t}","\t\t\t\t},","","\t\t\t\tinRange: function (mouseX, mouseY) {","\t\t\t\t\tvar vm = this._view;","\t\t\t\t\tvar inRange = false;","","\t\t\t\t\tif (vm) {","\t\t\t\t\t\tif (vm.x < vm.base) {","\t\t\t\t\t\t\tinRange = (mouseY >= vm.y - vm.height / 2 && mouseY <= vm.y + vm.height / 2) && (mouseX >= vm.x && mouseX <= vm.base);","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tinRange = (mouseY >= vm.y - vm.height / 2 && mouseY <= vm.y + vm.height / 2) && (mouseX >= vm.base && mouseX <= vm.x);","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\treturn inRange;","\t\t\t\t}","\t\t\t});","","\t\t\trectangle.pivot();","\t\t},","","\t\tcalculateBarBase: function (datasetIndex, index) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar base = 0;","","\t\t\tif (xScale.options.stacked) {","","\t\t\t\tvar value = me.chart.data.datasets[datasetIndex].data[index];","","\t\t\t\tif (value < 0) {","\t\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {","\t\t\t\t\t\tvar negDS = me.chart.data.datasets[i];","\t\t\t\t\t\tvar negDSMeta = me.chart.getDatasetMeta(i);","\t\t\t\t\t\tif (negDSMeta.bar && negDSMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i)) {","\t\t\t\t\t\t\tbase += negDS.data[index] < 0 ? negDS.data[index] : 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t} else {","\t\t\t\t\tfor (var j = 0; j < datasetIndex; j++) {","\t\t\t\t\t\tvar posDS = me.chart.data.datasets[j];","\t\t\t\t\t\tvar posDSMeta = me.chart.getDatasetMeta(j);","\t\t\t\t\t\tif (posDSMeta.bar && posDSMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(j)) {","\t\t\t\t\t\t\tbase += posDS.data[index] > 0 ? posDS.data[index] : 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\treturn xScale.getPixelForValue(base);","\t\t\t}","","\t\t\treturn xScale.getBasePixel();","\t\t},","","\t\tgetRuler: function (index) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar datasetCount = me.getBarCount();","","\t\t\tvar tickHeight;","\t\t\tif (yScale.options.type === 'category') {","\t\t\t\ttickHeight = yScale.getPixelForTick(index + 1) - yScale.getPixelForTick(index);","\t\t\t} else {","\t\t\t\t// Average width","\t\t\t\ttickHeight = yScale.width / yScale.ticks.length;","\t\t\t}","\t\t\tvar categoryHeight = tickHeight * yScale.options.categoryPercentage;","\t\t\tvar categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;","\t\t\tvar fullBarHeight = categoryHeight / datasetCount;","","\t\t\tif (yScale.ticks.length !== me.chart.data.labels.length) {","\t\t\t\tvar perc = yScale.ticks.length / me.chart.data.labels.length;","\t\t\t\tfullBarHeight = fullBarHeight * perc;","\t\t\t}","","\t\t\tvar barHeight = fullBarHeight * yScale.options.barPercentage;","\t\t\tvar barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);","","\t\t\treturn {","\t\t\t\tdatasetCount: datasetCount,","\t\t\t\ttickHeight: tickHeight,","\t\t\t\tcategoryHeight: categoryHeight,","\t\t\t\tcategorySpacing: categorySpacing,","\t\t\t\tfullBarHeight: fullBarHeight,","\t\t\t\tbarHeight: barHeight,","\t\t\t\tbarSpacing: barSpacing,","\t\t\t};","\t\t},","","\t\tcalculateBarHeight: function (index) {","\t\t\tvar me = this;","\t\t\tvar yScale = me.getScaleForId(me.getMeta().yAxisID);","\t\t\tvar ruler = me.getRuler(index);","\t\t\treturn yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight;","\t\t},","","\t\tcalculateBarX: function (index, datasetIndex) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar value = me.getDataset().data[index];","","\t\t\tif (xScale.options.stacked) {","","\t\t\t\tvar sumPos = 0,","\t\t\t\t\tsumNeg = 0;","","\t\t\t\tfor (var i = 0; i < datasetIndex; i++) {","\t\t\t\t\tvar ds = me.chart.data.datasets[i];","\t\t\t\t\tvar dsMeta = me.chart.getDatasetMeta(i);","\t\t\t\t\tif (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i)) {","\t\t\t\t\t\tif (ds.data[index] < 0) {","\t\t\t\t\t\t\tsumNeg += ds.data[index] || 0;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tsumPos += ds.data[index] || 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tif (value < 0) {","\t\t\t\t\treturn xScale.getPixelForValue(sumNeg + value);","\t\t\t\t} else {","\t\t\t\t\treturn xScale.getPixelForValue(sumPos + value);","\t\t\t\t}","\t\t\t}","","\t\t\treturn xScale.getPixelForValue(value);","\t\t},","","\t\tcalculateBarY: function (index, datasetIndex) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar barIndex = me.getBarIndex(datasetIndex);","","\t\t\tvar ruler = me.getRuler(index);","\t\t\tvar topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);","\t\t\ttopTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;","","\t\t\tif (yScale.options.stacked) {","\t\t\t\treturn topTick + (ruler.categoryHeight / 2) + ruler.categorySpacing;","\t\t\t}","","\t\t\treturn topTick +","\t\t\t\t(ruler.barHeight / 2) +","\t\t\t\truler.categorySpacing +","\t\t\t\t(ruler.barHeight * barIndex) +","\t\t\t\t(ruler.barSpacing / 2) +","\t\t\t\t(ruler.barSpacing * barIndex);","\t\t}","\t});","};","","},{}],16:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.bubble = {","\t\thover: {","\t\t\tmode: \"single\"","\t\t},","","\t\tscales: {","\t\t\txAxes: [{","\t\t\t\ttype: \"linear\", // bubble should probably use a linear scale by default","\t\t\t\tposition: \"bottom\",","\t\t\t\tid: \"x-axis-0\" // need an ID so datasets can reference the scale","\t\t\t}],","\t\t\tyAxes: [{","\t\t\t\ttype: \"linear\",","\t\t\t\tposition: \"left\",","\t\t\t\tid: \"y-axis-0\"","\t\t\t}]","\t\t},","","\t\ttooltips: {","\t\t\tcallbacks: {","\t\t\t\ttitle: function(tooltipItems, data) {","\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point","\t\t\t\t\treturn '';","\t\t\t\t},","\t\t\t\tlabel: function(tooltipItem, data) {","\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';","\t\t\t\t\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];","\t\t\t\t\treturn datasetLabel + ': (' + dataPoint.x + ', ' + dataPoint.y + ', ' + dataPoint.r + ')';","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\tChart.controllers.bubble = Chart.DatasetController.extend({","","\t\tdataElementType: Chart.elements.Point,","","\t\tupdate: function update(reset) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar points = meta.data;","","\t\t\t// Update Points","\t\t\thelpers.each(points, function(point, index) {","\t\t\t\tme.updateElement(point, index, reset);","\t\t\t});","\t\t},","","\t\tupdateElement: function(point, index, reset) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","","\t\t\tvar custom = point.custom || {};","\t\t\tvar dataset = me.getDataset();","\t\t\tvar data = dataset.data[index];","\t\t\tvar pointElementOptions = me.chart.options.elements.point;","\t\t\tvar dsIndex = me.index;","","\t\t\thelpers.extend(point, {","\t\t\t\t// Utility","\t\t\t\t_xScale: xScale,","\t\t\t\t_yScale: yScale,","\t\t\t\t_datasetIndex: dsIndex,","\t\t\t\t_index: index,","","\t\t\t\t// Desired view properties","\t\t\t\t_model: {","\t\t\t\t\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(data, index, dsIndex, me.chart.isCombo),","\t\t\t\t\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),","\t\t\t\t\t// Appearance","\t\t\t\t\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),","","\t\t\t\t\t// Tooltip","\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)","\t\t\t\t}","\t\t\t});","","\t\t\t// Trick to reset the styles of the point","\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);","","\t\t\tvar model = point._model;","\t\t\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));","","\t\t\tpoint.pivot();","\t\t},","","\t\tgetRadius: function(value) {","\t\t\treturn value.r || this.chart.options.elements.point.radius;","\t\t},","","\t\tsetHoverStyle: function(point) {","\t\t\tvar me = this;","\t\t\tChart.DatasetController.prototype.setHoverStyle.call(me, point);","","\t\t\t// Radius","\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];","\t\t\tvar index = point._index;","\t\t\tvar custom = point.custom || {};","\t\t\tvar model = point._model;","\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);","\t\t},","","\t\tremoveHoverStyle: function(point) {","\t\t\tvar me = this;","\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);","","\t\t\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];","\t\t\tvar custom = point.custom || {};","\t\t\tvar model = point._model;","","\t\t\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);","\t\t}","\t});","};","","},{}],17:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers,","\t\tdefaults = Chart.defaults;","","\tdefaults.doughnut = {","\t\tanimation: {","\t\t\t//Boolean - Whether we animate the rotation of the Doughnut","\t\t\tanimateRotate: true,","\t\t\t//Boolean - Whether we animate scaling the Doughnut from the centre","\t\t\tanimateScale: false","\t\t},","\t\taspectRatio: 1,","\t\thover: {","\t\t\tmode: 'single'","\t\t},","\t\tlegendCallback: function(chart) {","\t\t\tvar text = [];","\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');","","\t\t\tvar data = chart.data;","\t\t\tvar datasets = data.datasets;","\t\t\tvar labels = data.labels;","","\t\t\tif (datasets.length) {","\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {","\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');","\t\t\t\t\tif (labels[i]) {","\t\t\t\t\t\ttext.push(labels[i]);","\t\t\t\t\t}","\t\t\t\t\ttext.push('</li>');","\t\t\t\t}","\t\t\t}","","\t\t\ttext.push('</ul>');","\t\t\treturn text.join(\"\");","\t\t},","\t\tlegend: {","\t\t\tlabels: {","\t\t\t\tgenerateLabels: function(chart) {","\t\t\t\t\tvar data = chart.data;","\t\t\t\t\tif (data.labels.length && data.datasets.length) {","\t\t\t\t\t\treturn data.labels.map(function(label, i) {","\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);","\t\t\t\t\t\t\tvar ds = data.datasets[0];","\t\t\t\t\t\t\tvar arc = meta.data[i];","\t\t\t\t\t\t\tvar custom = arc.custom || {};","\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;","\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;","\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);","\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);","\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);","","\t\t\t\t\t\t\treturn {","\t\t\t\t\t\t\t\ttext: label,","\t\t\t\t\t\t\t\tfillStyle: fill,","\t\t\t\t\t\t\t\tstrokeStyle: stroke,","\t\t\t\t\t\t\t\tlineWidth: bw,","\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,","","\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item","\t\t\t\t\t\t\t\tindex: i","\t\t\t\t\t\t\t};","\t\t\t\t\t\t});","\t\t\t\t\t} else {","\t\t\t\t\t\treturn [];","\t\t\t\t\t}","\t\t\t\t}","\t\t\t},","","\t\t\tonClick: function(e, legendItem) {","\t\t\t\tvar index = legendItem.index;","\t\t\t\tvar chart = this.chart;","\t\t\t\tvar i, ilen, meta;","","\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {","\t\t\t\t\tmeta = chart.getDatasetMeta(i);","\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;","\t\t\t\t}","","\t\t\t\tchart.update();","\t\t\t}","\t\t},","","\t\t//The percentage of the chart that we cut out of the middle.","\t\tcutoutPercentage: 50,","","\t\t//The rotation of the chart, where the first data arc begins.","\t\trotation: Math.PI * -0.5,","","\t\t//The total circumference of the chart.","\t\tcircumference: Math.PI * 2.0,","","\t\t// Need to override these to give a nice default","\t\ttooltips: {","\t\t\tcallbacks: {","\t\t\t\ttitle: function() {","\t\t\t\t\treturn '';","\t\t\t\t},","\t\t\t\tlabel: function(tooltipItem, data) {","\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\tdefaults.pie = helpers.clone(defaults.doughnut);","\thelpers.extend(defaults.pie, {","\t\tcutoutPercentage: 0","\t});","","","\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({","","\t\tdataElementType: Chart.elements.Arc,","","\t\tlinkScales: helpers.noop,","","\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly","\t\tgetRingIndex: function getRingIndex(datasetIndex) {","\t\t\tvar ringIndex = 0;","","\t\t\tfor (var j = 0; j < datasetIndex; ++j) {","\t\t\t\tif (this.chart.isDatasetVisible(j)) {","\t\t\t\t\t++ringIndex;","\t\t\t\t}","\t\t\t}","","\t\t\treturn ringIndex;","\t\t},","","\t\tupdate: function update(reset) {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart,","\t\t\t\tchartArea = chart.chartArea,","\t\t\t\topts = chart.options,","\t\t\t\tarcOpts = opts.elements.arc,","\t\t\t\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,","\t\t\t\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,","\t\t\t\tminSize = Math.min(availableWidth, availableHeight),","\t\t\t\toffset = {","\t\t\t\t\tx: 0,","\t\t\t\t\ty: 0","\t\t\t\t},","\t\t\t\tmeta = me.getMeta(),","\t\t\t\tcutoutPercentage = opts.cutoutPercentage,","\t\t\t\tcircumference = opts.circumference;","","\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc","\t\t\tif (circumference < Math.PI * 2.0) {","\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);","\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);","\t\t\t\tvar endAngle = startAngle + circumference;","\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};","\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};","\t\t\t\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);","\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);","\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);","\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);","\t\t\t\tvar cutout = cutoutPercentage / 100.0;","\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};","\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};","\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};","\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);","\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};","\t\t\t}","","\t\t\tchart.outerRadius = Math.max(minSize / 2, 0);","\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 1, 0);","\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();","\t\t\tchart.offsetX = offset.x * chart.outerRadius;","\t\t\tchart.offsetY = offset.y * chart.outerRadius;","","\t\t\tmeta.total = me.calculateTotal();","","\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));","\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;","","\t\t\thelpers.each(meta.data, function(arc, index) {","\t\t\t\tme.updateElement(arc, index, reset);","\t\t\t});","\t\t},","","\t\tupdateElement: function(arc, index, reset) {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart,","\t\t\t\tchartArea = chart.chartArea,","\t\t\t\topts = chart.options,","\t\t\t\tanimationOpts = opts.animation,","\t\t\t\tarcOpts = opts.elements.arc,","\t\t\t\tcenterX = (chartArea.left + chartArea.right) / 2,","\t\t\t\tcenterY = (chartArea.top + chartArea.bottom) / 2,","\t\t\t\tstartAngle = opts.rotation, // non reset case handled later","\t\t\t\tendAngle = opts.rotation, // non reset case handled later","\t\t\t\tdataset = me.getDataset(),","\t\t\t\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),","\t\t\t\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,","\t\t\t\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,","\t\t\t\tcustom = arc.custom || {},","\t\t\t\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;","","\t\t\thelpers.extend(arc, {","\t\t\t\t// Utility","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t_index: index,","","\t\t\t\t// Desired view properties","\t\t\t\t_model: {","\t\t\t\t\tx: centerX + chart.offsetX,","\t\t\t\t\ty: centerY + chart.offsetY,","\t\t\t\t\tstartAngle: startAngle,","\t\t\t\t\tendAngle: endAngle,","\t\t\t\t\tcircumference: circumference,","\t\t\t\t\touterRadius: outerRadius,","\t\t\t\t\tinnerRadius: innerRadius,","\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])","\t\t\t\t}","\t\t\t});","","\t\t\tvar model = arc._model;","\t\t\t// Resets the visual styles","\t\t\tthis.removeHoverStyle(arc);","","\t\t\t// Set correct angles if not resetting","\t\t\tif (!reset || !animationOpts.animateRotate) {","\t\t\t\tif (index === 0) {","\t\t\t\t\tmodel.startAngle = opts.rotation;","\t\t\t\t} else {","\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;","\t\t\t\t}","","\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;","\t\t\t}","","\t\t\tarc.pivot();","\t\t},","","\t\tremoveHoverStyle: function(arc) {","\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);","\t\t},","","\t\tcalculateTotal: function() {","\t\t\tvar dataset = this.getDataset();","\t\t\tvar meta = this.getMeta();","\t\t\tvar total = 0;","\t\t\tvar value;","","\t\t\thelpers.each(meta.data, function(element, index) {","\t\t\t\tvalue = dataset.data[index];","\t\t\t\tif (!isNaN(value) && !element.hidden) {","\t\t\t\t\ttotal += Math.abs(value);","\t\t\t\t}","\t\t\t});","","\t\t\treturn total;","\t\t},","","\t\tcalculateCircumference: function(value) {","\t\t\tvar total = this.getMeta().total;","\t\t\tif (total > 0 && !isNaN(value)) {","\t\t\t\treturn (Math.PI * 2.0) * (value / total);","\t\t\t} else {","\t\t\t\treturn 0;","\t\t\t}","\t\t}","\t});","};","","},{}],18:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.line = {","\t\tshowLines: true,","","\t\thover: {","\t\t\tmode: \"label\"","\t\t},","","\t\tscales: {","\t\t\txAxes: [{","\t\t\t\ttype: \"category\",","\t\t\t\tid: 'x-axis-0'","\t\t\t}],","\t\t\tyAxes: [{","\t\t\t\ttype: \"linear\",","\t\t\t\tid: 'y-axis-0'","\t\t\t}]","\t\t}","\t};","","\tfunction lineEnabled(dataset, options) {","\t\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);","\t}","","\tChart.controllers.line = Chart.DatasetController.extend({","","\t\tdatasetElementType: Chart.elements.Line,","","\t\tdataElementType: Chart.elements.Point,","","\t\taddElementAndReset: function(index) {","\t\t\tvar me = this;","\t\t\tvar options = me.chart.options;","\t\t\tvar meta = me.getMeta();","","\t\t\tChart.DatasetController.prototype.addElementAndReset.call(me, index);","","\t\t\t// Make sure bezier control points are updated","\t\t\tif (lineEnabled(me.getDataset(), options) && meta.dataset._model.tension !== 0) {","\t\t\t\tme.updateBezierControlPoints();","\t\t\t}","\t\t},","","\t\tupdate: function update(reset) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar line = meta.dataset;","\t\t\tvar points = meta.data || [];","\t\t\tvar options = me.chart.options;","\t\t\tvar lineElementOptions = options.elements.line;","\t\t\tvar scale = me.getScaleForId(meta.yAxisID);","\t\t\tvar i, ilen, custom;","\t\t\tvar dataset = me.getDataset();","\t\t\tvar showLine = lineEnabled(dataset, options);","","\t\t\t// Update Line","\t\t\tif (showLine) {","\t\t\t\tcustom = line.custom || {};","","\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values","\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {","\t\t\t\t\tdataset.lineTension = dataset.tension;","\t\t\t\t}","","\t\t\t\t// Utility","\t\t\t\tline._scale = scale;","\t\t\t\tline._datasetIndex = me.index;","\t\t\t\t// Data","\t\t\t\tline._children = points;","\t\t\t\t// Model","\t\t\t\tline._model = {","\t\t\t\t\t// Appearance","\t\t\t\t\t// The default behavior of lines is to break at null values, according","\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158","\t\t\t\t\t// This option gives linse the ability to span gaps","\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : false,","\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),","\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),","\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),","\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),","\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),","\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),","\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),","\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),","\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),","\t\t\t\t\t// Scale","\t\t\t\t\tscaleTop: scale.top,","\t\t\t\t\tscaleBottom: scale.bottom,","\t\t\t\t\tscaleZero: scale.getBasePixel()","\t\t\t\t};","","\t\t\t\tline.pivot();","\t\t\t}","","\t\t\t// Update Points","\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {","\t\t\t\tme.updateElement(points[i], i, reset);","\t\t\t}","","\t\t\tif (showLine && line._model.tension !== 0) {","\t\t\t\tme.updateBezierControlPoints();","\t\t\t}","","\t\t\t// Now pivot the point for animation","\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {","\t\t\t\tpoints[i].pivot();","\t\t\t}","\t\t},","","\t\tgetPointBackgroundColor: function(point, index) {","\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;","\t\t\tvar dataset = this.getDataset();","\t\t\tvar custom = point.custom || {};","","\t\t\tif (custom.backgroundColor) {","\t\t\t\tbackgroundColor = custom.backgroundColor;","\t\t\t} else if (dataset.pointBackgroundColor) {","\t\t\t\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);","\t\t\t} else if (dataset.backgroundColor) {","\t\t\t\tbackgroundColor = dataset.backgroundColor;","\t\t\t}","","\t\t\treturn backgroundColor;","\t\t},","","\t\tgetPointBorderColor: function(point, index) {","\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;","\t\t\tvar dataset = this.getDataset();","\t\t\tvar custom = point.custom || {};","","\t\t\tif (custom.borderColor) {","\t\t\t\tborderColor = custom.borderColor;","\t\t\t} else if (dataset.pointBorderColor) {","\t\t\t\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);","\t\t\t} else if (dataset.borderColor) {","\t\t\t\tborderColor = dataset.borderColor;","\t\t\t}","","\t\t\treturn borderColor;","\t\t},","","\t\tgetPointBorderWidth: function(point, index) {","\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;","\t\t\tvar dataset = this.getDataset();","\t\t\tvar custom = point.custom || {};","","\t\t\tif (custom.borderWidth) {","\t\t\t\tborderWidth = custom.borderWidth;","\t\t\t} else if (dataset.pointBorderWidth) {","\t\t\t\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);","\t\t\t} else if (dataset.borderWidth) {","\t\t\t\tborderWidth = dataset.borderWidth;","\t\t\t}","","\t\t\treturn borderWidth;","\t\t},","","\t\tupdateElement: function(point, index, reset) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar custom = point.custom || {};","\t\t\tvar dataset = me.getDataset();","\t\t\tvar datasetIndex = me.index;","\t\t\tvar value = dataset.data[index];","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);","\t\t\tvar pointOptions = me.chart.options.elements.point;","\t\t\tvar x, y;","","\t\t\t// Compatibility: If the properties are defined with only the old name, use those values","\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {","\t\t\t\tdataset.pointRadius = dataset.radius;","\t\t\t}","\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {","\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;","\t\t\t}","","\t\t\tx = xScale.getPixelForValue(value, index, datasetIndex, me.chart.isCombo);","\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex, me.chart.isCombo);","","\t\t\t// Utility","\t\t\tpoint._xScale = xScale;","\t\t\tpoint._yScale = yScale;","\t\t\tpoint._datasetIndex = datasetIndex;","\t\t\tpoint._index = index;","","\t\t\t// Desired view properties","\t\t\tpoint._model = {","\t\t\t\tx: x,","\t\t\t\ty: y,","\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),","\t\t\t\t// Appearance","\t\t\t\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),","\t\t\t\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),","\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),","\t\t\t\tborderColor: me.getPointBorderColor(point, index),","\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),","\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,","\t\t\t\t// Tooltip","\t\t\t\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)","\t\t\t};","\t\t},","","\t\tcalculatePointY: function(value, index, datasetIndex, isCombo) {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart;","\t\t\tvar meta = me.getMeta();","\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);","\t\t\tvar sumPos = 0;","\t\t\tvar sumNeg = 0;","\t\t\tvar i, ds, dsMeta;","","\t\t\tif (yScale.options.stacked) {","\t\t\t\tfor (i = 0; i < datasetIndex; i++) {","\t\t\t\t\tds = chart.data.datasets[i];","\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);","\t\t\t\t\tif (dsMeta.type === 'line' && chart.isDatasetVisible(i)) {","\t\t\t\t\t\tif (ds.data[index] < 0) {","\t\t\t\t\t\t\tsumNeg += ds.data[index] || 0;","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tsumPos += ds.data[index] || 0;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tif (value < 0) {","\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + value);","\t\t\t\t} else {","\t\t\t\t\treturn yScale.getPixelForValue(sumPos + value);","\t\t\t\t}","\t\t\t}","","\t\t\treturn yScale.getPixelForValue(value);","\t\t},","","\t\tupdateBezierControlPoints: function() {","\t\t\tvar meta = this.getMeta();","\t\t\tvar area = this.chart.chartArea;","\t\t\tvar points = meta.data || [];","\t\t\tvar i, ilen, point, model, controlPoints;","","\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {","\t\t\t\tpoint = points[i];","\t\t\t\tmodel = point._model;","\t\t\t\tcontrolPoints = helpers.splineCurve(","\t\t\t\t\thelpers.previousItem(points, i)._model,","\t\t\t\t\tmodel,","\t\t\t\t\thelpers.nextItem(points, i)._model,","\t\t\t\t\tmeta.dataset._model.tension","\t\t\t\t);","","\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;","\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;","\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;","\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;","\t\t\t}","\t\t},","","\t\tdraw: function(ease) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar points = meta.data || [];","\t\t\tvar easingDecimal = ease || 1;","\t\t\tvar i, ilen;","","\t\t\t// Transition Point Locations","\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {","\t\t\t\tpoints[i].transition(easingDecimal);","\t\t\t}","","\t\t\t// Transition and Draw the line","\t\t\tif (lineEnabled(me.getDataset(), me.chart.options)) {","\t\t\t\tmeta.dataset.transition(easingDecimal).draw();","\t\t\t}","","\t\t\t// Draw the points","\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {","\t\t\t\tpoints[i].draw();","\t\t\t}","\t\t},","","\t\tsetHoverStyle: function(point) {","\t\t\t// Point","\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];","\t\t\tvar index = point._index;","\t\t\tvar custom = point.custom || {};","\t\t\tvar model = point._model;","","\t\t\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);","\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));","\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));","\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);","\t\t},","","\t\tremoveHoverStyle: function(point) {","\t\t\tvar me = this;","\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];","\t\t\tvar index = point._index;","\t\t\tvar custom = point.custom || {};","\t\t\tvar model = point._model;","","\t\t\t// Compatibility: If the properties are defined with only the old name, use those values","\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {","\t\t\t\tdataset.pointRadius = dataset.radius;","\t\t\t}","","\t\t\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);","\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);","\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);","\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);","\t\t}","\t});","};","","},{}],19:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.polarArea = {","","\t\tscale: {","\t\t\ttype: \"radialLinear\",","\t\t\tlineArc: true // so that lines are circular","\t\t},","","\t\t//Boolean - Whether to animate the rotation of the chart","\t\tanimation: {","\t\t\tanimateRotate: true,","\t\t\tanimateScale: true","\t\t},","","\t\taspectRatio: 1,","\t\tlegendCallback: function(chart) {","\t\t\tvar text = [];","\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');","","\t\t\tvar data = chart.data;","\t\t\tvar datasets = data.datasets;","\t\t\tvar labels = data.labels;","","\t\t\tif (datasets.length) {","\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {","\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\">');","\t\t\t\t\tif (labels[i]) {","\t\t\t\t\t\ttext.push(labels[i]);","\t\t\t\t\t}","\t\t\t\t\ttext.push('</span></li>');","\t\t\t\t}","\t\t\t}","","\t\t\ttext.push('</ul>');","\t\t\treturn text.join(\"\");","\t\t},","\t\tlegend: {","\t\t\tlabels: {","\t\t\t\tgenerateLabels: function(chart) {","\t\t\t\t\tvar data = chart.data;","\t\t\t\t\tif (data.labels.length && data.datasets.length) {","\t\t\t\t\t\treturn data.labels.map(function(label, i) {","\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);","\t\t\t\t\t\t\tvar ds = data.datasets[0];","\t\t\t\t\t\t\tvar arc = meta.data[i];","\t\t\t\t\t\t\tvar custom = arc.custom || {};","\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;","\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;","\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);","\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);","\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);","","\t\t\t\t\t\t\treturn {","\t\t\t\t\t\t\t\ttext: label,","\t\t\t\t\t\t\t\tfillStyle: fill,","\t\t\t\t\t\t\t\tstrokeStyle: stroke,","\t\t\t\t\t\t\t\tlineWidth: bw,","\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,","","\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item","\t\t\t\t\t\t\t\tindex: i","\t\t\t\t\t\t\t};","\t\t\t\t\t\t});","\t\t\t\t\t} else {","\t\t\t\t\t\treturn [];","\t\t\t\t\t}","\t\t\t\t}","\t\t\t},","","\t\t\tonClick: function(e, legendItem) {","\t\t\t\tvar index = legendItem.index;","\t\t\t\tvar chart = this.chart;","\t\t\t\tvar i, ilen, meta;","","\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {","\t\t\t\t\tmeta = chart.getDatasetMeta(i);","\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;","\t\t\t\t}","","\t\t\t\tchart.update();","\t\t\t}","\t\t},","","\t\t// Need to override these to give a nice default","\t\ttooltips: {","\t\t\tcallbacks: {","\t\t\t\ttitle: function() {","\t\t\t\t\treturn '';","\t\t\t\t},","\t\t\t\tlabel: function(tooltipItem, data) {","\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\tChart.controllers.polarArea = Chart.DatasetController.extend({","","\t\tdataElementType: Chart.elements.Arc,","","\t\tlinkScales: helpers.noop,","","\t\tupdate: function update(reset) {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart;","\t\t\tvar chartArea = chart.chartArea;","\t\t\tvar meta = me.getMeta();","\t\t\tvar opts = chart.options;","\t\t\tvar arcOpts = opts.elements.arc;","\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);","\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);","\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);","\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();","","\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);","\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;","","\t\t\tmeta.count = me.countVisibleElements();","","\t\t\thelpers.each(meta.data, function(arc, index) {","\t\t\t\tme.updateElement(arc, index, reset);","\t\t\t});","\t\t},","","\t\tupdateElement: function(arc, index, reset) {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart;","\t\t\tvar chartArea = chart.chartArea;","\t\t\tvar dataset = me.getDataset();","\t\t\tvar opts = chart.options;","\t\t\tvar animationOpts = opts.animation;","\t\t\tvar arcOpts = opts.elements.arc;","\t\t\tvar custom = arc.custom || {};","\t\t\tvar scale = chart.scale;","\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;","\t\t\tvar labels = chart.data.labels;","","\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);","\t\t\tvar centerX = (chartArea.left + chartArea.right) / 2;","\t\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;","","\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.","\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data","\t\t\tvar visibleCount = 0;","\t\t\tvar meta = me.getMeta();","\t\t\tfor (var i = 0; i < index; ++i) {","\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {","\t\t\t\t\t++visibleCount;","\t\t\t\t}","\t\t\t}","","\t\t\tvar negHalfPI = -0.5 * Math.PI;","\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);","\t\t\tvar startAngle = (negHalfPI) + (circumference * visibleCount);","\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);","","\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);","","\t\t\thelpers.extend(arc, {","\t\t\t\t// Utility","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t_index: index,","\t\t\t\t_scale: scale,","","\t\t\t\t// Desired view properties","\t\t\t\t_model: {","\t\t\t\t\tx: centerX,","\t\t\t\t\ty: centerY,","\t\t\t\t\tinnerRadius: 0,","\t\t\t\t\touterRadius: reset ? resetRadius : distance,","\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? negHalfPI : startAngle,","\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? negHalfPI : endAngle,","\t\t\t\t\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])","\t\t\t\t}","\t\t\t});","","\t\t\t// Apply border and fill style","\t\t\tme.removeHoverStyle(arc);","","\t\t\tarc.pivot();","\t\t},","","\t\tremoveHoverStyle: function(arc) {","\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);","\t\t},","","\t\tcountVisibleElements: function() {","\t\t\tvar dataset = this.getDataset();","\t\t\tvar meta = this.getMeta();","\t\t\tvar count = 0;","","\t\t\thelpers.each(meta.data, function(element, index) {","\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {","\t\t\t\t\tcount++;","\t\t\t\t}","\t\t\t});","","\t\t\treturn count;","\t\t},","","\t\tcalculateCircumference: function(value) {","\t\t\tvar count = this.getMeta().count;","\t\t\tif (count > 0 && !isNaN(value)) {","\t\t\t\treturn (2 * Math.PI) / count;","\t\t\t} else {","\t\t\t\treturn 0;","\t\t\t}","\t\t}","\t});","};","","},{}],20:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.radar = {","\t\tscale: {","\t\t\ttype: \"radialLinear\"","\t\t},","\t\telements: {","\t\t\tline: {","\t\t\t\ttension: 0 // no bezier in radar","\t\t\t}","\t\t}","\t};","","\tChart.controllers.radar = Chart.DatasetController.extend({","","\t\tdatasetElementType: Chart.elements.Line,","","\t\tdataElementType: Chart.elements.Point,","","\t\tlinkScales: helpers.noop,","","\t\taddElementAndReset: function(index) {","\t\t\tChart.DatasetController.prototype.addElementAndReset.call(this, index);","","\t\t\t// Make sure bezier control points are updated","\t\t\tthis.updateBezierControlPoints();","\t\t},","","\t\tupdate: function update(reset) {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar line = meta.dataset;","\t\t\tvar points = meta.data;","\t\t\tvar custom = line.custom || {};","\t\t\tvar dataset = me.getDataset();","\t\t\tvar lineElementOptions = me.chart.options.elements.line;","\t\t\tvar scale = me.chart.scale;","","\t\t\t// Compatibility: If the properties are defined with only the old name, use those values","\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {","\t\t\t\tdataset.lineTension = dataset.tension;","\t\t\t}","","\t\t\thelpers.extend(meta.dataset, {","\t\t\t\t// Utility","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t// Data","\t\t\t\t_children: points,","\t\t\t\t_loop: true,","\t\t\t\t// Model","\t\t\t\t_model: {","\t\t\t\t\t// Appearance","\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),","\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),","\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),","\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),","\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),","\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),","\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),","\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),","\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),","","\t\t\t\t\t// Scale","\t\t\t\t\tscaleTop: scale.top,","\t\t\t\t\tscaleBottom: scale.bottom,","\t\t\t\t\tscaleZero: scale.getBasePosition()","\t\t\t\t}","\t\t\t});","","\t\t\tmeta.dataset.pivot();","","\t\t\t// Update Points","\t\t\thelpers.each(points, function(point, index) {","\t\t\t\tme.updateElement(point, index, reset);","\t\t\t}, me);","","","\t\t\t// Update bezier control points","\t\t\tme.updateBezierControlPoints();","\t\t},","\t\tupdateElement: function(point, index, reset) {","\t\t\tvar me = this;","\t\t\tvar custom = point.custom || {};","\t\t\tvar dataset = me.getDataset();","\t\t\tvar scale = me.chart.scale;","\t\t\tvar pointElementOptions = me.chart.options.elements.point;","\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);","","\t\t\thelpers.extend(point, {","\t\t\t\t// Utility","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t_index: index,","\t\t\t\t_scale: scale,","","\t\t\t\t// Desired view properties","\t\t\t\t_model: {","\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales","\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,","","\t\t\t\t\t// Appearance","\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.tension, me.chart.options.elements.line.tension),","\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),","\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),","\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),","\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),","\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),","","\t\t\t\t\t// Tooltip","\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)","\t\t\t\t}","\t\t\t});","","\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));","\t\t},","\t\tupdateBezierControlPoints: function() {","\t\t\tvar chartArea = this.chart.chartArea;","\t\t\tvar meta = this.getMeta();","","\t\t\thelpers.each(meta.data, function(point, index) {","\t\t\t\tvar model = point._model;","\t\t\t\tvar controlPoints = helpers.splineCurve(","\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,","\t\t\t\t\tmodel,","\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,","\t\t\t\t\tmodel.tension","\t\t\t\t);","","\t\t\t\t// Prevent the bezier going outside of the bounds of the graph","\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);","\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);","","\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);","\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);","","\t\t\t\t// Now pivot the point for animation","\t\t\t\tpoint.pivot();","\t\t\t});","\t\t},","","\t\tdraw: function(ease) {","\t\t\tvar meta = this.getMeta();","\t\t\tvar easingDecimal = ease || 1;","","\t\t\t// Transition Point Locations","\t\t\thelpers.each(meta.data, function(point, index) {","\t\t\t\tpoint.transition(easingDecimal);","\t\t\t});","","\t\t\t// Transition and Draw the line","\t\t\tmeta.dataset.transition(easingDecimal).draw();","","\t\t\t// Draw the points","\t\t\thelpers.each(meta.data, function(point) {","\t\t\t\tpoint.draw();","\t\t\t});","\t\t},","","\t\tsetHoverStyle: function(point) {","\t\t\t// Point","\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];","\t\t\tvar custom = point.custom || {};","\t\t\tvar index = point._index;","\t\t\tvar model = point._model;","","\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);","\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));","\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));","\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);","\t\t},","","\t\tremoveHoverStyle: function(point) {","\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];","\t\t\tvar custom = point.custom || {};","\t\t\tvar index = point._index;","\t\t\tvar model = point._model;","\t\t\tvar pointElementOptions = this.chart.options.elements.point;","","\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);","\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);","\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);","\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);","\t\t}","\t});","};","","},{}],21:[function(require,module,exports){","/*global window: false */","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.global.animation = {","\t\tduration: 1000,","\t\teasing: \"easeOutQuart\",","\t\tonProgress: helpers.noop,","\t\tonComplete: helpers.noop","\t};","","\tChart.Animation = Chart.Element.extend({","\t\tcurrentStep: null, // the current animation step","\t\tnumSteps: 60, // default number of steps","\t\teasing: \"\", // the easing to use for this animation","\t\trender: null, // render function used by the animation service","","\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation","\t\tonAnimationComplete: null // user specified callback to fire when the animation finishes","\t});","","\tChart.animationService = {","\t\tframeDuration: 17,","\t\tanimations: [],","\t\tdropFrames: 0,","\t\trequest: null,","\t\taddAnimation: function(chartInstance, animationObject, duration, lazy) {","\t\t\tvar me = this;","","\t\t\tif (!lazy) {","\t\t\t\tchartInstance.animating = true;","\t\t\t}","","\t\t\tfor (var index = 0; index < me.animations.length; ++index) {","\t\t\t\tif (me.animations[index].chartInstance === chartInstance) {","\t\t\t\t\t// replacing an in progress animation","\t\t\t\t\tme.animations[index].animationObject = animationObject;","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t}","","\t\t\tme.animations.push({","\t\t\t\tchartInstance: chartInstance,","\t\t\t\tanimationObject: animationObject","\t\t\t});","","\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word","\t\t\tif (me.animations.length === 1) {","\t\t\t\tme.requestAnimationFrame();","\t\t\t}","\t\t},","\t\t// Cancel the animation for a given chart instance","\t\tcancelAnimation: function(chartInstance) {","\t\t\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {","\t\t\t\treturn animationWrapper.chartInstance === chartInstance;","\t\t\t});","","\t\t\tif (index !== -1) {","\t\t\t\tthis.animations.splice(index, 1);","\t\t\t\tchartInstance.animating = false;","\t\t\t}","\t\t},","\t\trequestAnimationFrame: function() {","\t\t\tvar me = this;","\t\t\tif (me.request === null) {","\t\t\t\t// Skip animation frame requests until the active one is executed.","\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'","\t\t\t\t// and 'mouseout' events will trigger multiple renders.","\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {","\t\t\t\t\tme.request = null;","\t\t\t\t\tme.startDigest();","\t\t\t\t});","\t\t\t}","\t\t},","\t\tstartDigest: function() {","\t\t\tvar me = this;","","\t\t\tvar startTime = Date.now();","\t\t\tvar framesToDrop = 0;","","\t\t\tif (me.dropFrames > 1) {","\t\t\t\tframesToDrop = Math.floor(me.dropFrames);","\t\t\t\tme.dropFrames = me.dropFrames % 1;","\t\t\t}","","\t\t\tvar i = 0;","\t\t\twhile (i < me.animations.length) {","\t\t\t\tif (me.animations[i].animationObject.currentStep === null) {","\t\t\t\t\tme.animations[i].animationObject.currentStep = 0;","\t\t\t\t}","","\t\t\t\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;","","\t\t\t\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {","\t\t\t\t\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;","\t\t\t\t}","","\t\t\t\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);","\t\t\t\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {","\t\t\t\t\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);","\t\t\t\t}","","\t\t\t\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {","\t\t\t\t\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {","\t\t\t\t\t\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);","\t\t\t\t\t}","","\t\t\t\t\t// executed the last frame. Remove the animation.","\t\t\t\t\tme.animations[i].chartInstance.animating = false;","","\t\t\t\t\tme.animations.splice(i, 1);","\t\t\t\t} else {","\t\t\t\t\t++i;","\t\t\t\t}","\t\t\t}","","\t\t\tvar endTime = Date.now();","\t\t\tvar dropFrames = (endTime - startTime) / me.frameDuration;","","\t\t\tme.dropFrames += dropFrames;","","\t\t\t// Do we have more stuff to animate?","\t\t\tif (me.animations.length > 0) {","\t\t\t\tme.requestAnimationFrame();","\t\t\t}","\t\t}","\t};","};","},{}],22:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\t//Create a dictionary of chart types, to allow for extension of existing types","\tChart.types = {};","","\t//Store a reference to each instance - allowing us to globally resize chart instances on window resize.","\t//Destroy method on the chart will remove the instance of the chart from this reference.","\tChart.instances = {};","","\t// Controllers available for dataset visualization eg. bar, line, slice, etc.","\tChart.controllers = {};","","\t/**","\t * @class Chart.Controller","\t * The main controller of a chart.","\t */","\tChart.Controller = function(instance) {","","\t\tthis.chart = instance;","\t\tthis.config = instance.config;","\t\tthis.options = this.config.options = helpers.configMerge(Chart.defaults.global, Chart.defaults[this.config.type], this.config.options || {});","\t\tthis.id = helpers.uid();","","\t\tObject.defineProperty(this, 'data', {","\t\t\tget: function() {","\t\t\t\treturn this.config.data;","\t\t\t}","\t\t});","","\t\t//Add the chart instance to the global namespace","\t\tChart.instances[this.id] = this;","","\t\tif (this.options.responsive) {","\t\t\t// Silent resize before chart draws","\t\t\tthis.resize(true);","\t\t}","","\t\tthis.initialize();","","\t\treturn this;","\t};","","\thelpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller */ {","","\t\tinitialize: function initialize() {","\t\t\tvar me = this;","\t\t\t// Before init plugin notification","\t\t\tChart.plugins.notify('beforeInit', [me]);","","\t\t\tme.bindEvents();","","\t\t\t// Make sure controllers are built first so that each dataset is bound to an axis before the scales","\t\t\t// are built","\t\t\tme.ensureScalesHaveIDs();","\t\t\tme.buildOrUpdateControllers();","\t\t\tme.buildScales();","\t\t\tme.updateLayout();","\t\t\tme.resetElements();","\t\t\tme.initToolTip();","\t\t\tme.update();","","\t\t\t// After init plugin notification","\t\t\tChart.plugins.notify('afterInit', [me]);","","\t\t\treturn me;","\t\t},","","\t\tclear: function clear() {","\t\t\thelpers.clear(this.chart);","\t\t\treturn this;","\t\t},","","\t\tstop: function stop() {","\t\t\t// Stops any current animation loop occuring","\t\t\tChart.animationService.cancelAnimation(this);","\t\t\treturn this;","\t\t},","","\t\tresize: function resize(silent) {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart;","\t\t\tvar canvas = chart.canvas;","\t\t\tvar newWidth = helpers.getMaximumWidth(canvas);","\t\t\tvar aspectRatio = chart.aspectRatio;","\t\t\tvar newHeight = (me.options.maintainAspectRatio && isNaN(aspectRatio) === false && isFinite(aspectRatio) && aspectRatio !== 0) ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas);","","\t\t\tvar sizeChanged = chart.width !== newWidth || chart.height !== newHeight;","","\t\t\tif (!sizeChanged) {","\t\t\t\treturn me;","\t\t\t}","","\t\t\tcanvas.width = chart.width = newWidth;","\t\t\tcanvas.height = chart.height = newHeight;","","\t\t\thelpers.retinaScale(chart);","","\t\t\t// Notify any plugins about the resize","\t\t\tvar newSize = { width: newWidth, height: newHeight };","\t\t\tChart.plugins.notify('resize', [me, newSize]);","","\t\t\t// Notify of resize","\t\t\tif (me.options.onResize) {","\t\t\t\tme.options.onResize(me, newSize);","\t\t\t}","","\t\t\tif (!silent) {","\t\t\t\tme.stop();","\t\t\t\tme.update(me.options.responsiveAnimationDuration);","\t\t\t}","","\t\t\treturn me;","\t\t},","","\t\tensureScalesHaveIDs: function ensureScalesHaveIDs() {","\t\t\tvar options = this.options;","\t\t\tvar scalesOptions = options.scales || {};","\t\t\tvar scaleOptions = options.scale;","","\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {","\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);","\t\t\t});","","\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {","\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);","\t\t\t});","","\t\t\tif (scaleOptions) {","\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';","\t\t\t}","\t\t},","","\t\t/**","\t\t * Builds a map of scale ID to scale object for future lookup.","\t\t */","\t\tbuildScales: function buildScales() {","\t\t\tvar me = this;","\t\t\tvar options = me.options;","\t\t\tvar scales = me.scales = {};","\t\t\tvar items = [];","","\t\t\tif (options.scales) {","\t\t\t\titems = items.concat(","\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {","\t\t\t\t\t\treturn { options: xAxisOptions, dtype: 'category' }; }),","\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {","\t\t\t\t\t\treturn { options: yAxisOptions, dtype: 'linear' }; }));","\t\t\t}","","\t\t\tif (options.scale) {","\t\t\t\titems.push({ options: options.scale, dtype: 'radialLinear', isDefault: true });","\t\t\t}","","\t\t\thelpers.each(items, function(item, index) {","\t\t\t\tvar scaleOptions = item.options;","\t\t\t\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);","\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);","\t\t\t\tif (!scaleClass) {","\t\t\t\t\treturn;","\t\t\t\t}","","\t\t\t\tvar scale = new scaleClass({","\t\t\t\t\tid: scaleOptions.id,","\t\t\t\t\toptions: scaleOptions,","\t\t\t\t\tctx: me.chart.ctx,","\t\t\t\t\tchart: me","\t\t\t\t});","","\t\t\t\tscales[scale.id] = scale;","","\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)","\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would","\t\t\t\t// make the logic easier and remove some useless? custom code.","\t\t\t\tif (item.isDefault) {","\t\t\t\t\tme.scale = scale;","\t\t\t\t}","\t\t\t});","","\t\t\tChart.scaleService.addScalesToLayout(this);","\t\t},","","\t\tupdateLayout: function() {","\t\t\tChart.layoutService.update(this, this.chart.width, this.chart.height);","\t\t},","","\t\tbuildOrUpdateControllers: function buildOrUpdateControllers() {","\t\t\tvar me = this;","\t\t\tvar types = [];","\t\t\tvar newControllers = [];","","\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);","\t\t\t\tif (!meta.type) {","\t\t\t\t\tmeta.type = dataset.type || me.config.type;","\t\t\t\t}","","\t\t\t\ttypes.push(meta.type);","","\t\t\t\tif (meta.controller) {","\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);","\t\t\t\t} else {","\t\t\t\t\tmeta.controller = new Chart.controllers[meta.type](me, datasetIndex);","\t\t\t\t\tnewControllers.push(meta.controller);","\t\t\t\t}","\t\t\t}, me);","","\t\t\tif (types.length > 1) {","\t\t\t\tfor (var i = 1; i < types.length; i++) {","\t\t\t\t\tif (types[i] !== types[i - 1]) {","\t\t\t\t\t\tme.isCombo = true;","\t\t\t\t\t\tbreak;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\treturn newControllers;","\t\t},","","\t\tresetElements: function resetElements() {","\t\t\tvar me = this;","\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();","\t\t\t}, me);","\t\t},","","\t\tupdate: function update(animationDuration, lazy) {","\t\t\tvar me = this;","\t\t\tChart.plugins.notify('beforeUpdate', [me]);","","\t\t\t// In case the entire data object changed","\t\t\tme.tooltip._data = me.data;","","\t\t\t// Make sure dataset controllers are updated and new controllers are reset","\t\t\tvar newControllers = me.buildOrUpdateControllers();","","\t\t\t// Make sure all dataset controllers have correct meta data counts","\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();","\t\t\t}, me);","","\t\t\tChart.layoutService.update(me, me.chart.width, me.chart.height);","","\t\t\t// Apply changes to the dataets that require the scales to have been calculated i.e BorderColor chages","\t\t\tChart.plugins.notify('afterScaleUpdate', [me]);","","\t\t\t// Can only reset the new controllers after the scales have been updated","\t\t\thelpers.each(newControllers, function(controller) {","\t\t\t\tcontroller.reset();","\t\t\t});","","\t\t\tme.updateDatasets();","","\t\t\t// Do this before render so that any plugins that need final scale updates can use it","\t\t\tChart.plugins.notify('afterUpdate', [me]);","","\t\t\tme.render(animationDuration, lazy);","\t\t},","","\t\t/**","\t\t * @method beforeDatasetsUpdate","\t\t * @description Called before all datasets are updated. If a plugin returns false,","\t\t * the datasets update will be cancelled until another chart update is triggered.","\t\t * @param {Object} instance the chart instance being updated.","\t\t * @returns {Boolean} false to cancel the datasets update.","\t\t * @memberof Chart.PluginBase","\t\t * @since version 2.1.5","\t\t * @instance","\t\t */","","\t\t/**","\t\t * @method afterDatasetsUpdate","\t\t * @description Called after all datasets have been updated. Note that this","\t\t * extension will not be called if the datasets update has been cancelled.","\t\t * @param {Object} instance the chart instance being updated.","\t\t * @memberof Chart.PluginBase","\t\t * @since version 2.1.5","\t\t * @instance","\t\t */","","\t\t/**","\t\t * Updates all datasets unless a plugin returns false to the beforeDatasetsUpdate","\t\t * extension, in which case no datasets will be updated and the afterDatasetsUpdate","\t\t * notification will be skipped.","\t\t * @protected","\t\t * @instance","\t\t */","\t\tupdateDatasets: function() {","\t\t\tvar me = this;","\t\t\tvar i, ilen;","","\t\t\tif (Chart.plugins.notify('beforeDatasetsUpdate', [ me ])) {","\t\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {","\t\t\t\t\tme.getDatasetMeta(i).controller.update();","\t\t\t\t}","","\t\t\t\tChart.plugins.notify('afterDatasetsUpdate', [ me ]);","\t\t\t}","\t\t},","","\t\trender: function render(duration, lazy) {","\t\t\tvar me = this;","\t\t\tChart.plugins.notify('beforeRender', [me]);","","\t\t\tvar animationOptions = me.options.animation;","\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {","\t\t\t\tvar animation = new Chart.Animation();","\t\t\t\tanimation.numSteps = (duration || animationOptions.duration) / 16.66; //60 fps","\t\t\t\tanimation.easing = animationOptions.easing;","","\t\t\t\t// render function","\t\t\t\tanimation.render = function(chartInstance, animationObject) {","\t\t\t\t\tvar easingFunction = helpers.easingEffects[animationObject.easing];","\t\t\t\t\tvar stepDecimal = animationObject.currentStep / animationObject.numSteps;","\t\t\t\t\tvar easeDecimal = easingFunction(stepDecimal);","","\t\t\t\t\tchartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);","\t\t\t\t};","","\t\t\t\t// user events","\t\t\t\tanimation.onAnimationProgress = animationOptions.onProgress;","\t\t\t\tanimation.onAnimationComplete = animationOptions.onComplete;","","\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);","\t\t\t} else {","\t\t\t\tme.draw();","\t\t\t\tif (animationOptions && animationOptions.onComplete && animationOptions.onComplete.call) {","\t\t\t\t\tanimationOptions.onComplete.call(me);","\t\t\t\t}","\t\t\t}","\t\t\treturn me;","\t\t},","","\t\tdraw: function(ease) {","\t\t\tvar me = this;","\t\t\tvar easingDecimal = ease || 1;","\t\t\tme.clear();","","\t\t\tChart.plugins.notify('beforeDraw', [me, easingDecimal]);","","\t\t\t// Draw all the scales","\t\t\thelpers.each(me.boxes, function(box) {","\t\t\t\tbox.draw(me.chartArea);","\t\t\t}, me);","\t\t\tif (me.scale) {","\t\t\t\tme.scale.draw();","\t\t\t}","","\t\t\tChart.plugins.notify('beforeDatasetsDraw', [me, easingDecimal]);","","\t\t\t// Draw each dataset via its respective controller (reversed to support proper line stacking)","\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {","\t\t\t\t\tme.getDatasetMeta(datasetIndex).controller.draw(ease);","\t\t\t\t}","\t\t\t}, me, true);","","\t\t\tChart.plugins.notify('afterDatasetsDraw', [me, easingDecimal]);","","\t\t\t// Finally draw the tooltip","\t\t\tme.tooltip.transition(easingDecimal).draw();","","\t\t\tChart.plugins.notify('afterDraw', [me, easingDecimal]);","\t\t},","","\t\t// Get the single element that was clicked on","\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw","\t\tgetElementAtEvent: function(e) {","\t\t\tvar me = this;","\t\t\tvar eventPosition = helpers.getRelativePosition(e, me.chart);","\t\t\tvar elementsArray = [];","","\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {","\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);","\t\t\t\t\thelpers.each(meta.data, function(element, index) {","\t\t\t\t\t\tif (element.inRange(eventPosition.x, eventPosition.y)) {","\t\t\t\t\t\t\telementsArray.push(element);","\t\t\t\t\t\t\treturn elementsArray;","\t\t\t\t\t\t}","\t\t\t\t\t});","\t\t\t\t}","\t\t\t});","","\t\t\treturn elementsArray;","\t\t},","","\t\tgetElementsAtEvent: function(e) {","\t\t\tvar me = this;","\t\t\tvar eventPosition = helpers.getRelativePosition(e, me.chart);","\t\t\tvar elementsArray = [];","","\t\t\tvar found = (function() {","\t\t\t\tif (me.data.datasets) {","\t\t\t\t\tfor (var i = 0; i < me.data.datasets.length; i++) {","\t\t\t\t\t\tvar meta = me.getDatasetMeta(i);","\t\t\t\t\t\tif (me.isDatasetVisible(i)) {","\t\t\t\t\t\t\tfor (var j = 0; j < meta.data.length; j++) {","\t\t\t\t\t\t\t\tif (meta.data[j].inRange(eventPosition.x, eventPosition.y)) {","\t\t\t\t\t\t\t\t\treturn meta.data[j];","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}).call(me);","","\t\t\tif (!found) {","\t\t\t\treturn elementsArray;","\t\t\t}","","\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tif (me.isDatasetVisible(datasetIndex)) {","\t\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);","\t\t\t\t\telementsArray.push(meta.data[found._index]);","\t\t\t\t}","\t\t\t}, me);","","\t\t\treturn elementsArray;","\t\t},","","\t\tgetElementsAtEventForMode: function(e, mode) {","\t\t\tvar me = this;","\t\t\tswitch (mode) {","\t\t\tcase 'single':","\t\t\t\treturn me.getElementAtEvent(e);","\t\t\tcase 'label':","\t\t\t\treturn me.getElementsAtEvent(e);","\t\t\tcase 'dataset':","\t\t\t\treturn me.getDatasetAtEvent(e);","\t\t\tdefault:","\t\t\t\treturn e;","\t\t\t}","\t\t},","","\t\tgetDatasetAtEvent: function(e) {","\t\t\tvar elementsArray = this.getElementAtEvent(e);","","\t\t\tif (elementsArray.length > 0) {","\t\t\t\telementsArray = this.getDatasetMeta(elementsArray[0]._datasetIndex).data;","\t\t\t}","","\t\t\treturn elementsArray;","\t\t},","","\t\tgetDatasetMeta: function(datasetIndex) {","\t\t\tvar me = this;","\t\t\tvar dataset = me.data.datasets[datasetIndex];","\t\t\tif (!dataset._meta) {","\t\t\t\tdataset._meta = {};","\t\t\t}","","\t\t\tvar meta = dataset._meta[me.id];","\t\t\tif (!meta) {","\t\t\t\tmeta = dataset._meta[me.id] = {","\t\t\t\ttype: null,","\t\t\t\tdata: [],","\t\t\t\tdataset: null,","\t\t\t\tcontroller: null,","\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment","\t\t\t\txAxisID: null,","\t\t\t\tyAxisID: null","\t\t\t};","\t\t\t}","","\t\t\treturn meta;","\t\t},","","\t\tgetVisibleDatasetCount: function() {","\t\t\tvar count = 0;","\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {","\t\t\t\t if (this.isDatasetVisible(i)) {","\t\t\t\t\tcount++;","\t\t\t\t}","\t\t\t}","\t\t\treturn count;","\t\t},","","\t\tisDatasetVisible: function(datasetIndex) {","\t\t\tvar meta = this.getDatasetMeta(datasetIndex);","","\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,","\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.","\t\t\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;","\t\t},","","\t\tgenerateLegend: function generateLegend() {","\t\t\treturn this.options.legendCallback(this);","\t\t},","","\t\tdestroy: function destroy() {","\t\t\tvar me = this;","\t\t\tme.stop();","\t\t\tme.clear();","\t\t\thelpers.unbindEvents(me, me.events);","\t\t\thelpers.removeResizeListener(me.chart.canvas.parentNode);","","\t\t\t// Reset canvas height/width attributes","\t\t\tvar canvas = me.chart.canvas;","\t\t\tcanvas.width = me.chart.width;","\t\t\tcanvas.height = me.chart.height;","","\t\t\t// if we scaled the canvas in response to a devicePixelRatio !== 1, we need to undo that transform here","\t\t\tif (me.chart.originalDevicePixelRatio !== undefined) {","\t\t\t\tme.chart.ctx.scale(1 / me.chart.originalDevicePixelRatio, 1 / me.chart.originalDevicePixelRatio);","\t\t\t}","","\t\t\t// Reset to the old style since it may have been changed by the device pixel ratio changes","\t\t\tcanvas.style.width = me.chart.originalCanvasStyleWidth;","\t\t\tcanvas.style.height = me.chart.originalCanvasStyleHeight;","","\t\t\tChart.plugins.notify('destroy', [me]);","","\t\t\tdelete Chart.instances[me.id];","\t\t},","","\t\ttoBase64Image: function toBase64Image() {","\t\t\treturn this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);","\t\t},","","\t\tinitToolTip: function initToolTip() {","\t\t\tvar me = this;","\t\t\tme.tooltip = new Chart.Tooltip({","\t\t\t\t_chart: me.chart,","\t\t\t\t_chartInstance: me,","\t\t\t\t_data: me.data,","\t\t\t\t_options: me.options.tooltips","\t\t\t}, me);","\t\t},","","\t\tbindEvents: function bindEvents() {","\t\t\tvar me = this;","\t\t\thelpers.bindEvents(me, me.options.events, function(evt) {","\t\t\t\tme.eventHandler(evt);","\t\t\t});","\t\t},","","\t\tupdateHoverStyle: function(elements, mode, enabled) {","\t\t\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';","\t\t\tvar element, i, ilen;","","\t\t\tswitch (mode) {","\t\t\tcase 'single':","\t\t\t\telements = [ elements[0] ];","\t\t\t\tbreak;","\t\t\tcase 'label':","\t\t\tcase 'dataset':","\t\t\t\t// elements = elements;","\t\t\t\tbreak;","\t\t\tdefault:","\t\t\t\t// unsupported mode","\t\t\t\treturn;","\t\t\t}","","\t\t\tfor (i=0, ilen=elements.length; i<ilen; ++i) {","\t\t\t\telement = elements[i];","\t\t\t\tif (element) {","\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);","\t\t\t\t}","\t\t\t}","\t\t},","","\t\teventHandler: function eventHandler(e) {","\t\t\tvar me = this;","\t\t\tvar tooltip = me.tooltip;","\t\t\tvar options = me.options || {};","\t\t\tvar hoverOptions = options.hover;","\t\t\tvar tooltipsOptions = options.tooltips;","","\t\t\tme.lastActive = me.lastActive || [];","\t\t\tme.lastTooltipActive = me.lastTooltipActive || [];","","\t\t\t// Find Active Elements for hover and tooltips","\t\t\tif (e.type === 'mouseout') {","\t\t\t\tme.active = [];","\t\t\t\tme.tooltipActive = [];","\t\t\t} else {","\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode);","\t\t\t\tme.tooltipActive =  me.getElementsAtEventForMode(e, tooltipsOptions.mode);","\t\t\t}","","\t\t\t// On Hover hook","\t\t\tif (hoverOptions.onHover) {","\t\t\t\thoverOptions.onHover.call(me, me.active);","\t\t\t}","","\t\t\tif (e.type === 'mouseup' || e.type === 'click') {","\t\t\t\tif (options.onClick) {","\t\t\t\t\toptions.onClick.call(me, e, me.active);","\t\t\t\t}","\t\t\t\tif (me.legend && me.legend.handleEvent) {","\t\t\t\t\tme.legend.handleEvent(e);","\t\t\t\t}","\t\t\t}","","\t\t\t// Remove styling for last active (even if it may still be active)","\t\t\tif (me.lastActive.length) {","\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);","\t\t\t}","","\t\t\t// Built in hover styling","\t\t\tif (me.active.length && hoverOptions.mode) {","\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);","\t\t\t}","","\t\t\t// Built in Tooltips","\t\t\tif (tooltipsOptions.enabled || tooltipsOptions.custom) {","\t\t\t\ttooltip.initialize();","\t\t\t\ttooltip._active = me.tooltipActive;","\t\t\t\ttooltip.update(true);","\t\t\t}","","\t\t\t// Hover animations","\t\t\ttooltip.pivot();","","\t\t\tif (!me.animating) {","\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot","\t\t\t\tif (!helpers.arrayEquals(me.active, me.lastActive) ||","\t\t\t\t\t!helpers.arrayEquals(me.tooltipActive, me.lastTooltipActive)) {","","\t\t\t\t\tme.stop();","","\t\t\t\t\tif (tooltipsOptions.enabled || tooltipsOptions.custom) {","\t\t\t\t\t\ttooltip.update(true);","\t\t\t\t\t}","","\t\t\t\t\t// We only need to render at this point. Updating will cause scales to be","\t\t\t\t\t// recomputed generating flicker & using more memory than necessary.","\t\t\t\t\tme.render(hoverOptions.animationDuration, true);","\t\t\t\t}","\t\t\t}","","\t\t\t// Remember Last Actives","\t\t\tme.lastActive = me.active;","\t\t\tme.lastTooltipActive = me.tooltipActive;","\t\t\treturn me;","\t\t}","\t});","};","","},{}],23:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\tvar noop = helpers.noop;","","\t// Base class for all dataset controllers (line, bar, etc)","\tChart.DatasetController = function(chart, datasetIndex) {","\t\tthis.initialize.call(this, chart, datasetIndex);","\t};","","\thelpers.extend(Chart.DatasetController.prototype, {","","\t\t/**","\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).","\t\t * @type {Chart.core.element}","\t\t */","\t\tdatasetElementType: null,","","\t\t/**","\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).","\t\t * @type {Chart.core.element}","\t\t */","\t\tdataElementType: null,","","\t\tinitialize: function(chart, datasetIndex) {","\t\t\tvar me = this;","\t\t\tme.chart = chart;","\t\t\tme.index = datasetIndex;","\t\t\tme.linkScales();","\t\t\tme.addElements();","\t\t},","","\t\tupdateIndex: function(datasetIndex) {","\t\t\tthis.index = datasetIndex;","\t\t},","","\t\tlinkScales: function() {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar dataset = me.getDataset();","","\t\t\tif (meta.xAxisID === null) {","\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;","\t\t\t}","\t\t\tif (meta.yAxisID === null) {","\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;","\t\t\t}","\t\t},","","\t\tgetDataset: function() {","\t\t\treturn this.chart.data.datasets[this.index];","\t\t},","","\t\tgetMeta: function() {","\t\t\treturn this.chart.getDatasetMeta(this.index);","\t\t},","","\t\tgetScaleForId: function(scaleID) {","\t\t\treturn this.chart.scales[scaleID];","\t\t},","","\t\treset: function() {","\t\t\tthis.update(true);","\t\t},","","\t\tcreateMetaDataset: function() {","\t\t\tvar me = this;","\t\t\tvar type = me.datasetElementType;","\t\t\treturn type && new type({","\t\t\t\t_chart: me.chart.chart,","\t\t\t\t_datasetIndex: me.index","\t\t\t});","\t\t},","","\t\tcreateMetaData: function(index) {","\t\t\tvar me = this;","\t\t\tvar type = me.dataElementType;","\t\t\treturn type && new type({","\t\t\t\t_chart: me.chart.chart,","\t\t\t\t_datasetIndex: me.index,","\t\t\t\t_index: index","\t\t\t});","\t\t},","","\t\taddElements: function() {","\t\t\tvar me = this;","\t\t\tvar meta = me.getMeta();","\t\t\tvar data = me.getDataset().data || [];","\t\t\tvar metaData = meta.data;","\t\t\tvar i, ilen;","","\t\t\tfor (i=0, ilen=data.length; i<ilen; ++i) {","\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(meta, i);","\t\t\t}","","\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();","\t\t},","","\t\taddElementAndReset: function(index) {","\t\t\tvar me = this;","\t\t\tvar element = me.createMetaData(index);","\t\t\tme.getMeta().data.splice(index, 0, element);","\t\t\tme.updateElement(element, index, true);","\t\t},","","\t\tbuildOrUpdateElements: function buildOrUpdateElements() {","\t\t\t// Handle the number of data points changing","\t\t\tvar meta = this.getMeta(),","\t\t\t\tmd = meta.data,","\t\t\t\tnumData = this.getDataset().data.length,","\t\t\t\tnumMetaData = md.length;","","\t\t\t// Make sure that we handle number of datapoints changing","\t\t\tif (numData < numMetaData) {","\t\t\t\t// Remove excess bars for data points that have been removed","\t\t\t\tmd.splice(numData, numMetaData - numData);","\t\t\t} else if (numData > numMetaData) {","\t\t\t\t// Add new elements","\t\t\t\tfor (var index = numMetaData; index < numData; ++index) {","\t\t\t\t\tthis.addElementAndReset(index);","\t\t\t\t}","\t\t\t}","\t\t},","","\t\tupdate: noop,","","\t\tdraw: function(ease) {","\t\t\tvar easingDecimal = ease || 1;","\t\t\thelpers.each(this.getMeta().data, function(element, index) {","\t\t\t\telement.transition(easingDecimal).draw();","\t\t\t});","\t\t},","","\t\tremoveHoverStyle: function(element, elementOpts) {","\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],","\t\t\t\tindex = element._index,","\t\t\t\tcustom = element.custom || {},","\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,","\t\t\t\tcolor = helpers.color,","\t\t\t\tmodel = element._model;","","\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);","\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);","\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);","\t\t},","","\t\tsetHoverStyle: function(element) {","\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],","\t\t\t\tindex = element._index,","\t\t\t\tcustom = element.custom || {},","\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,","\t\t\t\tcolor = helpers.color,","\t\t\t\tgetHoverColor = helpers.getHoverColor,","\t\t\t\tmodel = element._model;","","\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));","\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));","\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);","\t\t}","\t});","","\tChart.DatasetController.extend = helpers.inherits;","};","},{}],24:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","  var helpers = Chart.helpers;","","  Chart.elements = {};","","  Chart.Element = function(configuration) {","    helpers.extend(this, configuration);","    this.initialize.apply(this, arguments);","  };","","  helpers.extend(Chart.Element.prototype, {","","    initialize: function() {","      this.hidden = false;","    },","","    pivot: function() {","      var me = this;","      if (!me._view) {","        me._view = helpers.clone(me._model);","      }","      me._start = helpers.clone(me._view);","      return me;","    },","","    transition: function(ease) {","      var me = this;","      ","      if (!me._view) {","        me._view = helpers.clone(me._model);","      }","","      // No animation -> No Transition","      if (ease === 1) {","        me._view = me._model;","        me._start = null;","        return me;","      }","","      if (!me._start) {","        me.pivot();","      }","","      helpers.each(me._model, function(value, key) {","","        if (key[0] === '_') {","          // Only non-underscored properties","        }","","        // Init if doesn't exist","        else if (!me._view.hasOwnProperty(key)) {","          if (typeof value === 'number' && !isNaN(me._view[key])) {","            me._view[key] = value * ease;","          } else {","            me._view[key] = value;","          }","        }","","        // No unnecessary computations","        else if (value === me._view[key]) {","          // It's the same! Woohoo!","        }","","        // Color transitions if possible","        else if (typeof value === 'string') {","          try {","            var color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);","            me._view[key] = color.rgbString();","          } catch (err) {","            me._view[key] = value;","          }","        }","        // Number transitions","        else if (typeof value === 'number') {","          var startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;","          me._view[key] = ((me._model[key] - startVal) * ease) + startVal;","        }","        // Everything else","        else {","          me._view[key] = value;","        }","      }, me);","","      return me;","    },","","    tooltipPosition: function() {","      return {","        x: this._model.x,","        y: this._model.y","      };","    },","","    hasValue: function() {","      return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);","    }","  });","","  Chart.Element.extend = helpers.inherits;","","};","","},{}],25:[function(require,module,exports){","/*global window: false */","/*global document: false */","\"use strict\";","","var color = require(2);","","module.exports = function(Chart) {","\t//Global Chart helpers object for utility methods and classes","\tvar helpers = Chart.helpers = {};","","\t//-- Basic js utility methods","\thelpers.each = function(loopable, callback, self, reverse) {","\t\t// Check to see if null or undefined firstly.","\t\tvar i, len;","\t\tif (helpers.isArray(loopable)) {","\t\t\tlen = loopable.length;","\t\t\tif (reverse) {","\t\t\t\tfor (i = len - 1; i >= 0; i--) {","\t\t\t\t\tcallback.call(self, loopable[i], i);","\t\t\t\t}","\t\t\t} else {","\t\t\t\tfor (i = 0; i < len; i++) {","\t\t\t\t\tcallback.call(self, loopable[i], i);","\t\t\t\t}","\t\t\t}","\t\t} else if (typeof loopable === 'object') {","\t\t\tvar keys = Object.keys(loopable);","\t\t\tlen = keys.length;","\t\t\tfor (i = 0; i < len; i++) {","\t\t\t\tcallback.call(self, loopable[keys[i]], keys[i]);","\t\t\t}","\t\t}","\t};","\thelpers.clone = function(obj) {","\t\tvar objClone = {};","\t\thelpers.each(obj, function(value, key) {","\t\t\tif (helpers.isArray(value)) {","\t\t\t\tobjClone[key] = value.slice(0);","\t\t\t} else if (typeof value === 'object' && value !== null) {","\t\t\t\tobjClone[key] = helpers.clone(value);","\t\t\t} else {","\t\t\t\tobjClone[key] = value;","\t\t\t}","\t\t});","\t\treturn objClone;","\t};","\thelpers.extend = function(base) {","\t\tvar setFn = function(value, key) { base[key] = value; };","\t\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {","\t\t\thelpers.each(arguments[i], setFn);","\t\t}","\t\treturn base;","\t};","\t// Need a special merge function to chart configs since they are now grouped","\thelpers.configMerge = function(_base) {","\t\tvar base = helpers.clone(_base);","\t\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {","\t\t\thelpers.each(extension, function(value, key) {","\t\t\t\tif (key === 'scales') {","\t\t\t\t\t// Scale config merging is complex. Add out own function here for that","\t\t\t\t\tbase[key] = helpers.scaleMerge(base.hasOwnProperty(key) ? base[key] : {}, value);","","\t\t\t\t} else if (key === 'scale') {","\t\t\t\t\t// Used in polar area & radar charts since there is only one scale","\t\t\t\t\tbase[key] = helpers.configMerge(base.hasOwnProperty(key) ? base[key] : {}, Chart.scaleService.getScaleDefaults(value.type), value);","\t\t\t\t} else if (base.hasOwnProperty(key) && helpers.isArray(base[key]) && helpers.isArray(value)) {","\t\t\t\t\t// In this case we have an array of objects replacing another array. Rather than doing a strict replace,","\t\t\t\t\t// merge. This allows easy scale option merging","\t\t\t\t\tvar baseArray = base[key];","","\t\t\t\t\thelpers.each(value, function(valueObj, index) {","","\t\t\t\t\t\tif (index < baseArray.length) {","\t\t\t\t\t\t\tif (typeof baseArray[index] === 'object' && baseArray[index] !== null && typeof valueObj === 'object' && valueObj !== null) {","\t\t\t\t\t\t\t\t// Two objects are coming together. Do a merge of them.","\t\t\t\t\t\t\t\tbaseArray[index] = helpers.configMerge(baseArray[index], valueObj);","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t// Just overwrite in this case since there is nothing to merge","\t\t\t\t\t\t\t\tbaseArray[index] = valueObj;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tbaseArray.push(valueObj); // nothing to merge","\t\t\t\t\t\t}","\t\t\t\t\t});","","\t\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === \"object\" && base[key] !== null && typeof value === \"object\") {","\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.","\t\t\t\t\tbase[key] = helpers.configMerge(base[key], value);","","\t\t\t\t} else {","\t\t\t\t\t// can just overwrite the value in this case","\t\t\t\t\tbase[key] = value;","\t\t\t\t}","\t\t\t});","\t\t});","","\t\treturn base;","\t};","\thelpers.scaleMerge = function(_base, extension) {","\t\tvar base = helpers.clone(_base);","","\t\thelpers.each(extension, function(value, key) {","\t\t\tif (key === 'xAxes' || key === 'yAxes') {","\t\t\t\t// These properties are arrays of items","\t\t\t\tif (base.hasOwnProperty(key)) {","\t\t\t\t\thelpers.each(value, function(valueObj, index) {","\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');","\t\t\t\t\t\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);","\t\t\t\t\t\tif (index >= base[key].length || !base[key][index].type) {","\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));","\t\t\t\t\t\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {","\t\t\t\t\t\t\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults","\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t// Type is the same","\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);","\t\t\t\t\t\t}","\t\t\t\t\t});","\t\t\t\t} else {","\t\t\t\t\tbase[key] = [];","\t\t\t\t\thelpers.each(value, function(valueObj) {","\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');","\t\t\t\t\t\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));","\t\t\t\t\t});","\t\t\t\t}","\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === \"object\" && base[key] !== null && typeof value === \"object\") {","\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.","\t\t\t\tbase[key] = helpers.configMerge(base[key], value);","","\t\t\t} else {","\t\t\t\t// can just overwrite the value in this case","\t\t\t\tbase[key] = value;","\t\t\t}","\t\t});","","\t\treturn base;","\t};","\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {","\t\tif (value === undefined || value === null) {","\t\t\treturn defaultValue;","\t\t}","","\t\tif (helpers.isArray(value)) {","\t\t\treturn index < value.length ? value[index] : defaultValue;","\t\t}","","\t\treturn value;","\t};","\thelpers.getValueOrDefault = function(value, defaultValue) {","\t\treturn value === undefined ? defaultValue : value;","\t};","\thelpers.indexOf = Array.prototype.indexOf?","\t\tfunction(array, item) { return array.indexOf(item); } :","\t\tfunction(array, item) {","\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {","\t\t\t\tif (array[i] === item) {","\t\t\t\t\treturn i;","\t\t\t\t}","\t\t\t}","\t\t\treturn -1;","\t\t};","\thelpers.where = function(collection, filterCallback) {","\t\tif (helpers.isArray(collection) && Array.prototype.filter) {","\t\t\treturn collection.filter(filterCallback);","\t\t} else {","\t\t\tvar filtered = [];","","\t\t\thelpers.each(collection, function(item) {","\t\t\t\tif (filterCallback(item)) {","\t\t\t\t\tfiltered.push(item);","\t\t\t\t}","\t\t\t});","","\t\t\treturn filtered;","\t\t}","\t};","\thelpers.findIndex = Array.prototype.findIndex?","\t\tfunction(array, callback, scope) { return array.findIndex(callback, scope); } :","\t\tfunction(array, callback, scope) {","\t\t\tscope = scope === undefined? array : scope;","\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {","\t\t\t\tif (callback.call(scope, array[i], i, array)) {","\t\t\t\t\treturn i;","\t\t\t\t}","\t\t\t}","\t\t\treturn -1;","\t\t};","\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {","\t\t// Default to start of the array","\t\tif (startIndex === undefined || startIndex === null) {","\t\t\tstartIndex = -1;","\t\t}","\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {","\t\t\tvar currentItem = arrayToSearch[i];","\t\t\tif (filterCallback(currentItem)) {","\t\t\t\treturn currentItem;","\t\t\t}","\t\t}","\t};","\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {","\t\t// Default to end of the array","\t\tif (startIndex === undefined || startIndex === null) {","\t\t\tstartIndex = arrayToSearch.length;","\t\t}","\t\tfor (var i = startIndex - 1; i >= 0; i--) {","\t\t\tvar currentItem = arrayToSearch[i];","\t\t\tif (filterCallback(currentItem)) {","\t\t\t\treturn currentItem;","\t\t\t}","\t\t}","\t};","\thelpers.inherits = function(extensions) {","\t\t//Basic javascript inheritance based on the model created in Backbone.js","\t\tvar parent = this;","\t\tvar ChartElement = (extensions && extensions.hasOwnProperty(\"constructor\")) ? extensions.constructor : function() {","\t\t\treturn parent.apply(this, arguments);","\t\t};","","\t\tvar Surrogate = function() {","\t\t\tthis.constructor = ChartElement;","\t\t};","\t\tSurrogate.prototype = parent.prototype;","\t\tChartElement.prototype = new Surrogate();","","\t\tChartElement.extend = helpers.inherits;","","\t\tif (extensions) {","\t\t\thelpers.extend(ChartElement.prototype, extensions);","\t\t}","","\t\tChartElement.__super__ = parent.prototype;","","\t\treturn ChartElement;","\t};","\thelpers.noop = function() {};","\thelpers.uid = (function() {","\t\tvar id = 0;","\t\treturn function() {","\t\t\treturn id++;","\t\t};","\t})();","\t//-- Math methods","\thelpers.isNumber = function(n) {","\t\treturn !isNaN(parseFloat(n)) && isFinite(n);","\t};","\thelpers.almostEquals = function(x, y, epsilon) {","\t\treturn Math.abs(x - y) < epsilon;","\t};","\thelpers.max = function(array) {","\t\treturn array.reduce(function(max, value) {","\t\t\tif (!isNaN(value)) {","\t\t\t\treturn Math.max(max, value);","\t\t\t} else {","\t\t\t\treturn max;","\t\t\t}","\t\t}, Number.NEGATIVE_INFINITY);","\t};","\thelpers.min = function(array) {","\t\treturn array.reduce(function(min, value) {","\t\t\tif (!isNaN(value)) {","\t\t\t\treturn Math.min(min, value);","\t\t\t} else {","\t\t\t\treturn min;","\t\t\t}","\t\t}, Number.POSITIVE_INFINITY);","\t};","\thelpers.sign = Math.sign?","\t\tfunction(x) { return Math.sign(x); } :","\t\tfunction(x) {","\t\t\tx = +x; // convert to a number","\t\t\tif (x === 0 || isNaN(x)) {","\t\t\t\treturn x;","\t\t\t}","\t\t\treturn x > 0 ? 1 : -1;","\t\t};","\thelpers.log10 = Math.log10?","\t\tfunction(x) { return Math.log10(x); } :","\t\tfunction(x) {","\t\t\treturn Math.log(x) / Math.LN10;","\t\t};","\thelpers.toRadians = function(degrees) {","\t\treturn degrees * (Math.PI / 180);","\t};","\thelpers.toDegrees = function(radians) {","\t\treturn radians * (180 / Math.PI);","\t};","\t// Gets the angle from vertical upright to the point about a centre.","\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {","\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,","\t\t\tdistanceFromYCenter = anglePoint.y - centrePoint.y,","\t\t\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);","","\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);","","\t\tif (angle < (-0.5 * Math.PI)) {","\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]","\t\t}","","\t\treturn {","\t\t\tangle: angle,","\t\t\tdistance: radialDistanceFromCenter","\t\t};","\t};","\thelpers.aliasPixel = function(pixelWidth) {","\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;","\t};","\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {","\t\t//Props to Rob Spencer at scaled innovation for his post on splining between points","\t\t//http://scaledinnovation.com/analytics/splines/aboutSplines.html","","\t\t// This function must also respect \"skipped\" points","","\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint,","\t\t\tcurrent = middlePoint,","\t\t\tnext = afterPoint.skip ? middlePoint : afterPoint;","","\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));","\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));","","\t\tvar s01 = d01 / (d01 + d12);","\t\tvar s12 = d12 / (d01 + d12);","","\t\t// If all points are the same, s01 & s02 will be inf","\t\ts01 = isNaN(s01) ? 0 : s01;","\t\ts12 = isNaN(s12) ? 0 : s12;","","\t\tvar fa = t * s01; // scaling factor for triangle Ta","\t\tvar fb = t * s12;","","\t\treturn {","\t\t\tprevious: {","\t\t\t\tx: current.x - fa * (next.x - previous.x),","\t\t\t\ty: current.y - fa * (next.y - previous.y)","\t\t\t},","\t\t\tnext: {","\t\t\t\tx: current.x + fb * (next.x - previous.x),","\t\t\t\ty: current.y + fb * (next.y - previous.y)","\t\t\t}","\t\t};","\t};","\thelpers.nextItem = function(collection, index, loop) {","\t\tif (loop) {","\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];","\t\t}","","\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];","\t};","\thelpers.previousItem = function(collection, index, loop) {","\t\tif (loop) {","\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];","\t\t}","\t\treturn index <= 0 ? collection[0] : collection[index - 1];","\t};","\t// Implementation of the nice number algorithm used in determining where axis labels will go","\thelpers.niceNum = function(range, round) {","\t\tvar exponent = Math.floor(helpers.log10(range));","\t\tvar fraction = range / Math.pow(10, exponent);","\t\tvar niceFraction;","","\t\tif (round) {","\t\t\tif (fraction < 1.5) {","\t\t\t\tniceFraction = 1;","\t\t\t} else if (fraction < 3) {","\t\t\t\tniceFraction = 2;","\t\t\t} else if (fraction < 7) {","\t\t\t\tniceFraction = 5;","\t\t\t} else {","\t\t\t\tniceFraction = 10;","\t\t\t}","\t\t} else {","\t\t\tif (fraction <= 1.0) {","\t\t\t\tniceFraction = 1;","\t\t\t} else if (fraction <= 2) {","\t\t\t\tniceFraction = 2;","\t\t\t} else if (fraction <= 5) {","\t\t\t\tniceFraction = 5;","\t\t\t} else {","\t\t\t\tniceFraction = 10;","\t\t\t}","\t\t}","","\t\treturn niceFraction * Math.pow(10, exponent);","\t};","\t//Easing functions adapted from Robert Penner's easing equations","\t//http://www.robertpenner.com/easing/","\tvar easingEffects = helpers.easingEffects = {","\t\tlinear: function(t) {","\t\t\treturn t;","\t\t},","\t\teaseInQuad: function(t) {","\t\t\treturn t * t;","\t\t},","\t\teaseOutQuad: function(t) {","\t\t\treturn -1 * t * (t - 2);","\t\t},","\t\teaseInOutQuad: function(t) {","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn 1 / 2 * t * t;","\t\t\t}","\t\t\treturn -1 / 2 * ((--t) * (t - 2) - 1);","\t\t},","\t\teaseInCubic: function(t) {","\t\t\treturn t * t * t;","\t\t},","\t\teaseOutCubic: function(t) {","\t\t\treturn 1 * ((t = t / 1 - 1) * t * t + 1);","\t\t},","\t\teaseInOutCubic: function(t) {","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn 1 / 2 * t * t * t;","\t\t\t}","\t\t\treturn 1 / 2 * ((t -= 2) * t * t + 2);","\t\t},","\t\teaseInQuart: function(t) {","\t\t\treturn t * t * t * t;","\t\t},","\t\teaseOutQuart: function(t) {","\t\t\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);","\t\t},","\t\teaseInOutQuart: function(t) {","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn 1 / 2 * t * t * t * t;","\t\t\t}","\t\t\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);","\t\t},","\t\teaseInQuint: function(t) {","\t\t\treturn 1 * (t /= 1) * t * t * t * t;","\t\t},","\t\teaseOutQuint: function(t) {","\t\t\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);","\t\t},","\t\teaseInOutQuint: function(t) {","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn 1 / 2 * t * t * t * t * t;","\t\t\t}","\t\t\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);","\t\t},","\t\teaseInSine: function(t) {","\t\t\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;","\t\t},","\t\teaseOutSine: function(t) {","\t\t\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));","\t\t},","\t\teaseInOutSine: function(t) {","\t\t\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);","\t\t},","\t\teaseInExpo: function(t) {","\t\t\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));","\t\t},","\t\teaseOutExpo: function(t) {","\t\t\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);","\t\t},","\t\teaseInOutExpo: function(t) {","\t\t\tif (t === 0) {","\t\t\t\treturn 0;","\t\t\t}","\t\t\tif (t === 1) {","\t\t\t\treturn 1;","\t\t\t}","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));","\t\t\t}","\t\t\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);","\t\t},","\t\teaseInCirc: function(t) {","\t\t\tif (t >= 1) {","\t\t\t\treturn t;","\t\t\t}","\t\t\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);","\t\t},","\t\teaseOutCirc: function(t) {","\t\t\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);","\t\t},","\t\teaseInOutCirc: function(t) {","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);","\t\t\t}","\t\t\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);","\t\t},","\t\teaseInElastic: function(t) {","\t\t\tvar s = 1.70158;","\t\t\tvar p = 0;","\t\t\tvar a = 1;","\t\t\tif (t === 0) {","\t\t\t\treturn 0;","\t\t\t}","\t\t\tif ((t /= 1) === 1) {","\t\t\t\treturn 1;","\t\t\t}","\t\t\tif (!p) {","\t\t\t\tp = 1 * 0.3;","\t\t\t}","\t\t\tif (a < Math.abs(1)) {","\t\t\t\ta = 1;","\t\t\t\ts = p / 4;","\t\t\t} else {","\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);","\t\t\t}","\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));","\t\t},","\t\teaseOutElastic: function(t) {","\t\t\tvar s = 1.70158;","\t\t\tvar p = 0;","\t\t\tvar a = 1;","\t\t\tif (t === 0) {","\t\t\t\treturn 0;","\t\t\t}","\t\t\tif ((t /= 1) === 1) {","\t\t\t\treturn 1;","\t\t\t}","\t\t\tif (!p) {","\t\t\t\tp = 1 * 0.3;","\t\t\t}","\t\t\tif (a < Math.abs(1)) {","\t\t\t\ta = 1;","\t\t\t\ts = p / 4;","\t\t\t} else {","\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);","\t\t\t}","\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;","\t\t},","\t\teaseInOutElastic: function(t) {","\t\t\tvar s = 1.70158;","\t\t\tvar p = 0;","\t\t\tvar a = 1;","\t\t\tif (t === 0) {","\t\t\t\treturn 0;","\t\t\t}","\t\t\tif ((t /= 1 / 2) === 2) {","\t\t\t\treturn 1;","\t\t\t}","\t\t\tif (!p) {","\t\t\t\tp = 1 * (0.3 * 1.5);","\t\t\t}","\t\t\tif (a < Math.abs(1)) {","\t\t\t\ta = 1;","\t\t\t\ts = p / 4;","\t\t\t} else {","\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);","\t\t\t}","\t\t\tif (t < 1) {","\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));","\t\t\t}","\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;","\t\t},","\t\teaseInBack: function(t) {","\t\t\tvar s = 1.70158;","\t\t\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);","\t\t},","\t\teaseOutBack: function(t) {","\t\t\tvar s = 1.70158;","\t\t\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);","\t\t},","\t\teaseInOutBack: function(t) {","\t\t\tvar s = 1.70158;","\t\t\tif ((t /= 1 / 2) < 1) {","\t\t\t\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));","\t\t\t}","\t\t\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);","\t\t},","\t\teaseInBounce: function(t) {","\t\t\treturn 1 - easingEffects.easeOutBounce(1 - t);","\t\t},","\t\teaseOutBounce: function(t) {","\t\t\tif ((t /= 1) < (1 / 2.75)) {","\t\t\t\treturn 1 * (7.5625 * t * t);","\t\t\t} else if (t < (2 / 2.75)) {","\t\t\t\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);","\t\t\t} else if (t < (2.5 / 2.75)) {","\t\t\t\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);","\t\t\t} else {","\t\t\t\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);","\t\t\t}","\t\t},","\t\teaseInOutBounce: function(t) {","\t\t\tif (t < 1 / 2) {","\t\t\t\treturn easingEffects.easeInBounce(t * 2) * 0.5;","\t\t\t}","\t\t\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;","\t\t}","\t};","\t//Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/","\thelpers.requestAnimFrame = (function() {","\t\treturn window.requestAnimationFrame ||","\t\t\twindow.webkitRequestAnimationFrame ||","\t\t\twindow.mozRequestAnimationFrame ||","\t\t\twindow.oRequestAnimationFrame ||","\t\t\twindow.msRequestAnimationFrame ||","\t\t\tfunction(callback) {","\t\t\t\treturn window.setTimeout(callback, 1000 / 60);","\t\t\t};","\t})();","\thelpers.cancelAnimFrame = (function() {","\t\treturn window.cancelAnimationFrame ||","\t\t\twindow.webkitCancelAnimationFrame ||","\t\t\twindow.mozCancelAnimationFrame ||","\t\t\twindow.oCancelAnimationFrame ||","\t\t\twindow.msCancelAnimationFrame ||","\t\t\tfunction(callback) {","\t\t\t\treturn window.clearTimeout(callback, 1000 / 60);","\t\t\t};","\t})();","\t//-- DOM methods","\thelpers.getRelativePosition = function(evt, chart) {","\t\tvar mouseX, mouseY;","\t\tvar e = evt.originalEvent || evt,","\t\t\tcanvas = evt.currentTarget || evt.srcElement,","\t\t\tboundingRect = canvas.getBoundingClientRect();","","\t\tvar touches = e.touches;","\t\tif (touches && touches.length > 0) {","\t\t\tmouseX = touches[0].clientX;","\t\t\tmouseY = touches[0].clientY;","","\t\t} else {","\t\t\tmouseX = e.clientX;","\t\t\tmouseY = e.clientY;","\t\t}","","\t\t// Scale mouse coordinates into canvas coordinates","\t\t// by following the pattern laid out by 'jerryj' in the comments of","\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/","\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));","\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));","\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));","\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));","\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;","\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;","","\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However","\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here","\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);","\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);","","\t\treturn {","\t\t\tx: mouseX,","\t\t\ty: mouseY","\t\t};","","\t};","\thelpers.addEvent = function(node, eventType, method) {","\t\tif (node.addEventListener) {","\t\t\tnode.addEventListener(eventType, method);","\t\t} else if (node.attachEvent) {","\t\t\tnode.attachEvent(\"on\" + eventType, method);","\t\t} else {","\t\t\tnode[\"on\" + eventType] = method;","\t\t}","\t};","\thelpers.removeEvent = function(node, eventType, handler) {","\t\tif (node.removeEventListener) {","\t\t\tnode.removeEventListener(eventType, handler, false);","\t\t} else if (node.detachEvent) {","\t\t\tnode.detachEvent(\"on\" + eventType, handler);","\t\t} else {","\t\t\tnode[\"on\" + eventType] = helpers.noop;","\t\t}","\t};","\thelpers.bindEvents = function(chartInstance, arrayOfEvents, handler) {","\t\t// Create the events object if it's not already present","\t\tvar events = chartInstance.events = chartInstance.events || {};","","\t\thelpers.each(arrayOfEvents, function(eventName) {","\t\t\tevents[eventName] = function() {","\t\t\t\thandler.apply(chartInstance, arguments);","\t\t\t};","\t\t\thelpers.addEvent(chartInstance.chart.canvas, eventName, events[eventName]);","\t\t});","\t};","\thelpers.unbindEvents = function(chartInstance, arrayOfEvents) {","\t\tvar canvas = chartInstance.chart.canvas;","\t\thelpers.each(arrayOfEvents, function(handler, eventName) {","\t\t\thelpers.removeEvent(canvas, eventName, handler);","\t\t});","\t};","","\t// Private helper function to convert max-width/max-height values that may be percentages into a number","\tfunction parseMaxStyle(styleValue, node, parentProperty) {","\t\tvar valueInPixels;","\t\tif (typeof(styleValue) === 'string') {","\t\t\tvalueInPixels = parseInt(styleValue, 10);","","\t\t\tif (styleValue.indexOf('%') != -1) {","\t\t\t\t// percentage * size in dimension","\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];","\t\t\t}","\t\t} else {","\t\t\tvalueInPixels = styleValue;","\t\t}","","\t\treturn valueInPixels;","\t}","","\t/**","\t * Returns if the given value contains an effective constraint.","\t * @private","\t */","\tfunction isConstrainedValue(value) {","\t\treturn value !== undefined &&  value !== null && value !== 'none';","\t}","","\t// Private helper to get a constraint dimension","\t// @param domNode : the node to check the constraint on","\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)","\t// @param percentageProperty : property of parent to use when calculating width as a percentage","\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser","\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {","\t\tvar view = document.defaultView;","\t\tvar parentNode = domNode.parentNode;","\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];","\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];","\t\tvar hasCNode = isConstrainedValue(constrainedNode);","\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);","\t\tvar infinity = Number.POSITIVE_INFINITY;","","\t\tif (hasCNode || hasCContainer) {","\t\t\treturn Math.min(","\t\t\t\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,","\t\t\t\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);","\t\t}","","\t\treturn 'none';","\t}","\t// returns Number or undefined if no constraint","\thelpers.getConstraintWidth = function(domNode) {","\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');","\t};","\t// returns Number or undefined if no constraint","\thelpers.getConstraintHeight = function(domNode) {","\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');","\t};","\thelpers.getMaximumWidth = function(domNode) {","\t\tvar container = domNode.parentNode;","\t\tvar padding = parseInt(helpers.getStyle(container, 'padding-left')) + parseInt(helpers.getStyle(container, 'padding-right'));","\t\tvar w = container.clientWidth - padding;","\t\tvar cw = helpers.getConstraintWidth(domNode);","\t\treturn isNaN(cw)? w : Math.min(w, cw);","\t};","\thelpers.getMaximumHeight = function(domNode) {","\t\tvar container = domNode.parentNode;","\t\tvar padding = parseInt(helpers.getStyle(container, 'padding-top')) + parseInt(helpers.getStyle(container, 'padding-bottom'));","\t\tvar h = container.clientHeight - padding;","\t\tvar ch = helpers.getConstraintHeight(domNode);","\t\treturn isNaN(ch)? h : Math.min(h, ch);","\t};","\thelpers.getStyle = function(el, property) {","\t\treturn el.currentStyle ?","\t\t\tel.currentStyle[property] :","\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);","\t};","\thelpers.retinaScale = function(chart) {","\t\tvar ctx = chart.ctx;","\t\tvar canvas = chart.canvas;","\t\tvar width = canvas.width;","\t\tvar height = canvas.height;","\t\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;","","\t\tif (pixelRatio !== 1) {","\t\t\tcanvas.height = height * pixelRatio;","\t\t\tcanvas.width = width * pixelRatio;","\t\t\tctx.scale(pixelRatio, pixelRatio);","","\t\t\t// Store the device pixel ratio so that we can go backwards in `destroy`.","\t\t\t// The devicePixelRatio changes with zoom, so there are no guarantees that it is the same","\t\t\t// when destroy is called","\t\t\tchart.originalDevicePixelRatio = chart.originalDevicePixelRatio || pixelRatio;","\t\t}","","\t\tcanvas.style.width = width + 'px';","\t\tcanvas.style.height = height + 'px';","\t};","\t//-- Canvas methods","\thelpers.clear = function(chart) {","\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);","\t};","\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {","\t\treturn fontStyle + \" \" + pixelSize + \"px \" + fontFamily;","\t};","\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {","\t\tcache = cache || {};","\t\tvar data = cache.data = cache.data || {};","\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];","","\t\tif (cache.font !== font) {","\t\t\tdata = cache.data = {};","\t\t\tgc = cache.garbageCollect = [];","\t\t\tcache.font = font;","\t\t}","","\t\tctx.font = font;","\t\tvar longest = 0;","\t\thelpers.each(arrayOfThings, function(thing) {","\t\t\t// Undefined strings and arrays should not be measured","\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {","\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);","\t\t\t} else if (helpers.isArray(thing)) {","\t\t\t\t// if it is an array lets measure each element","\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?","\t\t\t\thelpers.each(thing, function(nestedThing) {","\t\t\t\t\t// Undefined strings and arrays should not be measured","\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {","\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);","\t\t\t\t\t}","\t\t\t\t});","\t\t\t}","\t\t});","","\t\tvar gcLen = gc.length / 2;","\t\tif (gcLen > arrayOfThings.length) {","\t\t\tfor (var i = 0; i < gcLen; i++) {","\t\t\t\tdelete data[gc[i]];","\t\t\t}","\t\t\tgc.splice(0, gcLen);","\t\t}","\t\treturn longest;","\t};","\thelpers.measureText = function (ctx, data, gc, longest, string) {","\t\tvar textWidth = data[string];","\t\tif (!textWidth) {","\t\t\ttextWidth = data[string] = ctx.measureText(string).width;","\t\t\tgc.push(string);","\t\t}","\t\tif (textWidth > longest) {","\t\t\tlongest = textWidth;","\t\t}","\t\treturn longest;","\t};","\thelpers.numberOfLabelLines = function(arrayOfThings) {","\t\tvar numberOfLines = 1;","\t\thelpers.each(arrayOfThings, function(thing) {","\t\t\tif (helpers.isArray(thing)) {","\t\t\t\tif (thing.length > numberOfLines) {","\t\t\t\t\tnumberOfLines = thing.length;","\t\t\t\t}","\t\t\t}","\t\t});","\t\treturn numberOfLines;","\t};","\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {","\t\tctx.beginPath();","\t\tctx.moveTo(x + radius, y);","\t\tctx.lineTo(x + width - radius, y);","\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);","\t\tctx.lineTo(x + width, y + height - radius);","\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);","\t\tctx.lineTo(x + radius, y + height);","\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);","\t\tctx.lineTo(x, y + radius);","\t\tctx.quadraticCurveTo(x, y, x + radius, y);","\t\tctx.closePath();","\t};","\thelpers.color = function(c) {","\t\tif (!color) {","\t\t\tconsole.log('Color.js not found!');","\t\t\treturn c;","\t\t}","","\t\t/* global CanvasGradient */","\t\tif (c instanceof CanvasGradient) {","\t\t\treturn color(Chart.defaults.global.defaultColor);","\t\t}","","\t\treturn color(c);","\t};","\thelpers.addResizeListener = function(node, callback) {","\t\t// Hide an iframe before the node","\t\tvar hiddenIframe = document.createElement('iframe');","\t\tvar hiddenIframeClass = 'chartjs-hidden-iframe';","","\t\tif (hiddenIframe.classlist) {","\t\t\t// can use classlist","\t\t\thiddenIframe.classlist.add(hiddenIframeClass);","\t\t} else {","\t\t\thiddenIframe.setAttribute('class', hiddenIframeClass);","\t\t}","","\t\t// Set the style","\t\tvar style = hiddenIframe.style;","\t\tstyle.width = '100%';","\t\tstyle.display = 'block';","\t\tstyle.border = 0;","\t\tstyle.height = 0;","\t\tstyle.margin = 0;","\t\tstyle.position = 'absolute';","\t\tstyle.left = 0;","\t\tstyle.right = 0;","\t\tstyle.top = 0;","\t\tstyle.bottom = 0;","","\t\t// Insert the iframe so that contentWindow is available","\t\tnode.insertBefore(hiddenIframe, node.firstChild);","","\t\t(hiddenIframe.contentWindow || hiddenIframe).onresize = function() {","\t\t\tif (callback) {","\t\t\t\tcallback();","\t\t\t}","\t\t};","\t};","\thelpers.removeResizeListener = function(node) {","\t\tvar hiddenIframe = node.querySelector('.chartjs-hidden-iframe');","","\t\t// Remove the resize detect iframe","\t\tif (hiddenIframe) {","\t\t\thiddenIframe.parentNode.removeChild(hiddenIframe);","\t\t}","\t};","\thelpers.isArray = Array.isArray?","\t\tfunction(obj) { return Array.isArray(obj); } :","\t\tfunction(obj) {","\t\t\treturn Object.prototype.toString.call(obj) === '[object Array]';","\t\t};","\t//! @see http://stackoverflow.com/a/14853974","\thelpers.arrayEquals = function(a0, a1) {","\t\tvar i, ilen, v0, v1;","","\t\tif (!a0 || !a1 || a0.length != a1.length) {","\t\t\treturn false;","\t\t}","","\t\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {","\t\t\tv0 = a0[i];","\t\t\tv1 = a1[i];","","\t\t\tif (v0 instanceof Array && v1 instanceof Array) {","\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {","\t\t\t\t\treturn false;","\t\t\t\t}","\t\t\t} else if (v0 != v1) {","\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}","\t\t\t\treturn false;","\t\t\t}","\t\t}","","\t\treturn true;","\t};","\thelpers.callCallback = function(fn, args, _tArg) {","\t\tif (fn && typeof fn.call === 'function') {","\t\t\tfn.apply(_tArg, args);","\t\t}","\t};","\thelpers.getHoverColor = function(color) {","\t\t/* global CanvasPattern */","\t\treturn (color instanceof CanvasPattern) ?","\t\t\tcolor :","\t\t\thelpers.color(color).saturate(0.5).darken(0.1).rgbString();","\t};","};","","},{\"2\":2}],26:[function(require,module,exports){","\"use strict\";","","module.exports = function() {","","\t//Occupy the global variable of Chart, and create a simple base class","\tvar Chart = function(context, config) {","\t\tvar me = this;","\t\tvar helpers = Chart.helpers;","\t\tme.config = config;","","\t\t// Support a jQuery'd canvas element","\t\tif (context.length && context[0].getContext) {","\t\t\tcontext = context[0];","\t\t}","","\t\t// Support a canvas domnode","\t\tif (context.getContext) {","\t\t\tcontext = context.getContext(\"2d\");","\t\t}","","\t\tme.ctx = context;","\t\tme.canvas = context.canvas;","","\t\tcontext.canvas.style.display = context.canvas.style.display || 'block';","","\t\t// Figure out what the size of the chart will be.","\t\t// If the canvas has a specified width and height, we use those else","\t\t// we look to see if the canvas node has a CSS width and height.","\t\t// If there is still no height, fill the parent container","\t\tme.width = context.canvas.width || parseInt(helpers.getStyle(context.canvas, 'width'), 10) || helpers.getMaximumWidth(context.canvas);","\t\tme.height = context.canvas.height || parseInt(helpers.getStyle(context.canvas, 'height'), 10) || helpers.getMaximumHeight(context.canvas);","","\t\tme.aspectRatio = me.width / me.height;","","\t\tif (isNaN(me.aspectRatio) || isFinite(me.aspectRatio) === false) {","\t\t\t// If the canvas has no size, try and figure out what the aspect ratio will be.","\t\t\t// Some charts prefer square canvases (pie, radar, etc). If that is specified, use that","\t\t\t// else use the canvas default ratio of 2","\t\t\tme.aspectRatio = config.aspectRatio !== undefined ? config.aspectRatio : 2;","\t\t}","","\t\t// Store the original style of the element so we can set it back","\t\tme.originalCanvasStyleWidth = context.canvas.style.width;","\t\tme.originalCanvasStyleHeight = context.canvas.style.height;","","\t\t// High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.","\t\thelpers.retinaScale(me);","","\t\tif (config) {","\t\t\tme.controller = new Chart.Controller(me);","\t\t}","","\t\t// Always bind this so that if the responsive state changes we still work","\t\thelpers.addResizeListener(context.canvas.parentNode, function() {","\t\t\tif (me.controller && me.controller.config.options.responsive) {","\t\t\t\tme.controller.resize();","\t\t\t}","\t\t});","","\t\treturn me.controller ? me.controller : me;","","\t};","","\t//Globally expose the defaults to allow for user updating/changing","\tChart.defaults = {","\t\tglobal: {","\t\t\tresponsive: true,","\t\t\tresponsiveAnimationDuration: 0,","\t\t\tmaintainAspectRatio: true,","\t\t\tevents: [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"],","\t\t\thover: {","\t\t\t\tonHover: null,","\t\t\t\tmode: 'single',","\t\t\t\tanimationDuration: 400","\t\t\t},","\t\t\tonClick: null,","\t\t\tdefaultColor: 'rgba(0,0,0,0.1)',","\t\t\tdefaultFontColor: '#666',","\t\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",","\t\t\tdefaultFontSize: 12,","\t\t\tdefaultFontStyle: 'normal',","\t\t\tshowLines: true,","","\t\t\t// Element defaults defined in element extensions","\t\t\telements: {},","","\t\t\t// Legend callback string","\t\t\tlegendCallback: function(chart) {","\t\t\t\tvar text = [];","\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');","\t\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {","\t\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');","\t\t\t\t\tif (chart.data.datasets[i].label) {","\t\t\t\t\t\ttext.push(chart.data.datasets[i].label);","\t\t\t\t\t}","\t\t\t\t\ttext.push('</li>');","\t\t\t\t}","\t\t\t\ttext.push('</ul>');","","\t\t\t\treturn text.join(\"\");","\t\t\t}","\t\t}","\t};","","\tChart.Chart = Chart;","","\treturn Chart;","","};","","},{}],27:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.","\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need","\t// It is this service's responsibility of carrying out that layout.","\tChart.layoutService = {","\t\tdefaults: {},","","\t\t// Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.","\t\taddBox: function(chartInstance, box) {","\t\t\tif (!chartInstance.boxes) {","\t\t\t\tchartInstance.boxes = [];","\t\t\t}","\t\t\tchartInstance.boxes.push(box);","\t\t},","","\t\tremoveBox: function(chartInstance, box) {","\t\t\tif (!chartInstance.boxes) {","\t\t\t\treturn;","\t\t\t}","\t\t\tchartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);","\t\t},","","\t\t// The most important function","\t\tupdate: function(chartInstance, width, height) {","","\t\t\tif (!chartInstance) {","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar xPadding = 0;","\t\t\tvar yPadding = 0;","","\t\t\tvar leftBoxes = helpers.where(chartInstance.boxes, function(box) {","\t\t\t\treturn box.options.position === \"left\";","\t\t\t});","\t\t\tvar rightBoxes = helpers.where(chartInstance.boxes, function(box) {","\t\t\t\treturn box.options.position === \"right\";","\t\t\t});","\t\t\tvar topBoxes = helpers.where(chartInstance.boxes, function(box) {","\t\t\t\treturn box.options.position === \"top\";","\t\t\t});","\t\t\tvar bottomBoxes = helpers.where(chartInstance.boxes, function(box) {","\t\t\t\treturn box.options.position === \"bottom\";","\t\t\t});","","\t\t\t// Boxes that overlay the chartarea such as the radialLinear scale","\t\t\tvar chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {","\t\t\t\treturn box.options.position === \"chartArea\";","\t\t\t});","","\t\t\t// Ensure that full width boxes are at the very top / bottom","\t\t\ttopBoxes.sort(function(a, b) {","\t\t\t\treturn (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);","\t\t\t});","\t\t\tbottomBoxes.sort(function(a, b) {","\t\t\t\treturn (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);","\t\t\t});","","\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.","\t\t\t// Our canvas looks like the following.","\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and","\t\t\t// B1 is the bottom axis","\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays","\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,","\t\t\t// an error will be thrown.","\t\t\t//","\t\t\t// |----------------------------------------------------|","\t\t\t// |                  T1 (Full Width)                   |","\t\t\t// |----------------------------------------------------|","\t\t\t// |    |    |                 T2                  |    |","\t\t\t// |    |----|-------------------------------------|----|","\t\t\t// |    |    | C1 |                           | C2 |    |","\t\t\t// |    |    |----|                           |----|    |","\t\t\t// |    |    |                                     |    |","\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |","\t\t\t// |    |    |                                     |    |","\t\t\t// |    |    |----|                           |----|    |","\t\t\t// |    |    | C3 |                           | C4 |    |","\t\t\t// |    |----|-------------------------------------|----|","\t\t\t// |    |    |                 B1                  |    |","\t\t\t// |----------------------------------------------------|","\t\t\t// |                  B2 (Full Width)                   |","\t\t\t// |----------------------------------------------------|","\t\t\t//","\t\t\t// What we do to find the best sizing, we do the following","\t\t\t// 1. Determine the minimum size of the chart area.","\t\t\t// 2. Split the remaining width equally between each vertical axis","\t\t\t// 3. Split the remaining height equally between each horizontal axis","\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size","\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.","\t\t\t// 6. Refit each axis","\t\t\t// 7. Position each axis in the final location","\t\t\t// 8. Tell the chart the final location of the chart area","\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area","","\t\t\t// Step 1","\t\t\tvar chartWidth = width - (2 * xPadding);","\t\t\tvar chartHeight = height - (2 * yPadding);","\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%","\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%","","\t\t\t// Step 2","\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);","","\t\t\t// Step 3","\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);","","\t\t\t// Step 4","\t\t\tvar maxChartAreaWidth = chartWidth;","\t\t\tvar maxChartAreaHeight = chartHeight;","\t\t\tvar minBoxSizes = [];","","\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);","","\t\t\tfunction getMinimumBoxSize(box) {","\t\t\t\tvar minSize;","\t\t\t\tvar isHorizontal = box.isHorizontal();","","\t\t\t\tif (isHorizontal) {","\t\t\t\t\tminSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);","\t\t\t\t\tmaxChartAreaHeight -= minSize.height;","\t\t\t\t} else {","\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);","\t\t\t\t\tmaxChartAreaWidth -= minSize.width;","\t\t\t\t}","","\t\t\t\tminBoxSizes.push({","\t\t\t\t\thorizontal: isHorizontal,","\t\t\t\t\tminSize: minSize,","\t\t\t\t\tbox: box","\t\t\t\t});","\t\t\t}","","\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could","\t\t\t// be if the axes are drawn at their minimum sizes.","","\t\t\t// Steps 5 & 6","\t\t\tvar totalLeftBoxesWidth = xPadding;","\t\t\tvar totalRightBoxesWidth = xPadding;","\t\t\tvar totalTopBoxesHeight = yPadding;","\t\t\tvar totalBottomBoxesHeight = yPadding;","","\t\t\t// Update, and calculate the left and right margins for the horizontal boxes","\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);","","\t\t\thelpers.each(leftBoxes, function(box) {","\t\t\t\ttotalLeftBoxesWidth += box.width;","\t\t\t});","","\t\t\thelpers.each(rightBoxes, function(box) {","\t\t\t\ttotalRightBoxesWidth += box.width;","\t\t\t});","","\t\t\t// Set the Left and Right margins for the horizontal boxes","\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);","","\t\t\t// Function to fit a box","\t\t\tfunction fitBox(box) {","\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBoxSize) {","\t\t\t\t\treturn minBoxSize.box === box;","\t\t\t\t});","","\t\t\t\tif (minBoxSize) {","\t\t\t\t\tif (box.isHorizontal()) {","\t\t\t\t\t\tvar scaleMargin = {","\t\t\t\t\t\t\tleft: totalLeftBoxesWidth,","\t\t\t\t\t\t\tright: totalRightBoxesWidth,","\t\t\t\t\t\t\ttop: 0,","\t\t\t\t\t\t\tbottom: 0","\t\t\t\t\t\t};","","\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends","\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly","\t\t\t\t\t\tbox.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);","\t\t\t\t\t} else {","\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes","\t\t\thelpers.each(topBoxes, function(box) {","\t\t\t\ttotalTopBoxesHeight += box.height;","\t\t\t});","","\t\t\thelpers.each(bottomBoxes, function(box) {","\t\t\t\ttotalBottomBoxesHeight += box.height;","\t\t\t});","","\t\t\t// Let the left layout know the final margin","\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);","","\t\t\tfunction finalFitVerticalBox(box) {","\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBoxSize) {","\t\t\t\t\treturn minBoxSize.box === box;","\t\t\t\t});","","\t\t\t\tvar scaleMargin = {","\t\t\t\t\tleft: 0,","\t\t\t\t\tright: 0,","\t\t\t\t\ttop: totalTopBoxesHeight,","\t\t\t\t\tbottom: totalBottomBoxesHeight","\t\t\t\t};","","\t\t\t\tif (minBoxSize) {","\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);","\t\t\t\t}","\t\t\t}","","\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)","\t\t\ttotalLeftBoxesWidth = xPadding;","\t\t\ttotalRightBoxesWidth = xPadding;","\t\t\ttotalTopBoxesHeight = yPadding;","\t\t\ttotalBottomBoxesHeight = yPadding;","","\t\t\thelpers.each(leftBoxes, function(box) {","\t\t\t\ttotalLeftBoxesWidth += box.width;","\t\t\t});","","\t\t\thelpers.each(rightBoxes, function(box) {","\t\t\t\ttotalRightBoxesWidth += box.width;","\t\t\t});","","\t\t\thelpers.each(topBoxes, function(box) {","\t\t\t\ttotalTopBoxesHeight += box.height;","\t\t\t});","\t\t\thelpers.each(bottomBoxes, function(box) {","\t\t\t\ttotalBottomBoxesHeight += box.height;","\t\t\t});","","\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation","\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do","\t\t\t// without calling `fit` again","\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;","\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;","","\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {","\t\t\t\thelpers.each(leftBoxes, function(box) {","\t\t\t\t\tbox.height = newMaxChartAreaHeight;","\t\t\t\t});","","\t\t\t\thelpers.each(rightBoxes, function(box) {","\t\t\t\t\tbox.height = newMaxChartAreaHeight;","\t\t\t\t});","","\t\t\t\thelpers.each(topBoxes, function(box) {","\t\t\t\t\tif (!box.options.fullWidth) {","\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;","\t\t\t\t\t}","\t\t\t\t});","","\t\t\t\thelpers.each(bottomBoxes, function(box) {","\t\t\t\t\tif (!box.options.fullWidth) {","\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;","\t\t\t\t\t}","\t\t\t\t});","","\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;","\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;","\t\t\t}","","\t\t\t// Step 7 - Position the boxes","\t\t\tvar left = xPadding;","\t\t\tvar top = yPadding;","\t\t\tvar right = 0;","\t\t\tvar bottom = 0;","","\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);","","\t\t\t// Account for chart width and height","\t\t\tleft += maxChartAreaWidth;","\t\t\ttop += maxChartAreaHeight;","","\t\t\thelpers.each(rightBoxes, placeBox);","\t\t\thelpers.each(bottomBoxes, placeBox);","","\t\t\tfunction placeBox(box) {","\t\t\t\tif (box.isHorizontal()) {","\t\t\t\t\tbox.left = box.options.fullWidth ? xPadding : totalLeftBoxesWidth;","\t\t\t\t\tbox.right = box.options.fullWidth ? width - xPadding : totalLeftBoxesWidth + maxChartAreaWidth;","\t\t\t\t\tbox.top = top;","\t\t\t\t\tbox.bottom = top + box.height;","","\t\t\t\t\t// Move to next point","\t\t\t\t\ttop = box.bottom;","","\t\t\t\t} else {","","\t\t\t\t\tbox.left = left;","\t\t\t\t\tbox.right = left + box.width;","\t\t\t\t\tbox.top = totalTopBoxesHeight;","\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;","","\t\t\t\t\t// Move to next point","\t\t\t\t\tleft = box.right;","\t\t\t\t}","\t\t\t}","","\t\t\t// Step 8","\t\t\tchartInstance.chartArea = {","\t\t\t\tleft: totalLeftBoxesWidth,","\t\t\t\ttop: totalTopBoxesHeight,","\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,","\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight","\t\t\t};","","\t\t\t// Step 9","\t\t\thelpers.each(chartAreaBoxes, function(box) {","\t\t\t\tbox.left = chartInstance.chartArea.left;","\t\t\t\tbox.top = chartInstance.chartArea.top;","\t\t\t\tbox.right = chartInstance.chartArea.right;","\t\t\t\tbox.bottom = chartInstance.chartArea.bottom;","","\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);","\t\t\t});","\t\t}","\t};","};","","},{}],28:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\tvar noop = helpers.noop;","","\tChart.defaults.global.legend = {","","\t\tdisplay: true,","\t\tposition: 'top',","\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)","\t\treverse: false,","","\t\t// a callback that will handle","\t\tonClick: function(e, legendItem) {","\t\t\tvar index = legendItem.datasetIndex;","\t\t\tvar ci = this.chart;","\t\t\tvar meta = ci.getDatasetMeta(index);","","\t\t\t// See controller.isDatasetVisible comment","\t\t\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;","","\t\t\t// We hid a dataset ... rerender the chart","\t\t\tci.update();","\t\t},","","\t\tlabels: {","\t\t\tboxWidth: 40,","\t\t\tpadding: 10,","\t\t\t// Generates labels shown in the legend","\t\t\t// Valid properties to return:","\t\t\t// text : text to display","\t\t\t// fillStyle : fill of coloured box","\t\t\t// strokeStyle: stroke of coloured box","\t\t\t// hidden : if this legend item refers to a hidden item","\t\t\t// lineCap : cap style for line","\t\t\t// lineDash","\t\t\t// lineDashOffset :","\t\t\t// lineJoin :","\t\t\t// lineWidth :","\t\t\tgenerateLabels: function(chart) {","\t\t\t\tvar data = chart.data;","\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {","\t\t\t\t\treturn {","\t\t\t\t\t\ttext: dataset.label,","\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),","\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),","\t\t\t\t\t\tlineCap: dataset.borderCapStyle,","\t\t\t\t\t\tlineDash: dataset.borderDash,","\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,","\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,","\t\t\t\t\t\tlineWidth: dataset.borderWidth,","\t\t\t\t\t\tstrokeStyle: dataset.borderColor,","","\t\t\t\t\t\t// Below is extra data used for toggling the datasets","\t\t\t\t\t\tdatasetIndex: i","\t\t\t\t\t};","\t\t\t\t}, this) : [];","\t\t\t}","\t\t}","\t};","","\tChart.Legend = Chart.Element.extend({","","\t\tinitialize: function(config) {","\t\t\thelpers.extend(this, config);","","\t\t\t// Contains hit boxes for each dataset (in dataset order)","\t\t\tthis.legendHitBoxes = [];","","\t\t\t// Are we in doughnut mode which has a different data type","\t\t\tthis.doughnutMode = false;","\t\t},","","\t\t// These methods are ordered by lifecyle. Utilities then follow.","\t\t// Any function defined here is inherited by all legend types.","\t\t// Any function can be extended by the legend type","","\t\tbeforeUpdate: noop,","\t\tupdate: function(maxWidth, maxHeight, margins) {","\t\t\tvar me = this;","","\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)","\t\t\tme.beforeUpdate();","","\t\t\t// Absorb the master measurements","\t\t\tme.maxWidth = maxWidth;","\t\t\tme.maxHeight = maxHeight;","\t\t\tme.margins = margins;","","\t\t\t// Dimensions","\t\t\tme.beforeSetDimensions();","\t\t\tme.setDimensions();","\t\t\tme.afterSetDimensions();","\t\t\t// Labels","\t\t\tme.beforeBuildLabels();","\t\t\tme.buildLabels();","\t\t\tme.afterBuildLabels();","","\t\t\t// Fit","\t\t\tme.beforeFit();","\t\t\tme.fit();","\t\t\tme.afterFit();","\t\t\t//","\t\t\tme.afterUpdate();","","\t\t\treturn me.minSize;","\t\t},","\t\tafterUpdate: noop,","","\t\t//","","\t\tbeforeSetDimensions: noop,","\t\tsetDimensions: function() {","\t\t\tvar me = this;","\t\t\t// Set the unconstrained dimension before label rotation","\t\t\tif (me.isHorizontal()) {","\t\t\t\t// Reset position before calculating rotation","\t\t\t\tme.width = me.maxWidth;","\t\t\t\tme.left = 0;","\t\t\t\tme.right = me.width;","\t\t\t} else {","\t\t\t\tme.height = me.maxHeight;","","\t\t\t\t// Reset position before calculating rotation","\t\t\t\tme.top = 0;","\t\t\t\tme.bottom = me.height;","\t\t\t}","","\t\t\t// Reset padding","\t\t\tme.paddingLeft = 0;","\t\t\tme.paddingTop = 0;","\t\t\tme.paddingRight = 0;","\t\t\tme.paddingBottom = 0;","","\t\t\t// Reset minSize","\t\t\tme.minSize = {","\t\t\t\twidth: 0,","\t\t\t\theight: 0","\t\t\t};","\t\t},","\t\tafterSetDimensions: noop,","","\t\t//","","\t\tbeforeBuildLabels: noop,","\t\tbuildLabels: function() {","\t\t\tvar me = this;","\t\t\tme.legendItems = me.options.labels.generateLabels.call(me, me.chart);","\t\t\tif(me.options.reverse){","\t\t\t\tme.legendItems.reverse();","\t\t\t}","\t\t},","\t\tafterBuildLabels: noop,","","\t\t//","","\t\tbeforeFit: noop,","\t\tfit: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar labelOpts = opts.labels;","\t\t\tvar display = opts.display;","","\t\t\tvar ctx = me.ctx;","","\t\t\tvar globalDefault = Chart.defaults.global,","\t\t\t\titemOrDefault = helpers.getValueOrDefault,","\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),","\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),","\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),","\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);","","\t\t\t// Reset hit boxes","\t\t\tvar hitboxes = me.legendHitBoxes = [];","","\t\t\tvar minSize = me.minSize;","\t\t\tvar isHorizontal = me.isHorizontal();","","\t\t\tif (isHorizontal) {","\t\t\t\tminSize.width = me.maxWidth; // fill all the width","\t\t\t\tminSize.height = display ? 10 : 0;","\t\t\t} else {","\t\t\t\tminSize.width = display ? 10 : 0;","\t\t\t\tminSize.height = me.maxHeight; // fill all the height","\t\t\t}","","\t\t\t// Increase sizes here","\t\t\tif (display) {","\t\t\t\tctx.font = labelFont;","","\t\t\t\tif (isHorizontal) {","\t\t\t\t\t// Labels","","\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one","\t\t\t\t\tvar lineWidths = me.lineWidths = [0];","\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;","","\t\t\t\t\tctx.textAlign = \"left\";","\t\t\t\t\tctx.textBaseline = 'top';","","\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {","\t\t\t\t\t\tvar width = labelOpts.boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;","\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {","\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);","\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;","\t\t\t\t\t\t}","","\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`","\t\t\t\t\t\thitboxes[i] = {","\t\t\t\t\t\t\tleft: 0,","\t\t\t\t\t\t\ttop: 0,","\t\t\t\t\t\t\twidth: width,","\t\t\t\t\t\t\theight: fontSize","\t\t\t\t\t\t};","","\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;","\t\t\t\t\t});","","\t\t\t\t\tminSize.height += totalHeight;","","\t\t\t\t} else {","\t\t\t\t\tvar vPadding = labelOpts.padding;","\t\t\t\t\tvar columnWidths = me.columnWidths = [];","\t\t\t\t\tvar totalWidth = labelOpts.padding;","\t\t\t\t\tvar currentColWidth = 0;","\t\t\t\t\tvar currentColHeight = 0;","\t\t\t\t\tvar itemHeight = fontSize + vPadding;","","\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {","\t\t\t\t\t\tvar itemWidth = labelOpts.boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;","","\t\t\t\t\t\t// If too tall, go to new column","\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {","\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;","\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width","","\t\t\t\t\t\t\tcurrentColWidth = 0;","\t\t\t\t\t\t\tcurrentColHeight = 0;","\t\t\t\t\t\t}","","\t\t\t\t\t\t// Get max width","\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);","\t\t\t\t\t\tcurrentColHeight += itemHeight;","","\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`","\t\t\t\t\t\thitboxes[i] = {","\t\t\t\t\t\t\tleft: 0,","\t\t\t\t\t\t\ttop: 0,","\t\t\t\t\t\t\twidth: itemWidth,","\t\t\t\t\t\t\theight: fontSize","\t\t\t\t\t\t};","\t\t\t\t\t});","","\t\t\t\t\ttotalWidth += currentColWidth;","\t\t\t\t\tcolumnWidths.push(currentColWidth);","\t\t\t\t\tminSize.width += totalWidth;","\t\t\t\t}","\t\t\t}","","\t\t\tme.width = minSize.width;","\t\t\tme.height = minSize.height;","\t\t},","\t\tafterFit: noop,","","\t\t// Shared Methods","\t\tisHorizontal: function() {","\t\t\treturn this.options.position === \"top\" || this.options.position === \"bottom\";","\t\t},","","\t\t// Actualy draw the legend on the canvas","\t\tdraw: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar labelOpts = opts.labels;","\t\t\tvar globalDefault = Chart.defaults.global,","\t\t\t\tlineDefault = globalDefault.elements.line,","\t\t\t\tlegendWidth = me.width,","\t\t\t\tlegendHeight = me.height,","\t\t\t\tlineWidths = me.lineWidths;","","\t\t\tif (opts.display) {","\t\t\t\tvar ctx = me.ctx,","\t\t\t\t\tcursor,","\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,","\t\t\t\t\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),","\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),","\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),","\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),","\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);","","\t\t\t\t// Canvas setup","\t\t\t\tctx.textAlign = \"left\";","\t\t\t\tctx.textBaseline = 'top';","\t\t\t\tctx.lineWidth = 0.5;","\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect","\t\t\t\tctx.fillStyle = fontColor; // render in correct colour","\t\t\t\tctx.font = labelFont;","","\t\t\t\tvar boxWidth = labelOpts.boxWidth,","\t\t\t\t\thitboxes = me.legendHitBoxes;","","\t\t\t\t// current position","\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {","\t\t\t\t\t// Set the ctx for the box","\t\t\t\t\tctx.save();","","\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);","\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);","\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);","\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);","\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);","\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);","","\t\t\t\t\tif (ctx.setLineDash) {","\t\t\t\t\t\t// IE 9 and 10 do not support line dash","\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));","\t\t\t\t\t}","","\t\t\t\t\t// Draw the box","\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);","\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);","","\t\t\t\t\tctx.restore();","\t\t\t\t};","\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {","\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);","","\t\t\t\t\tif (legendItem.hidden) {","\t\t\t\t\t\t// Strikethrough the text if hidden","\t\t\t\t\t\tctx.beginPath();","\t\t\t\t\t\tctx.lineWidth = 2;","\t\t\t\t\t\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));","\t\t\t\t\t\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));","\t\t\t\t\t\tctx.stroke();","\t\t\t\t\t}","\t\t\t\t};","","\t\t\t\t// Horizontal","\t\t\t\tvar isHorizontal = me.isHorizontal();","\t\t\t\tif (isHorizontal) {","\t\t\t\t\tcursor = {","\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),","\t\t\t\t\t\ty: me.top + labelOpts.padding,","\t\t\t\t\t\tline: 0","\t\t\t\t\t};","\t\t\t\t} else {","\t\t\t\t\tcursor = {","\t\t\t\t\t\tx: me.left + labelOpts.padding,","\t\t\t\t\t\ty: me.top,","\t\t\t\t\t\tline: 0","\t\t\t\t\t};","\t\t\t\t}","","\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;","\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {","\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,","\t\t\t\t\t\twidth = boxWidth + (fontSize / 2) + textWidth,","\t\t\t\t\t\tx = cursor.x,","\t\t\t\t\t\ty = cursor.y;","","\t\t\t\t\tif (isHorizontal) {","\t\t\t\t\t\tif (x + width >= legendWidth) {","\t\t\t\t\t\t\ty = cursor.y += fontSize + (labelOpts.padding);","\t\t\t\t\t\t\tcursor.line++;","\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);","\t\t\t\t\t\t}","\t\t\t\t\t} else {","\t\t\t\t\t\tif (y + itemHeight > me.bottom) {","\t\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;","\t\t\t\t\t\t\ty = cursor.y = me.top;","\t\t\t\t\t\t\tcursor.line++;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\t","","\t\t\t\t\tdrawLegendBox(x, y, legendItem);","","\t\t\t\t\thitboxes[i].left = x;","\t\t\t\t\thitboxes[i].top = y;","","\t\t\t\t\t// Fill the actual label","\t\t\t\t\tfillText(x, y, legendItem, textWidth);","","\t\t\t\t\tif (isHorizontal) {","\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);","\t\t\t\t\t} else {","\t\t\t\t\t\tcursor.y += itemHeight;","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t});","\t\t\t}","\t\t},","","\t\t// Handle an event","\t\thandleEvent: function(e) {","\t\t\tvar me = this;","\t\t\tvar position = helpers.getRelativePosition(e, me.chart.chart),","\t\t\t\tx = position.x,","\t\t\t\ty = position.y,","\t\t\t\topts = me.options;","","\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {","\t\t\t\t// See if we are touching one of the dataset boxes","\t\t\t\tvar lh = me.legendHitBoxes;","\t\t\t\tfor (var i = 0; i < lh.length; ++i) {","\t\t\t\t\tvar hitBox = lh[i];","","\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {","\t\t\t\t\t\t// Touching an element","\t\t\t\t\t\tif (opts.onClick) {","\t\t\t\t\t\t\topts.onClick.call(me, e, me.legendItems[i]);","\t\t\t\t\t\t}","\t\t\t\t\t\tbreak;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t});","","\t// Register the legend plugin","\tChart.plugins.register({","\t\tbeforeInit: function(chartInstance) {","\t\t\tvar opts = chartInstance.options;","\t\t\tvar legendOpts = opts.legend;","","\t\t\tif (legendOpts) {","\t\t\t\tchartInstance.legend = new Chart.Legend({","\t\t\t\t\tctx: chartInstance.chart.ctx,","\t\t\t\t\toptions: legendOpts,","\t\t\t\t\tchart: chartInstance","\t\t\t\t});","","\t\t\t\tChart.layoutService.addBox(chartInstance, chartInstance.legend);","\t\t\t}","\t\t}","\t});","};","","},{}],29:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar noop = Chart.helpers.noop;","","\t/**","\t * The plugin service singleton","\t * @namespace Chart.plugins","\t * @since 2.1.0","\t */","\tChart.plugins = {","\t\t_plugins: [],","","\t\t/**","\t\t * Registers the given plugin(s) if not already registered.","\t\t * @param {Array|Object} plugins plugin instance(s).","\t\t */","\t\tregister: function(plugins) {","\t\t\tvar p = this._plugins;","\t\t\t([]).concat(plugins).forEach(function(plugin) {","\t\t\t\tif (p.indexOf(plugin) === -1) {","\t\t\t\t\tp.push(plugin);","\t\t\t\t}","\t\t\t});","\t\t},","","\t\t/**","\t\t * Unregisters the given plugin(s) only if registered.","\t\t * @param {Array|Object} plugins plugin instance(s).","\t\t */","\t\tunregister: function(plugins) {","\t\t\tvar p = this._plugins;","\t\t\t([]).concat(plugins).forEach(function(plugin) {","\t\t\t\tvar idx = p.indexOf(plugin);","\t\t\t\tif (idx !== -1) {","\t\t\t\t\tp.splice(idx, 1);","\t\t\t\t}","\t\t\t});","\t\t},","","\t\t/**","\t\t * Remove all registered p^lugins.","\t\t * @since 2.1.5","\t\t */","\t\tclear: function() {","\t\t\tthis._plugins = [];","\t\t},","","\t\t/**","\t\t * Returns the number of registered plugins?","\t\t * @returns {Number}","\t\t * @since 2.1.5","\t\t */","\t\tcount: function() {","\t\t\treturn this._plugins.length;","\t\t},","","\t\t/**","\t\t * Returns all registered plugin intances.","\t\t * @returns {Array} array of plugin objects.","\t\t * @since 2.1.5","\t\t */","\t\tgetAll: function() {","\t\t\treturn this._plugins;","\t\t},","","\t\t/**","\t\t * Calls registered plugins on the specified extension, with the given args. This","\t\t * method immediately returns as soon as a plugin explicitly returns false. The","\t\t * returned value can be used, for instance, to interrupt the current action.","\t\t * @param {String} extension the name of the plugin method to call (e.g. 'beforeUpdate').","\t\t * @param {Array} [args] extra arguments to apply to the extension call.","\t\t * @returns {Boolean} false if any of the plugins return false, else returns true.","\t\t */","\t\tnotify: function(extension, args) {","\t\t\tvar plugins = this._plugins;","\t\t\tvar ilen = plugins.length;","\t\t\tvar i, plugin;","","\t\t\tfor (i=0; i<ilen; ++i) {","\t\t\t\tplugin = plugins[i];","\t\t\t\tif (typeof plugin[extension] === 'function') {","\t\t\t\t\tif (plugin[extension].apply(plugin, args || []) === false) {","\t\t\t\t\t\treturn false;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\treturn true;","\t\t}","\t};","","\t/**","\t * Plugin extension methods.","\t * @interface Chart.PluginBase","\t * @since 2.1.0","\t */","\tChart.PluginBase = Chart.Element.extend({","\t\t// Called at start of chart init","\t\tbeforeInit: noop,","","\t\t// Called at end of chart init","\t\tafterInit: noop,","","\t\t// Called at start of update","\t\tbeforeUpdate: noop,","","\t\t// Called at end of update","\t\tafterUpdate: noop,","","\t\t// Called at start of draw","\t\tbeforeDraw: noop,","","\t\t// Called at end of draw","\t\tafterDraw: noop,","","\t\t// Called during destroy","\t\tdestroy: noop","\t});","","\t/**","\t * Provided for backward compatibility, use Chart.plugins instead","\t * @namespace Chart.pluginService","\t * @deprecated since version 2.1.5","\t * @todo remove me at version 3","\t */","\tChart.pluginService = Chart.plugins;","};","","},{}],30:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.scale = {","\t\tdisplay: true,","\t\tposition: \"left\",","","\t\t// grid line settings","\t\tgridLines: {","\t\t\tdisplay: true,","\t\t\tcolor: \"rgba(0, 0, 0, 0.1)\",","\t\t\tlineWidth: 1,","\t\t\tdrawBorder: true,","\t\t\tdrawOnChartArea: true,","\t\t\tdrawTicks: true,","\t\t\ttickMarkLength: 10,","\t\t\tzeroLineWidth: 1,","\t\t\tzeroLineColor: \"rgba(0,0,0,0.25)\",","\t\t\toffsetGridLines: false","\t\t},","","\t\t// scale label","\t\tscaleLabel: {","\t\t\t// actual label","\t\t\tlabelString: '',","","\t\t\t// display property","\t\t\tdisplay: false","\t\t},","","\t\t// label settings","\t\tticks: {","\t\t\tbeginAtZero: false,","\t\t\tminRotation: 0,","\t\t\tmaxRotation: 50,","\t\t\tmirror: false,","\t\t\tpadding: 10,","\t\t\treverse: false,","\t\t\tdisplay: true,","\t\t\tautoSkip: true,","\t\t\tautoSkipPadding: 0,","\t\t\tlabelOffset: 0,","\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.","\t\t\tcallback: function(value) {","\t\t\t\treturn helpers.isArray(value) ? value : '' + value;","\t\t\t}","\t\t}","\t};","","\tChart.Scale = Chart.Element.extend({","","\t\t// These methods are ordered by lifecyle. Utilities then follow.","\t\t// Any function defined here is inherited by all scale types.","\t\t// Any function can be extended by the scale type","","\t\tbeforeUpdate: function() {","\t\t\thelpers.callCallback(this.options.beforeUpdate, [this]);","\t\t},","\t\tupdate: function(maxWidth, maxHeight, margins) {","\t\t\tvar me = this;","","\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)","\t\t\tme.beforeUpdate();","","\t\t\t// Absorb the master measurements","\t\t\tme.maxWidth = maxWidth;","\t\t\tme.maxHeight = maxHeight;","\t\t\tme.margins = helpers.extend({","\t\t\t\tleft: 0,","\t\t\t\tright: 0,","\t\t\t\ttop: 0,","\t\t\t\tbottom: 0","\t\t\t}, margins);","","\t\t\t// Dimensions","\t\t\tme.beforeSetDimensions();","\t\t\tme.setDimensions();","\t\t\tme.afterSetDimensions();","","\t\t\t// Data min/max","\t\t\tme.beforeDataLimits();","\t\t\tme.determineDataLimits();","\t\t\tme.afterDataLimits();","","\t\t\t// Ticks","\t\t\tme.beforeBuildTicks();","\t\t\tme.buildTicks();","\t\t\tme.afterBuildTicks();","","\t\t\tme.beforeTickToLabelConversion();","\t\t\tme.convertTicksToLabels();","\t\t\tme.afterTickToLabelConversion();","","\t\t\t// Tick Rotation","\t\t\tme.beforeCalculateTickRotation();","\t\t\tme.calculateTickRotation();","\t\t\tme.afterCalculateTickRotation();","\t\t\t// Fit","\t\t\tme.beforeFit();","\t\t\tme.fit();","\t\t\tme.afterFit();","\t\t\t//","\t\t\tme.afterUpdate();","","\t\t\treturn me.minSize;","","\t\t},","\t\tafterUpdate: function() {","\t\t\thelpers.callCallback(this.options.afterUpdate, [this]);","\t\t},","","\t\t//","","\t\tbeforeSetDimensions: function() {","\t\t\thelpers.callCallback(this.options.beforeSetDimensions, [this]);","\t\t},","\t\tsetDimensions: function() {","\t\t\tvar me = this;","\t\t\t// Set the unconstrained dimension before label rotation","\t\t\tif (me.isHorizontal()) {","\t\t\t\t// Reset position before calculating rotation","\t\t\t\tme.width = me.maxWidth;","\t\t\t\tme.left = 0;","\t\t\t\tme.right = me.width;","\t\t\t} else {","\t\t\t\tme.height = me.maxHeight;","","\t\t\t\t// Reset position before calculating rotation","\t\t\t\tme.top = 0;","\t\t\t\tme.bottom = me.height;","\t\t\t}","","\t\t\t// Reset padding","\t\t\tme.paddingLeft = 0;","\t\t\tme.paddingTop = 0;","\t\t\tme.paddingRight = 0;","\t\t\tme.paddingBottom = 0;","\t\t},","\t\tafterSetDimensions: function() {","\t\t\thelpers.callCallback(this.options.afterSetDimensions, [this]);","\t\t},","","\t\t// Data limits","\t\tbeforeDataLimits: function() {","\t\t\thelpers.callCallback(this.options.beforeDataLimits, [this]);","\t\t},","\t\tdetermineDataLimits: helpers.noop,","\t\tafterDataLimits: function() {","\t\t\thelpers.callCallback(this.options.afterDataLimits, [this]);","\t\t},","","\t\t//","\t\tbeforeBuildTicks: function() {","\t\t\thelpers.callCallback(this.options.beforeBuildTicks, [this]);","\t\t},","\t\tbuildTicks: helpers.noop,","\t\tafterBuildTicks: function() {","\t\t\thelpers.callCallback(this.options.afterBuildTicks, [this]);","\t\t},","","\t\tbeforeTickToLabelConversion: function() {","\t\t\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);","\t\t},","\t\tconvertTicksToLabels: function() {","\t\t\tvar me = this;","\t\t\t// Convert ticks to strings","\t\t\tme.ticks = me.ticks.map(function(numericalTick, index, ticks) {","\t\t\t\t\tif (me.options.ticks.userCallback) {","\t\t\t\t\t\treturn me.options.ticks.userCallback(numericalTick, index, ticks);","\t\t\t\t\t}","\t\t\t\t\treturn me.options.ticks.callback(numericalTick, index, ticks);","\t\t\t\t},","\t\t\t\tme);","\t\t},","\t\tafterTickToLabelConversion: function() {","\t\t\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);","\t\t},","","\t\t//","","\t\tbeforeCalculateTickRotation: function() {","\t\t\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);","\t\t},","\t\tcalculateTickRotation: function() {","\t\t\tvar me = this;","\t\t\tvar context = me.ctx;","\t\t\tvar globalDefaults = Chart.defaults.global;","\t\t\tvar optionTicks = me.options.ticks;","","\t\t\t//Get the width of each grid by calculating the difference","\t\t\t//between x offsets between 0 and 1.","\t\t\tvar tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);","\t\t\tvar tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);","\t\t\tvar tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);","\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);","\t\t\tcontext.font = tickLabelFont;","","\t\t\tvar firstWidth = context.measureText(me.ticks[0]).width;","\t\t\tvar lastWidth = context.measureText(me.ticks[me.ticks.length - 1]).width;","\t\t\tvar firstRotated;","","\t\t\tme.labelRotation = optionTicks.minRotation || 0;","\t\t\tme.paddingRight = 0;","\t\t\tme.paddingLeft = 0;","","\t\t\tif (me.options.display) {","\t\t\t\tif (me.isHorizontal()) {","\t\t\t\t\tme.paddingRight = lastWidth / 2 + 3;","\t\t\t\t\tme.paddingLeft = firstWidth / 2 + 3;","","\t\t\t\t\tif (!me.longestTextCache) {","\t\t\t\t\t\tme.longestTextCache = {};","\t\t\t\t\t}","\t\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickLabelFont, me.ticks, me.longestTextCache);","\t\t\t\t\tvar labelWidth = originalLabelWidth;","\t\t\t\t\tvar cosRotation;","\t\t\t\t\tvar sinRotation;","","\t\t\t\t\t// Allow 3 pixels x2 padding either side for label readability","\t\t\t\t\t// only the index matters for a dataset scale, but we want a consistent interface between scales","\t\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;","","\t\t\t\t\t//Max label rotation can be set or default to 90 - also act as a loop counter","\t\t\t\t\twhile (labelWidth > tickWidth && me.labelRotation < optionTicks.maxRotation) {","\t\t\t\t\t\tcosRotation = Math.cos(helpers.toRadians(me.labelRotation));","\t\t\t\t\t\tsinRotation = Math.sin(helpers.toRadians(me.labelRotation));","","\t\t\t\t\t\tfirstRotated = cosRotation * firstWidth;","","\t\t\t\t\t\t// We're right aligning the text now.","\t\t\t\t\t\tif (firstRotated + tickFontSize / 2 > me.yLabelWidth) {","\t\t\t\t\t\t\tme.paddingLeft = firstRotated + tickFontSize / 2;","\t\t\t\t\t\t}","","\t\t\t\t\t\tme.paddingRight = tickFontSize / 2;","","\t\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {","\t\t\t\t\t\t\t// go back one step","\t\t\t\t\t\t\tme.labelRotation--;","\t\t\t\t\t\t\tbreak;","\t\t\t\t\t\t}","","\t\t\t\t\t\tme.labelRotation++;","\t\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\tif (me.margins) {","\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);","\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);","\t\t\t}","\t\t},","\t\tafterCalculateTickRotation: function() {","\t\t\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);","\t\t},","","\t\t//","","\t\tbeforeFit: function() {","\t\t\thelpers.callCallback(this.options.beforeFit, [this]);","\t\t},","\t\tfit: function() {","\t\t\tvar me = this;","\t\t\t// Reset","\t\t\tvar minSize = me.minSize = {","\t\t\t\twidth: 0,","\t\t\t\theight: 0","\t\t\t};","","\t\t\tvar opts = me.options;","\t\t\tvar globalDefaults = Chart.defaults.global;","\t\t\tvar tickOpts = opts.ticks;","\t\t\tvar scaleLabelOpts = opts.scaleLabel;","\t\t\tvar display = opts.display;","\t\t\tvar isHorizontal = me.isHorizontal();","","\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);","\t\t\tvar tickFontStyle = helpers.getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);","\t\t\tvar tickFontFamily = helpers.getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);","\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);","","\t\t\tvar scaleLabelFontSize = helpers.getValueOrDefault(scaleLabelOpts.fontSize, globalDefaults.defaultFontSize);","\t\t\tvar scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabelOpts.fontStyle, globalDefaults.defaultFontStyle);","\t\t\tvar scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabelOpts.fontFamily, globalDefaults.defaultFontFamily);","\t\t\tvar scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);","","\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;","","\t\t\t// Width","\t\t\tif (isHorizontal) {","\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale","\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;","\t\t\t} else {","\t\t\t\tminSize.width = display ? tickMarkLength : 0;","\t\t\t}","","\t\t\t// height","\t\t\tif (isHorizontal) {","\t\t\t\tminSize.height = display ? tickMarkLength : 0;","\t\t\t} else {","\t\t\t\tminSize.height = me.maxHeight; // fill all the height","\t\t\t}","","\t\t\t// Are we showing a title for the scale?","\t\t\tif (scaleLabelOpts.display && display) {","\t\t\t\tif (isHorizontal) {","\t\t\t\t\tminSize.height += (scaleLabelFontSize * 1.5);","\t\t\t\t} else {","\t\t\t\t\tminSize.width += (scaleLabelFontSize * 1.5);","\t\t\t\t}","\t\t\t}","","\t\t\tif (tickOpts.display && display) {","\t\t\t\t// Don't bother fitting the ticks if we are not showing them","\t\t\t\tif (!me.longestTextCache) {","\t\t\t\t\tme.longestTextCache = {};","\t\t\t\t}","","\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickLabelFont, me.ticks, me.longestTextCache);","\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);","\t\t\t\tvar lineSpace = tickFontSize * 0.5;","","\t\t\t\tif (isHorizontal) {","\t\t\t\t\t// A horizontal axis is more constrained by the height.","\t\t\t\t\tme.longestLabelWidth = largestTextWidth;","","\t\t\t\t\t// TODO - improve this calculation","\t\t\t\t\tvar labelHeight = (Math.sin(helpers.toRadians(me.labelRotation)) * me.longestLabelWidth) + (tickFontSize * tallestLabelHeightInLines) + (lineSpace * tallestLabelHeightInLines);","","\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);","\t\t\t\t\tme.ctx.font = tickLabelFont;","","\t\t\t\t\tvar firstLabelWidth = me.ctx.measureText(me.ticks[0]).width;","\t\t\t\t\tvar lastLabelWidth = me.ctx.measureText(me.ticks[me.ticks.length - 1]).width;","","\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated","\t\t\t\t\t// by the font height","\t\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.labelRotation));","\t\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.labelRotation));","\t\t\t\t\tme.paddingLeft = me.labelRotation !== 0 ? (cosRotation * firstLabelWidth) + 3 : firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges","\t\t\t\t\tme.paddingRight = me.labelRotation !== 0 ? (sinRotation * (tickFontSize / 2)) + 3 : lastLabelWidth / 2 + 3; // when rotated","\t\t\t\t} else {","\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first","\t\t\t\t\tvar maxLabelWidth = me.maxWidth - minSize.width;","","\t\t\t\t\t// Account for padding","\t\t\t\t\tvar mirror = tickOpts.mirror;","\t\t\t\t\tif (!mirror) {","\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;","\t\t\t\t\t} else {","\t\t\t\t\t\t// If mirrored text is on the inside so don't expand","\t\t\t\t\t\tlargestTextWidth = 0;","\t\t\t\t\t}","","\t\t\t\t\tif (largestTextWidth < maxLabelWidth) {","\t\t\t\t\t\t// We don't need all the room","\t\t\t\t\t\tminSize.width += largestTextWidth;","\t\t\t\t\t} else {","\t\t\t\t\t\t// Expand to max size","\t\t\t\t\t\tminSize.width = me.maxWidth;","\t\t\t\t\t}","","\t\t\t\t\tme.paddingTop = tickFontSize / 2;","\t\t\t\t\tme.paddingBottom = tickFontSize / 2;","\t\t\t\t}","\t\t\t}","","\t\t\tif (me.margins) {","\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);","\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);","\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);","\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);","\t\t\t}","","\t\t\tme.width = minSize.width;","\t\t\tme.height = minSize.height;","","\t\t},","\t\tafterFit: function() {","\t\t\thelpers.callCallback(this.options.afterFit, [this]);","\t\t},","","\t\t// Shared Methods","\t\tisHorizontal: function() {","\t\t\treturn this.options.position === \"top\" || this.options.position === \"bottom\";","\t\t},","\t\tisFullWidth: function() {","\t\t\treturn (this.options.fullWidth);","\t\t},","","\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not","\t\tgetRightValue: function getRightValue(rawValue) {","\t\t\t// Null and undefined values first","\t\t\tif (rawValue === null || typeof(rawValue) === 'undefined') {","\t\t\t\treturn NaN;","\t\t\t}","\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number","\t\t\tif (typeof(rawValue) === 'number' && isNaN(rawValue)) {","\t\t\t\treturn NaN;","\t\t\t}","\t\t\t// If it is in fact an object, dive in one more level","\t\t\tif (typeof(rawValue) === \"object\") {","\t\t\t\tif ((rawValue instanceof Date) || (rawValue.isValid)) {","\t\t\t\t\treturn rawValue;","\t\t\t\t} else {","\t\t\t\t\treturn getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);","\t\t\t\t}","\t\t\t}","","\t\t\t// Value is good, return it","\t\t\treturn rawValue;","\t\t},","","\t\t// Used to get the value to display in the tooltip for the data at the given index","\t\t// function getLabelForIndex(index, datasetIndex)","\t\tgetLabelForIndex: helpers.noop,","","\t\t// Used to get data value locations.  Value can either be an index or a numerical value","\t\tgetPixelForValue: helpers.noop,","","\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue","\t\tgetValueForPixel: helpers.noop,","","\t\t// Used for tick location, should","\t\tgetPixelForTick: function(index, includeOffset) {","\t\t\tvar me = this;","\t\t\tif (me.isHorizontal()) {","\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);","\t\t\t\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);","\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;","","\t\t\t\tif (includeOffset) {","\t\t\t\t\tpixel += tickWidth / 2;","\t\t\t\t}","","\t\t\t\tvar finalVal = me.left + Math.round(pixel);","\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;","\t\t\t\treturn finalVal;","\t\t\t} else {","\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);","\t\t\t\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));","\t\t\t}","\t\t},","","\t\t// Utility for getting the pixel location of a percentage of scale","\t\tgetPixelForDecimal: function(decimal /*, includeOffset*/ ) {","\t\t\tvar me = this;","\t\t\tif (me.isHorizontal()) {","\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);","\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;","","\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);","\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;","\t\t\t\treturn finalVal;","\t\t\t} else {","\t\t\t\treturn me.top + (decimal * me.height);","\t\t\t}","\t\t},","","\t\tgetBasePixel: function() {","\t\t\tvar me = this;","\t\t\tvar min = me.min;","\t\t\tvar max = me.max;","","\t\t\treturn me.getPixelForValue(","\t\t\t\tme.beginAtZero? 0:","\t\t\t\tmin < 0 && max < 0? max :","\t\t\t\tmin > 0 && max > 0? min :","\t\t\t\t0);","\t\t},","","\t\t// Actualy draw the scale on the canvas","\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on","\t\tdraw: function(chartArea) {","\t\t\tvar me = this;","\t\t\tvar options = me.options;","\t\t\tif (!options.display) {","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar context = me.ctx;","\t\t\tvar globalDefaults = Chart.defaults.global;","\t\t\tvar optionTicks = options.ticks;","\t\t\tvar gridLines = options.gridLines;","\t\t\tvar scaleLabel = options.scaleLabel;","","\t\t\tvar isRotated = me.labelRotation !== 0;","\t\t\tvar skipRatio;","\t\t\tvar useAutoskipper = optionTicks.autoSkip;","\t\t\tvar isHorizontal = me.isHorizontal();","","\t\t\t// figure out the maximum number of gridlines to show","\t\t\tvar maxTicks;","\t\t\tif (optionTicks.maxTicksLimit) {","\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;","\t\t\t}","","\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);","\t\t\tvar tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);","\t\t\tvar tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);","\t\t\tvar tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);","\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);","\t\t\tvar tl = gridLines.tickMarkLength;","","\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);","\t\t\tvar scaleLabelFontSize = helpers.getValueOrDefault(scaleLabel.fontSize, globalDefaults.defaultFontSize);","\t\t\tvar scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabel.fontStyle, globalDefaults.defaultFontStyle);","\t\t\tvar scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabel.fontFamily, globalDefaults.defaultFontFamily);","\t\t\tvar scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);","","\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);","\t\t\tvar cosRotation = Math.cos(labelRotationRadians);","\t\t\tvar sinRotation = Math.sin(labelRotationRadians);","\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;","\t\t\tvar rotatedLabelHeight = tickFontSize * sinRotation;","","\t\t\t// Make sure we draw text in the correct color and font","\t\t\tcontext.fillStyle = tickFontColor;","","\t\t\tvar itemsToDraw = [];","","\t\t\tif (isHorizontal) {","\t\t\t\tskipRatio = false;","","                // Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation","                // See #2584","                if (isRotated) {","                    longestRotatedLabel /= 2;","                }","","\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {","\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));","\t\t\t\t}","","\t\t\t\t// if they defined a max number of optionTicks,","\t\t\t\t// increase skipRatio until that number is met","\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {","\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {","\t\t\t\t\t\tif (!skipRatio) {","\t\t\t\t\t\t\tskipRatio = 1;","\t\t\t\t\t\t}","\t\t\t\t\t\tskipRatio += 1;","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tif (!useAutoskipper) {","\t\t\t\t\tskipRatio = false;","\t\t\t\t}","\t\t\t}","","","\t\t\tvar xTickStart = options.position === \"right\" ? me.left : me.right - tl;","\t\t\tvar xTickEnd = options.position === \"right\" ? me.left + tl : me.right;","\t\t\tvar yTickStart = options.position === \"bottom\" ? me.top : me.bottom - tl;","\t\t\tvar yTickEnd = options.position === \"bottom\" ? me.top + tl : me.bottom;","","\t\t\thelpers.each(me.ticks, function(label, index) {","\t\t\t\t// If the callback returned a null or undefined value, do not draw this line","\t\t\t\tif (label === undefined || label === null) {","\t\t\t\t\treturn;","\t\t\t\t}","","\t\t\t\tvar isLastTick = me.ticks.length === index + 1;","","\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before","\t\t\t\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);","\t\t\t\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {","\t\t\t\t\treturn;","\t\t\t\t}","","\t\t\t\tvar lineWidth, lineColor;","\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {","\t\t\t\t\t// Draw the first index specially","\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;","\t\t\t\t\tlineColor = gridLines.zeroLineColor;","\t\t\t\t} else  {","\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);","\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);","\t\t\t\t}","","\t\t\t\t// Common properties","\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;","\t\t\t\tvar textAlign, textBaseline = 'middle';","","\t\t\t\tif (isHorizontal) {","\t\t\t\t\tif (!isRotated) {","\t\t\t\t\t\ttextBaseline = options.position === 'top' ? 'bottom' : 'top';","\t\t\t\t\t}","","\t\t\t\t\ttextAlign = isRotated ? 'right' : 'center';","","\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines","\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)","\t\t\t\t\tlabelY = (isRotated) ? me.top + 12 : options.position === 'top' ? me.bottom - tl : me.top + tl;","","\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;","\t\t\t\t\tty1 = yTickStart;","\t\t\t\t\tty2 = yTickEnd;","\t\t\t\t\ty1 = chartArea.top;","\t\t\t\t\ty2 = chartArea.bottom;","\t\t\t\t} else {","\t\t\t\t\tif (options.position === 'left') {","\t\t\t\t\t\tif (optionTicks.mirror) {","\t\t\t\t\t\t\tlabelX = me.right + optionTicks.padding;","\t\t\t\t\t\t\ttextAlign = 'left';","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tlabelX = me.right - optionTicks.padding;","\t\t\t\t\t\t\ttextAlign = 'right';","\t\t\t\t\t\t}","\t\t\t\t\t} else {","\t\t\t\t\t\t// right side","\t\t\t\t\t\tif (optionTicks.mirror) {","\t\t\t\t\t\t\tlabelX = me.left - optionTicks.padding;","\t\t\t\t\t\t\ttextAlign = 'right';","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tlabelX = me.left + optionTicks.padding;","\t\t\t\t\t\t\ttextAlign = 'left';","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines","\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);","\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);","","\t\t\t\t\ttx1 = xTickStart;","\t\t\t\t\ttx2 = xTickEnd;","\t\t\t\t\tx1 = chartArea.left;","\t\t\t\t\tx2 = chartArea.right;","\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;","\t\t\t\t}","","\t\t\t\titemsToDraw.push({","\t\t\t\t\ttx1: tx1,","\t\t\t\t\tty1: ty1,","\t\t\t\t\ttx2: tx2,","\t\t\t\t\tty2: ty2,","\t\t\t\t\tx1: x1,","\t\t\t\t\ty1: y1,","\t\t\t\t\tx2: x2,","\t\t\t\t\ty2: y2,","\t\t\t\t\tlabelX: labelX,","\t\t\t\t\tlabelY: labelY,","\t\t\t\t\tglWidth: lineWidth,","\t\t\t\t\tglColor: lineColor,","\t\t\t\t\trotation: -1 * labelRotationRadians,","\t\t\t\t\tlabel: label,","\t\t\t\t\ttextBaseline: textBaseline,","\t\t\t\t\ttextAlign: textAlign","\t\t\t\t});","\t\t\t});","","\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places","\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {","\t\t\t\tif (gridLines.display) {","\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;","\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;","","\t\t\t\t\tcontext.beginPath();","","\t\t\t\t\tif (gridLines.drawTicks) {","\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);","\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);","\t\t\t\t\t}","","\t\t\t\t\tif (gridLines.drawOnChartArea) {","\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);","\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);","\t\t\t\t\t}","","\t\t\t\t\tcontext.stroke();","\t\t\t\t}","","\t\t\t\tif (optionTicks.display) {","\t\t\t\t\tcontext.save();","\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);","\t\t\t\t\tcontext.rotate(itemToDraw.rotation);","\t\t\t\t\tcontext.font = tickLabelFont;","\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;","\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;","","\t\t\t\t\tvar label = itemToDraw.label;","\t\t\t\t\tif (helpers.isArray(label)) {","\t\t\t\t\t\tfor (var i = 0, y = 0; i < label.length; ++i) {","\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..","\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);","\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320","\t\t\t\t\t\t\ty += (tickFontSize * 1.5);","\t\t\t\t\t\t}","\t\t\t\t\t} else {","\t\t\t\t\t\tcontext.fillText(label, 0, 0);","\t\t\t\t\t}","\t\t\t\t\tcontext.restore();","\t\t\t\t}","\t\t\t});","","\t\t\tif (scaleLabel.display) {","\t\t\t\t// Draw the scale label","\t\t\t\tvar scaleLabelX;","\t\t\t\tvar scaleLabelY;","\t\t\t\tvar rotation = 0;","","\t\t\t\tif (isHorizontal) {","\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width","\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFontSize / 2) : me.top + (scaleLabelFontSize / 2);","\t\t\t\t} else {","\t\t\t\t\tvar isLeft = options.position === 'left';","\t\t\t\t\tscaleLabelX = isLeft ? me.left + (scaleLabelFontSize / 2) : me.right - (scaleLabelFontSize / 2);","\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);","\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;","\t\t\t\t}","\t\t\t\t","\t\t\t\tcontext.save();","\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);","\t\t\t\tcontext.rotate(rotation);","\t\t\t\tcontext.textAlign = 'center';","\t\t\t\tcontext.textBaseline = 'middle';","\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour","\t\t\t\tcontext.font = scaleLabelFont;","\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);","\t\t\t\tcontext.restore();","\t\t\t}","","\t\t\tif (gridLines.drawBorder) {","\t\t\t\t// Draw the line at the edge of the axis","\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);","\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);","\t\t\t\tvar x1 = me.left,","\t\t\t\t\tx2 = me.right,","\t\t\t\t\ty1 = me.top,","\t\t\t\t\ty2 = me.bottom;","","\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);","\t\t\t\tif (isHorizontal) {","\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;","\t\t\t\t\ty1 += aliasPixel;","\t\t\t\t\ty2 += aliasPixel;","\t\t\t\t} else {","\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;","\t\t\t\t\tx1 += aliasPixel;","\t\t\t\t\tx2 += aliasPixel;","\t\t\t\t}","","\t\t\t\tcontext.beginPath();","\t\t\t\tcontext.moveTo(x1, y1);","\t\t\t\tcontext.lineTo(x2, y2);","\t\t\t\tcontext.stroke();","\t\t\t}","\t\t}","\t});","};","","},{}],31:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.scaleService = {","\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then","\t\t// use the new chart options to grab the correct scale","\t\tconstructors: {},","\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support","\t\t// old browsers","","\t\t// Scale config defaults","\t\tdefaults: {},","\t\tregisterScaleType: function(type, scaleConstructor, defaults) {","\t\t\tthis.constructors[type] = scaleConstructor;","\t\t\tthis.defaults[type] = helpers.clone(defaults);","\t\t},","\t\tgetScaleConstructor: function(type) {","\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;","\t\t},","\t\tgetScaleDefaults: function(type) {","\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones","\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};","\t\t},","\t\tupdateScaleDefaults: function(type, additions) {","\t\t\tvar defaults = this.defaults;","\t\t\tif (defaults.hasOwnProperty(type)) {","\t\t\t\tdefaults[type] = helpers.extend(defaults[type], additions);","\t\t\t}","\t\t},","\t\taddScalesToLayout: function(chartInstance) {","\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly","\t\t\thelpers.each(chartInstance.scales, function(scale) {","\t\t\t\tChart.layoutService.addBox(chartInstance, scale);","\t\t\t});","\t\t}","\t};","};","},{}],32:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.global.title = {","\t\tdisplay: false,","\t\tposition: 'top',","\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)","","\t\tfontStyle: 'bold',","\t\tpadding: 10,","","\t\t// actual title","\t\ttext: ''","\t};","","\tvar noop = helpers.noop;","\tChart.Title = Chart.Element.extend({","","\t\tinitialize: function(config) {","\t\t\tvar me = this;","\t\t\thelpers.extend(me, config);","\t\t\tme.options = helpers.configMerge(Chart.defaults.global.title, config.options);","","\t\t\t// Contains hit boxes for each dataset (in dataset order)","\t\t\tme.legendHitBoxes = [];","\t\t},","","\t\t// These methods are ordered by lifecyle. Utilities then follow.","","\t\tbeforeUpdate: function () {","\t\t\tvar chartOpts = this.chart.options;","\t\t\tif (chartOpts && chartOpts.title) {","\t\t\t\tthis.options = helpers.configMerge(Chart.defaults.global.title, chartOpts.title);","\t\t\t}","\t\t},","\t\tupdate: function(maxWidth, maxHeight, margins) {","\t\t\tvar me = this;","","\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)","\t\t\tme.beforeUpdate();","","\t\t\t// Absorb the master measurements","\t\t\tme.maxWidth = maxWidth;","\t\t\tme.maxHeight = maxHeight;","\t\t\tme.margins = margins;","","\t\t\t// Dimensions","\t\t\tme.beforeSetDimensions();","\t\t\tme.setDimensions();","\t\t\tme.afterSetDimensions();","\t\t\t// Labels","\t\t\tme.beforeBuildLabels();","\t\t\tme.buildLabels();","\t\t\tme.afterBuildLabels();","","\t\t\t// Fit","\t\t\tme.beforeFit();","\t\t\tme.fit();","\t\t\tme.afterFit();","\t\t\t//","\t\t\tme.afterUpdate();","","\t\t\treturn me.minSize;","","\t\t},","\t\tafterUpdate: noop,","","\t\t//","","\t\tbeforeSetDimensions: noop,","\t\tsetDimensions: function() {","\t\t\tvar me = this;","\t\t\t// Set the unconstrained dimension before label rotation","\t\t\tif (me.isHorizontal()) {","\t\t\t\t// Reset position before calculating rotation","\t\t\t\tme.width = me.maxWidth;","\t\t\t\tme.left = 0;","\t\t\t\tme.right = me.width;","\t\t\t} else {","\t\t\t\tme.height = me.maxHeight;","","\t\t\t\t// Reset position before calculating rotation","\t\t\t\tme.top = 0;","\t\t\t\tme.bottom = me.height;","\t\t\t}","","\t\t\t// Reset padding","\t\t\tme.paddingLeft = 0;","\t\t\tme.paddingTop = 0;","\t\t\tme.paddingRight = 0;","\t\t\tme.paddingBottom = 0;","","\t\t\t// Reset minSize","\t\t\tme.minSize = {","\t\t\t\twidth: 0,","\t\t\t\theight: 0","\t\t\t};","\t\t},","\t\tafterSetDimensions: noop,","","\t\t//","","\t\tbeforeBuildLabels: noop,","\t\tbuildLabels: noop,","\t\tafterBuildLabels: noop,","","\t\t//","","\t\tbeforeFit: noop,","\t\tfit: function() {","","\t\t\tvar me = this,","\t\t\t\tctx = me.ctx,","\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,","\t\t\t\topts = me.options,","\t\t\t\tglobalDefaults = Chart.defaults.global,","\t\t\t\tdisplay = opts.display,","\t\t\t\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),","\t\t\t\tminSize = me.minSize;","","\t\t\tif (me.isHorizontal()) {","\t\t\t\tminSize.width = me.maxWidth; // fill all the width","\t\t\t\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;","\t\t\t} else {","\t\t\t\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;","\t\t\t\tminSize.height = me.maxHeight; // fill all the height","\t\t\t}","","\t\t\tme.width = minSize.width;","\t\t\tme.height = minSize.height;","","\t\t},","\t\tafterFit: noop,","","\t\t// Shared Methods","\t\tisHorizontal: function() {","\t\t\tvar pos = this.options.position;","\t\t\treturn pos === \"top\" || pos === \"bottom\";","\t\t},","","\t\t// Actualy draw the title block on the canvas","\t\tdraw: function() {","\t\t\tvar me = this,","\t\t\t\tctx = me.ctx,","\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,","\t\t\t\topts = me.options,","\t\t\t\tglobalDefaults = Chart.defaults.global;","","\t\t\tif (opts.display) {","\t\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),","\t\t\t\t\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),","\t\t\t\t\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),","\t\t\t\t\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),","\t\t\t\t\trotation = 0,","\t\t\t\t\ttitleX,","\t\t\t\t\ttitleY,","\t\t\t\t\ttop = me.top,","\t\t\t\t\tleft = me.left,","\t\t\t\t\tbottom = me.bottom,","\t\t\t\t\tright = me.right;","","\t\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour","\t\t\t\tctx.font = titleFont;","","\t\t\t\t// Horizontal","\t\t\t\tif (me.isHorizontal()) {","\t\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width","\t\t\t\t\ttitleY = top + ((bottom - top) / 2); // midpoint of the height","\t\t\t\t} else {","\t\t\t\t\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);","\t\t\t\t\ttitleY = top + ((bottom - top) / 2);","\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);","\t\t\t\t}","","\t\t\t\tctx.save();","\t\t\t\tctx.translate(titleX, titleY);","\t\t\t\tctx.rotate(rotation);","\t\t\t\tctx.textAlign = 'center';","\t\t\t\tctx.textBaseline = 'middle';","\t\t\t\tctx.fillText(opts.text, 0, 0);","\t\t\t\tctx.restore();","\t\t\t}","\t\t}","\t});","","\t// Register the title plugin","\tChart.plugins.register({","\t\tbeforeInit: function(chartInstance) {","\t\t\tvar opts = chartInstance.options;","\t\t\tvar titleOpts = opts.title;","","\t\t\tif (titleOpts) {","\t\t\t\tchartInstance.titleBlock = new Chart.Title({","\t\t\t\t\tctx: chartInstance.chart.ctx,","\t\t\t\t\toptions: titleOpts,","\t\t\t\t\tchart: chartInstance","\t\t\t\t});","","\t\t\t\tChart.layoutService.addBox(chartInstance, chartInstance.titleBlock);","\t\t\t}","\t\t}","\t});","};","","},{}],33:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tChart.defaults.global.tooltips = {","\t\tenabled: true,","\t\tcustom: null,","\t\tmode: 'single',","\t\tbackgroundColor: \"rgba(0,0,0,0.8)\",","\t\ttitleFontStyle: \"bold\",","\t\ttitleSpacing: 2,","\t\ttitleMarginBottom: 6,","\t\ttitleFontColor: \"#fff\",","\t\ttitleAlign: \"left\",","\t\tbodySpacing: 2,","\t\tbodyFontColor: \"#fff\",","\t\tbodyAlign: \"left\",","\t\tfooterFontStyle: \"bold\",","\t\tfooterSpacing: 2,","\t\tfooterMarginTop: 6,","\t\tfooterFontColor: \"#fff\",","\t\tfooterAlign: \"left\",","\t\tyPadding: 6,","\t\txPadding: 6,","\t\tyAlign : 'center',","\t\txAlign : 'center',","\t\tcaretSize: 5,","\t\tcornerRadius: 6,","\t\tmultiKeyBackground: '#fff',","\t\tcallbacks: {","\t\t\t// Args are: (tooltipItems, data)","\t\t\tbeforeTitle: helpers.noop,","\t\t\ttitle: function(tooltipItems, data) {","\t\t\t\t// Pick first xLabel for now","\t\t\t\tvar title = '';","\t\t\t\tvar labels = data.labels;","\t\t\t\tvar labelCount = labels ? labels.length : 0;","","\t\t\t\tif (tooltipItems.length > 0) {","\t\t\t\t\tvar item = tooltipItems[0];","","\t\t\t\t\tif (item.xLabel) {","\t\t\t\t\t\ttitle = item.xLabel;","\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {","\t\t\t\t\t\ttitle = labels[item.index];","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\treturn title;","\t\t\t},","\t\t\tafterTitle: helpers.noop,","","\t\t\t// Args are: (tooltipItems, data)","\t\t\tbeforeBody: helpers.noop,","","\t\t\t// Args are: (tooltipItem, data)","\t\t\tbeforeLabel: helpers.noop,","\t\t\tlabel: function(tooltipItem, data) {","\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';","\t\t\t\treturn datasetLabel + ': ' + tooltipItem.yLabel;","\t\t\t},","\t\t\tlabelColor: function(tooltipItem, chartInstance) {","\t\t\t\tvar meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);","\t\t\t\tvar activeElement = meta.data[tooltipItem.index];","\t\t\t\tvar view = activeElement._view;","\t\t\t\treturn {","\t\t\t\t\tborderColor: view.borderColor,","\t\t\t\t\tbackgroundColor: view.backgroundColor","\t\t\t\t};","\t\t\t},","\t\t\tafterLabel: helpers.noop,","","\t\t\t// Args are: (tooltipItems, data)","\t\t\tafterBody: helpers.noop,","","\t\t\t// Args are: (tooltipItems, data)","\t\t\tbeforeFooter: helpers.noop,","\t\t\tfooter: helpers.noop,","\t\t\tafterFooter: helpers.noop","\t\t}","\t};","","\t// Helper to push or concat based on if the 2nd parameter is an array or not","\tfunction pushOrConcat(base, toPush) {","\t\tif (toPush) {","\t\t\tif (helpers.isArray(toPush)) {","\t\t\t\t//base = base.concat(toPush);","\t\t\t\tArray.prototype.push.apply(base, toPush);","\t\t\t} else {","\t\t\t\tbase.push(toPush);","\t\t\t}","\t\t}","","\t\treturn base;","\t}","","\tfunction getAveragePosition(elements) {","\t\tif (!elements.length) {","\t\t\treturn false;","\t\t}","","\t\tvar i, len;","\t\tvar xPositions = [];","\t\tvar yPositions = [];","","\t\tfor (i = 0, len = elements.length; i < len; ++i) {","\t\t\tvar el = elements[i];","\t\t\tif (el && el.hasValue()){","\t\t\t\tvar pos = el.tooltipPosition();","\t\t\t\txPositions.push(pos.x);","\t\t\t\tyPositions.push(pos.y);","\t\t\t}","\t\t}","","\t\tvar x = 0,","\t\t\ty = 0;","\t\tfor (i = 0, len - xPositions.length; i < len; ++i) {","\t\t\tx += xPositions[i];","\t\t\ty += yPositions[i];","\t\t}","","\t\treturn {","\t\t\tx: Math.round(x / xPositions.length),","\t\t\ty: Math.round(y / xPositions.length)","\t\t};","\t}","","\t// Private helper to create a tooltip iteam model","\t// @param element : the chart element (point, arc, bar) to create the tooltip item for","\t// @return : new tooltip item","\tfunction createTooltipItem(element) {","\t\tvar xScale = element._xScale;","\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts","\t\tvar index = element._index,","\t\t\tdatasetIndex = element._datasetIndex;","","\t\treturn {","\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',","\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',","\t\t\tindex: index,","\t\t\tdatasetIndex: datasetIndex","\t\t};","\t}","","\tChart.Tooltip = Chart.Element.extend({","\t\tinitialize: function() {","\t\t\tvar me = this;","\t\t\tvar globalDefaults = Chart.defaults.global;","\t\t\tvar tooltipOpts = me._options;","\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;","","\t\t\thelpers.extend(me, {","\t\t\t\t_model: {","\t\t\t\t\t// Positioning","\t\t\t\t\txPadding: tooltipOpts.xPadding,","\t\t\t\t\tyPadding: tooltipOpts.yPadding,","\t\t\t\t\txAlign : tooltipOpts.yAlign,","\t\t\t\t\tyAlign : tooltipOpts.xAlign,","","\t\t\t\t\t// Body","\t\t\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,","\t\t\t\t\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),","\t\t\t\t\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),","\t\t\t\t\t_bodyAlign: tooltipOpts.bodyAlign,","\t\t\t\t\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),","\t\t\t\t\tbodySpacing: tooltipOpts.bodySpacing,","","\t\t\t\t\t// Title","\t\t\t\t\ttitleFontColor: tooltipOpts.titleFontColor,","\t\t\t\t\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),","\t\t\t\t\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),","\t\t\t\t\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),","\t\t\t\t\t_titleAlign: tooltipOpts.titleAlign,","\t\t\t\t\ttitleSpacing: tooltipOpts.titleSpacing,","\t\t\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,","","\t\t\t\t\t// Footer","\t\t\t\t\tfooterFontColor: tooltipOpts.footerFontColor,","\t\t\t\t\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),","\t\t\t\t\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),","\t\t\t\t\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),","\t\t\t\t\t_footerAlign: tooltipOpts.footerAlign,","\t\t\t\t\tfooterSpacing: tooltipOpts.footerSpacing,","\t\t\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,","","\t\t\t\t\t// Appearance","\t\t\t\t\tcaretSize: tooltipOpts.caretSize,","\t\t\t\t\tcornerRadius: tooltipOpts.cornerRadius,","\t\t\t\t\tbackgroundColor: tooltipOpts.backgroundColor,","\t\t\t\t\topacity: 0,","\t\t\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground","\t\t\t\t}","\t\t\t});","\t\t},","","\t\t// Get the title","\t\t// Args are: (tooltipItem, data)","\t\tgetTitle: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me._options;","\t\t\tvar callbacks = opts.callbacks;","","\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),","\t\t\t\ttitle = callbacks.title.apply(me, arguments),","\t\t\t\tafterTitle = callbacks.afterTitle.apply(me, arguments);","","\t\t\tvar lines = [];","\t\t\tlines = pushOrConcat(lines, beforeTitle);","\t\t\tlines = pushOrConcat(lines, title);","\t\t\tlines = pushOrConcat(lines, afterTitle);","","\t\t\treturn lines;","\t\t},","","\t\t// Args are: (tooltipItem, data)","\t\tgetBeforeBody: function() {","\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);","\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];","\t\t},","","\t\t// Args are: (tooltipItem, data)","\t\tgetBody: function(tooltipItems, data) {","\t\t\tvar me = this;","\t\t\tvar callbacks = me._options.callbacks;","\t\t\tvar bodyItems = [];","","\t\t\thelpers.each(tooltipItems, function(tooltipItem) {","\t\t\t\tvar bodyItem = {","\t\t\t\t\tbefore: [],","\t\t\t\t\tlines: [],","\t\t\t\t\tafter: []","\t\t\t\t};","\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));","\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));","\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));","","\t\t\t\tbodyItems.push(bodyItem);","\t\t\t});","","\t\t\treturn bodyItems;","\t\t},","","\t\t// Args are: (tooltipItem, data)","\t\tgetAfterBody: function() {","\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);","\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];","\t\t},","","\t\t// Get the footer and beforeFooter and afterFooter lines","\t\t// Args are: (tooltipItem, data)","\t\tgetFooter: function() {","\t\t\tvar me = this;","\t\t\tvar callbacks = me._options.callbacks;","","\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);","\t\t\tvar footer = callbacks.footer.apply(me, arguments);","\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);","","\t\t\tvar lines = [];","\t\t\tlines = pushOrConcat(lines, beforeFooter);","\t\t\tlines = pushOrConcat(lines, footer);","\t\t\tlines = pushOrConcat(lines, afterFooter);","","\t\t\treturn lines;","\t\t},","","\t\tupdate: function(changed) {","\t\t\tvar me = this;","\t\t\tvar opts = me._options;","\t\t\tvar model = me._model;","\t\t\tvar active = me._active;","","\t\t\tvar data = me._data;","\t\t\tvar chartInstance = me._chartInstance;","","\t\t\tvar i, len;","","\t\t\tif (active.length) {","\t\t\t\tmodel.opacity = 1;","","\t\t\t\tvar labelColors = [],","\t\t\t\t\ttooltipPosition = getAveragePosition(active);","","\t\t\t\tvar tooltipItems = [];","\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {","\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));","\t\t\t\t}","","\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items","\t\t\t\tif (opts.itemSort) {","\t\t\t\t\ttooltipItems = tooltipItems.sort(opts.itemSort);","\t\t\t\t}","","\t\t\t\t// If there is more than one item, show color items","\t\t\t\tif (active.length > 1) {","\t\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {","\t\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));","\t\t\t\t\t});","\t\t\t\t}","","\t\t\t\t// Build the Text Lines","\t\t\t\thelpers.extend(model, {","\t\t\t\t\ttitle: me.getTitle(tooltipItems, data),","\t\t\t\t\tbeforeBody: me.getBeforeBody(tooltipItems, data),","\t\t\t\t\tbody: me.getBody(tooltipItems, data),","\t\t\t\t\tafterBody: me.getAfterBody(tooltipItems, data),","\t\t\t\t\tfooter: me.getFooter(tooltipItems, data),","\t\t\t\t\tx: Math.round(tooltipPosition.x),","\t\t\t\t\ty: Math.round(tooltipPosition.y),","\t\t\t\t\tcaretPadding: helpers.getValueOrDefault(tooltipPosition.padding, 2),","\t\t\t\t\tlabelColors: labelColors","\t\t\t\t});","","\t\t\t\t// We need to determine alignment of","\t\t\t\tvar tooltipSize = me.getTooltipSize(model);","\t\t\t\tme.determineAlignment(tooltipSize); // Smart Tooltip placement to stay on the canvas","","\t\t\t\thelpers.extend(model, me.getBackgroundPoint(model, tooltipSize));","\t\t\t} else {","\t\t\t\tme._model.opacity = 0;","\t\t\t}","","\t\t\tif (changed && opts.custom) {","\t\t\t\topts.custom.call(me, model);","\t\t\t}","","\t\t\treturn me;","\t\t},","\t\tgetTooltipSize: function getTooltipSize(vm) {","\t\t\tvar ctx = this._chart.ctx;","","\t\t\tvar size = {","\t\t\t\theight: vm.yPadding * 2, // Tooltip Padding","\t\t\t\twidth: 0","\t\t\t};","","\t\t\t// Count of all lines in the body","\t\t\tvar body = vm.body;","\t\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {","\t\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;","\t\t\t}, 0);","\t\t\tcombinedBodyLength += vm.beforeBody.length + vm.afterBody.length;","","\t\t\tvar titleLineCount = vm.title.length;","\t\t\tvar footerLineCount = vm.footer.length;","\t\t\tvar titleFontSize = vm.titleFontSize,","\t\t\t\tbodyFontSize = vm.bodyFontSize,","\t\t\t\tfooterFontSize = vm.footerFontSize;","","\t\t\tsize.height += titleLineCount * titleFontSize; // Title Lines","\t\t\tsize.height += (titleLineCount - 1) * vm.titleSpacing; // Title Line Spacing","\t\t\tsize.height += titleLineCount ? vm.titleMarginBottom : 0; // Title's bottom Margin","\t\t\tsize.height += combinedBodyLength * bodyFontSize; // Body Lines","\t\t\tsize.height += combinedBodyLength ? (combinedBodyLength - 1) * vm.bodySpacing : 0; // Body Line Spacing","\t\t\tsize.height += footerLineCount ? vm.footerMarginTop : 0; // Footer Margin","\t\t\tsize.height += footerLineCount * (footerFontSize); // Footer Lines","\t\t\tsize.height += footerLineCount ? (footerLineCount - 1) * vm.footerSpacing : 0; // Footer Line Spacing","","\t\t\t// Title width","\t\t\tvar widthPadding = 0;","\t\t\tvar maxLineWidth = function(line) {","\t\t\t\tsize.width = Math.max(size.width, ctx.measureText(line).width + widthPadding);","\t\t\t};","","\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);","\t\t\thelpers.each(vm.title, maxLineWidth);","","\t\t\t// Body width","\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);","\t\t\thelpers.each(vm.beforeBody.concat(vm.afterBody), maxLineWidth);","","\t\t\t// Body lines may include some extra width due to the color box","\t\t\twidthPadding = body.length > 1 ? (bodyFontSize + 2) : 0;","\t\t\thelpers.each(body, function(bodyItem) {","\t\t\t\thelpers.each(bodyItem.before, maxLineWidth);","\t\t\t\thelpers.each(bodyItem.lines, maxLineWidth);","\t\t\t\thelpers.each(bodyItem.after, maxLineWidth);","\t\t\t});","","\t\t\t// Reset back to 0","\t\t\twidthPadding = 0;","","\t\t\t// Footer width","\t\t\tctx.font = helpers.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);","\t\t\thelpers.each(vm.footer, maxLineWidth);","","\t\t\t// Add padding","\t\t\tsize.width += 2 * vm.xPadding;","","\t\t\treturn size;","\t\t},","\t\tdetermineAlignment: function determineAlignment(size) {","\t\t\tvar me = this;","\t\t\tvar model = me._model;","\t\t\tvar chart = me._chart;","\t\t\tvar chartArea = me._chartInstance.chartArea;","","\t\t\tif (model.y < size.height) {","\t\t\t\tmodel.yAlign = 'top';","\t\t\t} else if (model.y > (chart.height - size.height)) {","\t\t\t\tmodel.yAlign = 'bottom';","\t\t\t}","","\t\t\tvar lf, rf; // functions to determine left, right alignment","\t\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart","\t\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges","\t\t\tvar midX = (chartArea.left + chartArea.right) / 2;","\t\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;","","\t\t\tif (model.yAlign === 'center') {","\t\t\t\tlf = function(x) {","\t\t\t\t\treturn x <= midX;","\t\t\t\t};","\t\t\t\trf = function(x) {","\t\t\t\t\treturn x > midX;","\t\t\t\t};","\t\t\t} else {","\t\t\t\tlf = function(x) {","\t\t\t\t\treturn x <= (size.width / 2);","\t\t\t\t};","\t\t\t\trf = function(x) {","\t\t\t\t\treturn x >= (chart.width - (size.width / 2));","\t\t\t\t};","\t\t\t}","","\t\t\tolf = function(x) {","\t\t\t\treturn x + size.width > chart.width;","\t\t\t};","\t\t\torf = function(x) {","\t\t\t\treturn x - size.width < 0;","\t\t\t};","\t\t\tyf = function(y) {","\t\t\t\treturn y <= midY ? 'top' : 'bottom';","\t\t\t};","","\t\t\tif (lf(model.x)) {","\t\t\t\tmodel.xAlign = 'left';","","\t\t\t\t// Is tooltip too wide and goes over the right side of the chart.?","\t\t\t\tif (olf(model.x)) {","\t\t\t\t\tmodel.xAlign = 'center';","\t\t\t\t\tmodel.yAlign = yf(model.y);","\t\t\t\t}","\t\t\t} else if (rf(model.x)) {","\t\t\t\tmodel.xAlign = 'right';","","\t\t\t\t// Is tooltip too wide and goes outside left edge of canvas?","\t\t\t\tif (orf(model.x)) {","\t\t\t\t\tmodel.xAlign = 'center';","\t\t\t\t\tmodel.yAlign = yf(model.y);","\t\t\t\t}","\t\t\t}","\t\t},","\t\tgetBackgroundPoint: function getBackgroundPoint(vm, size) {","\t\t\t// Background Position","\t\t\tvar pt = {","\t\t\t\tx: vm.x,","\t\t\t\ty: vm.y","\t\t\t};","","\t\t\tvar caretSize = vm.caretSize,","\t\t\t\tcaretPadding = vm.caretPadding,","\t\t\t\tcornerRadius = vm.cornerRadius,","\t\t\t\txAlign = vm.xAlign,","\t\t\t\tyAlign = vm.yAlign,","\t\t\t\tpaddingAndSize = caretSize + caretPadding,","\t\t\t\tradiusAndPadding = cornerRadius + caretPadding;","","\t\t\tif (xAlign === 'right') {","\t\t\t\tpt.x -= size.width;","\t\t\t} else if (xAlign === 'center') {","\t\t\t\tpt.x -= (size.width / 2);","\t\t\t}","","\t\t\tif (yAlign === 'top') {","\t\t\t\tpt.y += paddingAndSize;","\t\t\t} else if (yAlign === 'bottom') {","\t\t\t\tpt.y -= size.height + paddingAndSize;","\t\t\t} else {","\t\t\t\tpt.y -= (size.height / 2);","\t\t\t}","","\t\t\tif (yAlign === 'center') {","\t\t\t\tif (xAlign === 'left') {","\t\t\t\t\tpt.x += paddingAndSize;","\t\t\t\t} else if (xAlign === 'right') {","\t\t\t\t\tpt.x -= paddingAndSize;","\t\t\t\t}","\t\t\t} else {","\t\t\t\tif (xAlign === 'left') {","\t\t\t\t\tpt.x -= radiusAndPadding;","\t\t\t\t} else if (xAlign === 'right') {","\t\t\t\t\tpt.x += radiusAndPadding;","\t\t\t\t}","\t\t\t}","","\t\t\treturn pt;","\t\t},","\t\tdrawCaret: function drawCaret(tooltipPoint, size, opacity, caretPadding) {","\t\t\tvar vm = this._view;","\t\t\tvar ctx = this._chart.ctx;","\t\t\tvar x1, x2, x3;","\t\t\tvar y1, y2, y3;","\t\t\tvar caretSize = vm.caretSize;","\t\t\tvar cornerRadius = vm.cornerRadius;","\t\t\tvar xAlign = vm.xAlign,","\t\t\t\tyAlign = vm.yAlign;","\t\t\tvar ptX = tooltipPoint.x,","\t\t\t\tptY = tooltipPoint.y;","\t\t\tvar width = size.width,","\t\t\t\theight = size.height;","","\t\t\tif (yAlign === 'center') {","\t\t\t\t// Left or right side","\t\t\t\tif (xAlign === 'left') {","\t\t\t\t\tx1 = ptX;","\t\t\t\t\tx2 = x1 - caretSize;","\t\t\t\t\tx3 = x1;","\t\t\t\t} else {","\t\t\t\t\tx1 = ptX + width;","\t\t\t\t\tx2 = x1 + caretSize;","\t\t\t\t\tx3 = x1;","\t\t\t\t}","","\t\t\t\ty2 = ptY + (height / 2);","\t\t\t\ty1 = y2 - caretSize;","\t\t\t\ty3 = y2 + caretSize;","\t\t\t} else {","\t\t\t\tif (xAlign === 'left') {","\t\t\t\t\tx1 = ptX + cornerRadius;","\t\t\t\t\tx2 = x1 + caretSize;","\t\t\t\t\tx3 = x2 + caretSize;","\t\t\t\t} else if (xAlign === 'right') {","\t\t\t\t\tx1 = ptX + width - cornerRadius;","\t\t\t\t\tx2 = x1 - caretSize;","\t\t\t\t\tx3 = x2 - caretSize;","\t\t\t\t} else {","\t\t\t\t\tx2 = ptX + (width / 2);","\t\t\t\t\tx1 = x2 - caretSize;","\t\t\t\t\tx3 = x2 + caretSize;","\t\t\t\t}","","\t\t\t\tif (yAlign === 'top') {","\t\t\t\t\ty1 = ptY;","\t\t\t\t\ty2 = y1 - caretSize;","\t\t\t\t\ty3 = y1;","\t\t\t\t} else {","\t\t\t\t\ty1 = ptY + height;","\t\t\t\t\ty2 = y1 + caretSize;","\t\t\t\t\ty3 = y1;","\t\t\t\t}","\t\t\t}","","\t\t\tvar bgColor = helpers.color(vm.backgroundColor);","\t\t\tctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();","\t\t\tctx.beginPath();","\t\t\tctx.moveTo(x1, y1);","\t\t\tctx.lineTo(x2, y2);","\t\t\tctx.lineTo(x3, y3);","\t\t\tctx.closePath();","\t\t\tctx.fill();","\t\t},","\t\tdrawTitle: function drawTitle(pt, vm, ctx, opacity) {","\t\t\tvar title = vm.title;","","\t\t\tif (title.length) {","\t\t\t\tctx.textAlign = vm._titleAlign;","\t\t\t\tctx.textBaseline = \"top\";","","\t\t\t\tvar titleFontSize = vm.titleFontSize,","\t\t\t\t\ttitleSpacing = vm.titleSpacing;","","\t\t\t\tvar titleFontColor = helpers.color(vm.titleFontColor);","\t\t\t\tctx.fillStyle = titleFontColor.alpha(opacity * titleFontColor.alpha()).rgbString();","\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);","","\t\t\t\tvar i, len;","\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {","\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);","\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing","","\t\t\t\t\tif (i + 1 === title.length) {","\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t},","\t\tdrawBody: function drawBody(pt, vm, ctx, opacity) {","\t\t\tvar bodyFontSize = vm.bodyFontSize;","\t\t\tvar bodySpacing = vm.bodySpacing;","\t\t\tvar body = vm.body;","","\t\t\tctx.textAlign = vm._bodyAlign;","\t\t\tctx.textBaseline = \"top\";","","\t\t\tvar bodyFontColor = helpers.color(vm.bodyFontColor);","\t\t\tvar textColor = bodyFontColor.alpha(opacity * bodyFontColor.alpha()).rgbString();","\t\t\tctx.fillStyle = textColor;","\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);","","\t\t\t// Before Body","\t\t\tvar xLinePadding = 0;","\t\t\tvar fillLineOfText = function(line) {","\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);","\t\t\t\tpt.y += bodyFontSize + bodySpacing;","\t\t\t};","","\t\t\t// Before body lines","\t\t\thelpers.each(vm.beforeBody, fillLineOfText);","","\t\t\tvar drawColorBoxes = body.length > 1;","\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;","","\t\t\t// Draw body lines now","\t\t\thelpers.each(body, function(bodyItem, i) {","\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);","","\t\t\t\thelpers.each(bodyItem.lines, function(line) {","\t\t\t\t\t// Draw Legend-like boxes if needed","\t\t\t\t\tif (drawColorBoxes) {","\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1","\t\t\t\t\t\tctx.fillStyle = helpers.color(vm.legendColorBackground).alpha(opacity).rgbaString();","\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);","","\t\t\t\t\t\t// Border","\t\t\t\t\t\tctx.strokeStyle = helpers.color(vm.labelColors[i].borderColor).alpha(opacity).rgbaString();","\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);","","\t\t\t\t\t\t// Inner square","\t\t\t\t\t\tctx.fillStyle = helpers.color(vm.labelColors[i].backgroundColor).alpha(opacity).rgbaString();","\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);","","\t\t\t\t\t\tctx.fillStyle = textColor;","\t\t\t\t\t}","","\t\t\t\t\tfillLineOfText(line);","\t\t\t\t});","","\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);","\t\t\t});","","\t\t\t// Reset back to 0 for after body","\t\t\txLinePadding = 0;","","\t\t\t// After body lines","\t\t\thelpers.each(vm.afterBody, fillLineOfText);","\t\t\tpt.y -= bodySpacing; // Remove last body spacing","\t\t},","\t\tdrawFooter: function drawFooter(pt, vm, ctx, opacity) {","\t\t\tvar footer = vm.footer;","","\t\t\tif (footer.length) {","\t\t\t\tpt.y += vm.footerMarginTop;","","\t\t\t\tctx.textAlign = vm._footerAlign;","\t\t\t\tctx.textBaseline = \"top\";","","\t\t\t\tvar footerFontColor = helpers.color(vm.footerFontColor);","\t\t\t\tctx.fillStyle = footerFontColor.alpha(opacity * footerFontColor.alpha()).rgbString();","\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);","","\t\t\t\thelpers.each(footer, function(line) {","\t\t\t\t\tctx.fillText(line, pt.x, pt.y);","\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;","\t\t\t\t});","\t\t\t}","\t\t},","\t\tdraw: function draw() {","\t\t\tvar ctx = this._chart.ctx;","\t\t\tvar vm = this._view;","","\t\t\tif (vm.opacity === 0) {","\t\t\t\treturn;","\t\t\t}","","\t\t\tvar tooltipSize = this.getTooltipSize(vm);","\t\t\tvar pt = {","\t\t\t\tx: vm.x,","\t\t\t\ty: vm.y","\t\t\t};","","\t\t\t// IE11/Edge does not like very small opacities, so snap to 0","\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;","","\t\t\tif (this._options.enabled) {","\t\t\t\t// Draw Background","\t\t\t\tvar bgColor = helpers.color(vm.backgroundColor);","\t\t\t\tctx.fillStyle = bgColor.alpha(opacity * bgColor.alpha()).rgbString();","\t\t\t\thelpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);","\t\t\t\tctx.fill();","","\t\t\t\t// Draw Caret","\t\t\t\tthis.drawCaret(pt, tooltipSize, opacity, vm.caretPadding);","","\t\t\t\t// Draw Title, Body, and Footer","\t\t\t\tpt.x += vm.xPadding;","\t\t\t\tpt.y += vm.yPadding;","","\t\t\t\t// Titles","\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);","","\t\t\t\t// Body","\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);","","\t\t\t\t// Footer","\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);","\t\t\t}","\t\t}","\t});","};","","},{}],34:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart, moment) {","","  var helpers = Chart.helpers,","    globalOpts = Chart.defaults.global;","","  globalOpts.elements.arc = {","    backgroundColor: globalOpts.defaultColor,","    borderColor: \"#fff\",","    borderWidth: 2","  };","","  Chart.elements.Arc = Chart.Element.extend({","    inLabelRange: function(mouseX) {","      var vm = this._view;","","      if (vm) {","        return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));","      } else {","        return false;","      }","    },","    inRange: function(chartX, chartY) {","      var vm = this._view;","","      if (vm) {","        var pointRelativePosition = helpers.getAngleFromPoint(vm, {","            x: chartX,","            y: chartY","          }),","          angle = pointRelativePosition.angle,","          distance = pointRelativePosition.distance;","","        //Sanitise angle range","        var startAngle = vm.startAngle;","        var endAngle = vm.endAngle;","        while (endAngle < startAngle) {","          endAngle += 2.0 * Math.PI;","        }","        while (angle > endAngle) {","          angle -= 2.0 * Math.PI;","        }","        while (angle < startAngle) {","          angle += 2.0 * Math.PI;","        }","","        //Check if within the range of the open/close angle","        var betweenAngles = (angle >= startAngle && angle <= endAngle),","          withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);","","        return (betweenAngles && withinRadius);","      } else {","        return false;","      }","    },","    tooltipPosition: function() {","      var vm = this._view;","","      var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),","        rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;","      return {","        x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),","        y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)","      };","    },","    draw: function() {","","      var ctx = this._chart.ctx,","        vm = this._view,","        sA = vm.startAngle,","        eA = vm.endAngle;","","      ctx.beginPath();","","      ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);","      ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);","","      ctx.closePath();","      ctx.strokeStyle = vm.borderColor;","      ctx.lineWidth = vm.borderWidth;","","      ctx.fillStyle = vm.backgroundColor;","","      ctx.fill();","      ctx.lineJoin = 'bevel';","","      if (vm.borderWidth) {","        ctx.stroke();","      }","    }","  });","};","","},{}],35:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\tvar globalDefaults = Chart.defaults.global;","","\tChart.defaults.global.elements.line = {","\t\ttension: 0.4,","\t\tbackgroundColor: globalDefaults.defaultColor,","\t\tborderWidth: 3,","\t\tborderColor: globalDefaults.defaultColor,","\t\tborderCapStyle: 'butt',","\t\tborderDash: [],","\t\tborderDashOffset: 0.0,","\t\tborderJoinStyle: 'miter',","\t\tfill: true // do we fill in the area between the line and its base axis","\t};","","\tChart.elements.Line = Chart.Element.extend({","\t\tlineToNextPoint: function(previousPoint, point, nextPoint, skipHandler, previousSkipHandler) {","\t\t\tvar me = this;","\t\t\tvar ctx = me._chart.ctx;","\t\t\tvar spanGaps = me._view ? me._view.spanGaps : false;","","\t\t\tif (point._view.skip && !spanGaps) {","\t\t\t\tskipHandler.call(me, previousPoint, point, nextPoint);","\t\t\t} else if (previousPoint._view.skip && !spanGaps) {","\t\t\t\tpreviousSkipHandler.call(me, previousPoint, point, nextPoint);","\t\t\t} else if (point._view.tension === 0) {","\t\t\t\tctx.lineTo(point._view.x, point._view.y);","\t\t\t} else {","\t\t\t\t// Line between points","\t\t\t\tctx.bezierCurveTo(","\t\t\t\t\tpreviousPoint._view.controlPointNextX,","\t\t\t\t\tpreviousPoint._view.controlPointNextY,","\t\t\t\t\tpoint._view.controlPointPreviousX,","\t\t\t\t\tpoint._view.controlPointPreviousY,","\t\t\t\t\tpoint._view.x,","\t\t\t\t\tpoint._view.y","\t\t\t\t);","\t\t\t}","\t\t},","","\t\tdraw: function() {","\t\t\tvar me = this;","","\t\t\tvar vm = me._view;","\t\t\tvar ctx = me._chart.ctx;","\t\t\tvar first = me._children[0];","\t\t\tvar last = me._children[me._children.length - 1];","","\t\t\tfunction loopBackToStart(drawLineToCenter) {","\t\t\t\tif (!first._view.skip && !last._view.skip) {","\t\t\t\t\t// Draw a bezier line from last to first","\t\t\t\t\tctx.bezierCurveTo(","\t\t\t\t\t\tlast._view.controlPointNextX,","\t\t\t\t\t\tlast._view.controlPointNextY,","\t\t\t\t\t\tfirst._view.controlPointPreviousX,","\t\t\t\t\t\tfirst._view.controlPointPreviousY,","\t\t\t\t\t\tfirst._view.x,","\t\t\t\t\t\tfirst._view.y","\t\t\t\t\t);","\t\t\t\t} else if (drawLineToCenter) {","\t\t\t\t\t// Go to center","\t\t\t\t\tctx.lineTo(me._view.scaleZero.x, me._view.scaleZero.y);","\t\t\t\t}","\t\t\t}","","\t\t\tctx.save();","","\t\t\t// If we had points and want to fill this line, do so.","\t\t\tif (me._children.length > 0 && vm.fill) {","\t\t\t\t// Draw the background first (so the border is always on top)","\t\t\t\tctx.beginPath();","","\t\t\t\thelpers.each(me._children, function(point, index) {","\t\t\t\t\tvar previous = helpers.previousItem(me._children, index);","\t\t\t\t\tvar next = helpers.nextItem(me._children, index);","","\t\t\t\t\t// First point moves to it's starting position no matter what","\t\t\t\t\tif (index === 0) {","\t\t\t\t\t\tif (me._loop) {","\t\t\t\t\t\t\tctx.moveTo(vm.scaleZero.x, vm.scaleZero.y);","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tctx.moveTo(point._view.x, vm.scaleZero);","\t\t\t\t\t\t}","","\t\t\t\t\t\tif (point._view.skip) {","\t\t\t\t\t\t\tif (!me._loop) {","\t\t\t\t\t\t\t\tctx.moveTo(next._view.x, me._view.scaleZero);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tctx.lineTo(point._view.x, point._view.y);","\t\t\t\t\t\t}","\t\t\t\t\t} else {","\t\t\t\t\t\tme.lineToNextPoint(previous, point, next, function(previousPoint, point, nextPoint) {","\t\t\t\t\t\t\tif (me._loop) {","\t\t\t\t\t\t\t\t// Go to center","\t\t\t\t\t\t\t\tctx.lineTo(me._view.scaleZero.x, me._view.scaleZero.y);","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\tctx.lineTo(previousPoint._view.x, me._view.scaleZero);","\t\t\t\t\t\t\t\tctx.moveTo(nextPoint._view.x, me._view.scaleZero);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}, function(previousPoint, point) {","\t\t\t\t\t\t\t// If we skipped the last point, draw a line to ourselves so that the fill is nice","\t\t\t\t\t\t\tctx.lineTo(point._view.x, point._view.y);","\t\t\t\t\t\t});","\t\t\t\t\t}","\t\t\t\t}, me);","","\t\t\t\t// For radial scales, loop back around to the first point","\t\t\t\tif (me._loop) {","\t\t\t\t\tloopBackToStart(true);","\t\t\t\t} else {","\t\t\t\t\t//Round off the line by going to the base of the chart, back to the start, then fill.","\t\t\t\t\tctx.lineTo(me._children[me._children.length - 1]._view.x, vm.scaleZero);","\t\t\t\t\tctx.lineTo(me._children[0]._view.x, vm.scaleZero);","\t\t\t\t}","","\t\t\t\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;","\t\t\t\tctx.closePath();","\t\t\t\tctx.fill();","\t\t\t}","","\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;","\t\t\t// Now draw the line between all the points with any borders","\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;","","\t\t\t// IE 9 and 10 do not support line dash","\t\t\tif (ctx.setLineDash) {","\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);","\t\t\t}","","\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;","\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;","\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;","\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;","\t\t\tctx.beginPath();","","\t\t\thelpers.each(me._children, function(point, index) {","\t\t\t\tvar previous = helpers.previousItem(me._children, index);","\t\t\t\tvar next = helpers.nextItem(me._children, index);","","\t\t\t\tif (index === 0) {","\t\t\t\t\tctx.moveTo(point._view.x, point._view.y);","\t\t\t\t} else {","\t\t\t\t\tme.lineToNextPoint(previous, point, next, function(previousPoint, point, nextPoint) {","\t\t\t\t\t\tctx.moveTo(nextPoint._view.x, nextPoint._view.y);","\t\t\t\t\t}, function(previousPoint, point) {","\t\t\t\t\t\t// If we skipped the last point, move up to our point preventing a line from being drawn","\t\t\t\t\t\tctx.moveTo(point._view.x, point._view.y);","\t\t\t\t\t});","\t\t\t\t}","\t\t\t}, me);","","\t\t\tif (me._loop && me._children.length > 0) {","\t\t\t\tloopBackToStart();","\t\t\t}","","\t\t\tctx.stroke();","\t\t\tctx.restore();","\t\t}","\t});","};","},{}],36:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers,","\t\tglobalOpts = Chart.defaults.global,","\t\tdefaultColor = globalOpts.defaultColor;","","\tglobalOpts.elements.point = {","\t\tradius: 3,","\t\tpointStyle: 'circle',","\t\tbackgroundColor: defaultColor,","\t\tborderWidth: 1,","\t\tborderColor: defaultColor,","\t\t// Hover","\t\thitRadius: 1,","\t\thoverRadius: 4,","\t\thoverBorderWidth: 1","\t};","","\tChart.elements.Point = Chart.Element.extend({","\t\tinRange: function(mouseX, mouseY) {","\t\t\tvar vm = this._view;","\t\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;","\t\t},","\t\tinLabelRange: function(mouseX) {","\t\t\tvar vm = this._view;","\t\t\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;","\t\t},","\t\ttooltipPosition: function() {","\t\t\tvar vm = this._view;","\t\t\treturn {","\t\t\t\tx: vm.x,","\t\t\t\ty: vm.y,","\t\t\t\tpadding: vm.radius + vm.borderWidth","\t\t\t};","\t\t},","\t\tdraw: function() {","\t\t\tvar vm = this._view;","\t\t\tvar ctx = this._chart.ctx;","\t\t\tvar pointStyle = vm.pointStyle;","\t\t\tvar radius = vm.radius;","\t\t\tvar x = vm.x;","\t\t\tvar y = vm.y;","\t\t\tvar type, edgeLength, xOffset, yOffset, height, size;","","\t\t\tif (vm.skip) {","\t\t\t\treturn;","\t\t\t}","","\t\t\tif (typeof pointStyle === 'object') {","\t\t\t\ttype = pointStyle.toString();","\t\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {","\t\t\t\t\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t}","","\t\t\tif (isNaN(radius) || radius <= 0) {","\t\t\t\treturn;","\t\t\t}","","\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;","\t\t\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);","\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;","","\t\t\tswitch (pointStyle) {","\t\t\t// Default includes circle","\t\t\tdefault:","\t\t\t\tctx.beginPath();","\t\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);","\t\t\t\tctx.closePath();","\t\t\t\tctx.fill();","\t\t\t\tbreak;","\t\t\tcase 'triangle':","\t\t\t\tctx.beginPath();","\t\t\t\tedgeLength = 3 * radius / Math.sqrt(3);","\t\t\t\theight = edgeLength * Math.sqrt(3) / 2;","\t\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);","\t\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);","\t\t\t\tctx.lineTo(x, y - 2 * height / 3);","\t\t\t\tctx.closePath();","\t\t\t\tctx.fill();","\t\t\t\tbreak;","\t\t\tcase 'rect':","\t\t\t\tsize = 1 / Math.SQRT2 * radius;","\t\t\t\tctx.fillRect(x - size, y - size, 2 * size,  2 * size);","\t\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);","\t\t\t\tbreak;","\t\t\tcase 'rectRot':","\t\t\t\tsize = 1 / Math.SQRT2 * radius;","\t\t\t\tctx.beginPath();","\t\t\t\tctx.moveTo(x - size, y);","\t\t\t\tctx.lineTo(x, y + size);","\t\t\t\tctx.lineTo(x + size, y);","\t\t\t\tctx.lineTo(x, y - size);","\t\t\t\tctx.closePath();","\t\t\t\tctx.fill();","\t\t\t\tbreak;","\t\t\tcase 'cross':","\t\t\t\tctx.beginPath();","\t\t\t\tctx.moveTo(x, y + radius);","\t\t\t\tctx.lineTo(x, y - radius);","\t\t\t\tctx.moveTo(x - radius, y);","\t\t\t\tctx.lineTo(x + radius, y);","\t\t\t\tctx.closePath();","\t\t\t\tbreak;","\t\t\tcase 'crossRot':","\t\t\t\tctx.beginPath();","\t\t\t\txOffset = Math.cos(Math.PI / 4) * radius;","\t\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;","\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);","\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);","\t\t\t\tctx.moveTo(x - xOffset, y + yOffset);","\t\t\t\tctx.lineTo(x + xOffset, y - yOffset);","\t\t\t\tctx.closePath();","\t\t\t\tbreak;","\t\t\tcase 'star':","\t\t\t\tctx.beginPath();","\t\t\t\tctx.moveTo(x, y + radius);","\t\t\t\tctx.lineTo(x, y - radius);","\t\t\t\tctx.moveTo(x - radius, y);","\t\t\t\tctx.lineTo(x + radius, y);","\t\t\t\txOffset = Math.cos(Math.PI / 4) * radius;","\t\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;","\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);","\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);","\t\t\t\tctx.moveTo(x - xOffset, y + yOffset);","\t\t\t\tctx.lineTo(x + xOffset, y - yOffset);","\t\t\t\tctx.closePath();","\t\t\t\tbreak;","\t\t\tcase 'line':","\t\t\t\tctx.beginPath();","\t\t\t\tctx.moveTo(x - radius, y);","\t\t\t\tctx.lineTo(x + radius, y);","\t\t\t\tctx.closePath();","\t\t\t\tbreak;","\t\t\tcase 'dash':","\t\t\t\tctx.beginPath();","\t\t\t\tctx.moveTo(x, y);","\t\t\t\tctx.lineTo(x + radius, y);","\t\t\t\tctx.closePath();","\t\t\t\tbreak;","\t\t\t}","","\t\t\tctx.stroke();","\t\t}","\t});","};","","},{}],37:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers,","\t\tglobalOpts = Chart.defaults.global;","","\tglobalOpts.elements.rectangle = {","\t\tbackgroundColor: globalOpts.defaultColor,","\t\tborderWidth: 0,","\t\tborderColor: globalOpts.defaultColor,","\t\tborderSkipped: 'bottom'","\t};","","\tChart.elements.Rectangle = Chart.Element.extend({","\t\tdraw: function() {","\t\t\tvar ctx = this._chart.ctx;","\t\t\tvar vm = this._view;","","\t\t\tvar halfWidth = vm.width / 2,","\t\t\t\tleftX = vm.x - halfWidth,","\t\t\t\trightX = vm.x + halfWidth,","\t\t\t\ttop = vm.base - (vm.base - vm.y),","\t\t\t\thalfStroke = vm.borderWidth / 2;","","\t\t\t// Canvas doesn't allow us to stroke inside the width so we can","\t\t\t// adjust the sizes to fit if we're setting a stroke on the line","\t\t\tif (vm.borderWidth) {","\t\t\t\tleftX += halfStroke;","\t\t\t\trightX -= halfStroke;","\t\t\t\ttop += halfStroke;","\t\t\t}","","\t\t\tctx.beginPath();","\t\t\tctx.fillStyle = vm.backgroundColor;","\t\t\tctx.strokeStyle = vm.borderColor;","\t\t\tctx.lineWidth = vm.borderWidth;","","\t\t\t// Corner points, from bottom-left to bottom-right clockwise","\t\t\t// | 1 2 |","\t\t\t// | 0 3 |","\t\t\tvar corners = [","\t\t\t\t[leftX, vm.base],","\t\t\t\t[leftX, top],","\t\t\t\t[rightX, top],","\t\t\t\t[rightX, vm.base]","\t\t\t];","","\t\t\t// Find first (starting) corner with fallback to 'bottom' ","\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];","\t\t\tvar startCorner = borders.indexOf(vm.borderSkipped, 0);","\t\t\tif (startCorner === -1)","\t\t\t\tstartCorner = 0;","","\t\t\tfunction cornerAt(index) {","\t\t\t\treturn corners[(startCorner + index) % 4];","\t\t\t}","","\t\t\t// Draw rectangle from 'startCorner'","\t\t\tctx.moveTo.apply(ctx, cornerAt(0));","\t\t\tfor (var i = 1; i < 4; i++)","\t\t\t\tctx.lineTo.apply(ctx, cornerAt(i));","","\t\t\tctx.fill();","\t\t\tif (vm.borderWidth) {","\t\t\t\tctx.stroke();","\t\t\t}","\t\t},","\t\theight: function() {","\t\t\tvar vm = this._view;","\t\t\treturn vm.base - vm.y;","\t\t},","\t\tinRange: function(mouseX, mouseY) {","\t\t\tvar vm = this._view;","\t\t\treturn vm ? ","\t\t\t\t\t(vm.y < vm.base ? ","\t\t\t\t\t\t(mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) && (mouseY >= vm.y && mouseY <= vm.base) :","\t\t\t\t\t\t(mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) && (mouseY >= vm.base && mouseY <= vm.y)) :","\t\t\t\t\tfalse;","\t\t},","\t\tinLabelRange: function(mouseX) {","\t\t\tvar vm = this._view;","\t\t\treturn vm ? (mouseX >= vm.x - vm.width / 2 && mouseX <= vm.x + vm.width / 2) : false;","\t\t},","\t\ttooltipPosition: function() {","\t\t\tvar vm = this._view;","\t\t\treturn {","\t\t\t\tx: vm.x,","\t\t\t\ty: vm.y","\t\t\t};","\t\t}","\t});","","};","},{}],38:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\t// Default config for a category scale","\tvar defaultConfig = {","\t\tposition: \"bottom\"","\t};","","\tvar DatasetScale = Chart.Scale.extend({","\t\t// Implement this so that ","\t\tdetermineDataLimits: function() {","\t\t\tvar me = this;","\t\t\tme.minIndex = 0;","\t\t\tme.maxIndex = me.chart.data.labels.length - 1;","\t\t\tvar findIndex;","","\t\t\tif (me.options.ticks.min !== undefined) {","\t\t\t\t// user specified min value","\t\t\t\tfindIndex = helpers.indexOf(me.chart.data.labels, me.options.ticks.min);","\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;","\t\t\t}","","\t\t\tif (me.options.ticks.max !== undefined) {","\t\t\t\t// user specified max value","\t\t\t\tfindIndex = helpers.indexOf(me.chart.data.labels, me.options.ticks.max);","\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;","\t\t\t}","","\t\t\tme.min = me.chart.data.labels[me.minIndex];","\t\t\tme.max = me.chart.data.labels[me.maxIndex];","\t\t},","","\t\tbuildTicks: function(index) {","\t\t\tvar me = this;","\t\t\t// If we are viewing some subset of labels, slice the original array","\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === me.chart.data.labels.length - 1) ? me.chart.data.labels : me.chart.data.labels.slice(me.minIndex, me.maxIndex + 1);","\t\t},","","\t\tgetLabelForIndex: function(index, datasetIndex) {","\t\t\treturn this.ticks[index];","\t\t},","","\t\t// Used to get data value locations.  Value can either be an index or a numerical value","\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {","\t\t\tvar me = this;","\t\t\t// 1 is added because we need the length but we have the indexes","\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);","","\t\t\tif (me.isHorizontal()) {","\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);","\t\t\t\tvar valueWidth = innerWidth / offsetAmt;","\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex)) + me.paddingLeft;","","\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {","\t\t\t\t\twidthOffset += (valueWidth / 2);","\t\t\t\t}","","\t\t\t\treturn me.left + Math.round(widthOffset);","\t\t\t} else {","\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);","\t\t\t\tvar valueHeight = innerHeight / offsetAmt;","\t\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex)) + me.paddingTop;","","\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {","\t\t\t\t\theightOffset += (valueHeight / 2);","\t\t\t\t}","","\t\t\t\treturn me.top + Math.round(heightOffset);","\t\t\t}","\t\t},","\t\tgetPixelForTick: function(index, includeOffset) {","\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);","\t\t},","\t\tgetValueForPixel: function(pixel) {","\t\t\tvar me = this;","\t\t\tvar value;","\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);","\t\t\tvar horz = me.isHorizontal();","\t\t\tvar innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);","\t\t\tvar valueDimension = innerDimension / offsetAmt;","","\t\t\tif (me.options.gridLines.offsetGridLines) {","\t\t\t\tpixel -= (valueDimension / 2);","\t\t\t}","\t\t\tpixel -= horz ? me.paddingLeft : me.paddingTop;","","\t\t\tif (pixel <= 0) {","\t\t\t\tvalue = 0;","\t\t\t} else {","\t\t\t\tvalue = Math.round(pixel / valueDimension);","\t\t\t}","","\t\t\treturn value;","\t\t}","\t});","","\tChart.scaleService.registerScaleType(\"category\", DatasetScale, defaultConfig);","","};","},{}],39:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tvar defaultConfig = {","\t\tposition: \"left\",","\t\tticks: {","\t\t\tcallback: function(tickValue, index, ticks) {","\t\t\t\t// If we have lots of ticks, don't use the ones","\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];","","\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need","\t\t\t\tif (Math.abs(delta) > 1) {","\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {","\t\t\t\t\t\t// not an integer","\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));","\t\t\t\tvar tickString = '';","","\t\t\t\tif (tickValue !== 0) {","\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);","\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places","\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);","\t\t\t\t} else {","\t\t\t\t\ttickString = '0'; // never show decimal places for 0","\t\t\t\t}","","\t\t\t\treturn tickString;","\t\t\t}","\t\t}","\t};","","\tvar LinearScale = Chart.LinearScaleBase.extend({","\t\tdetermineDataLimits: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar tickOpts = opts.ticks;","\t\t\tvar chart = me.chart;","\t\t\tvar data = chart.data;","\t\t\tvar datasets = data.datasets;","\t\t\tvar isHorizontal = me.isHorizontal();","","\t\t\tfunction IDMatches(meta) {","\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;","\t\t\t}","","\t\t\t// First Calculate the range","\t\t\tme.min = null;","\t\t\tme.max = null;","","\t\t\tif (opts.stacked) {","\t\t\t\tvar valuesPerType = {};","\t\t\t\tvar hasPositiveValues = false;","\t\t\t\tvar hasNegativeValues = false;","","\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {","\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);","\t\t\t\t\tif (valuesPerType[meta.type] === undefined) {","\t\t\t\t\t\tvaluesPerType[meta.type] = {","\t\t\t\t\t\t\tpositiveValues: [],","\t\t\t\t\t\t\tnegativeValues: []","\t\t\t\t\t\t};","\t\t\t\t\t}","","\t\t\t\t\t// Store these per type","\t\t\t\t\tvar positiveValues = valuesPerType[meta.type].positiveValues;","\t\t\t\t\tvar negativeValues = valuesPerType[meta.type].negativeValues;","","\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {","\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {","\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);","\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {","\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;","\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;","","\t\t\t\t\t\t\tif (opts.relativePoints) {","\t\t\t\t\t\t\t\tpositiveValues[index] = 100;","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\tif (value < 0) {","\t\t\t\t\t\t\t\t\thasNegativeValues = true;","\t\t\t\t\t\t\t\t\tnegativeValues[index] += value;","\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\thasPositiveValues = true;","\t\t\t\t\t\t\t\t\tpositiveValues[index] += value;","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t}","\t\t\t\t\t\t});","\t\t\t\t\t}","\t\t\t\t});","","\t\t\t\thelpers.each(valuesPerType, function(valuesForType) {","\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);","\t\t\t\t\tvar minVal = helpers.min(values);","\t\t\t\t\tvar maxVal = helpers.max(values);","\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);","\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);","\t\t\t\t});","","\t\t\t} else {","\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {","\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);","\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {","\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {","\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);","\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {","\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tif (me.min === null) {","\t\t\t\t\t\t\t\tme.min = value;","\t\t\t\t\t\t\t} else if (value < me.min) {","\t\t\t\t\t\t\t\tme.min = value;","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tif (me.max === null) {","\t\t\t\t\t\t\t\tme.max = value;","\t\t\t\t\t\t\t} else if (value > me.max) {","\t\t\t\t\t\t\t\tme.max = value;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t});","\t\t\t\t\t}","\t\t\t\t});","\t\t\t}","","\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero","\t\t\tthis.handleTickRangeOptions();","\t\t},","\t\tgetTickLimit: function() {","\t\t\tvar maxTicks;","\t\t\tvar me = this;","\t\t\tvar tickOpts = me.options.ticks;","","\t\t\tif (me.isHorizontal()) {","\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));","\t\t\t} else {","\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.","\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);","\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));","\t\t\t}","","\t\t\treturn maxTicks;","\t\t},","\t\t// Called after the ticks are built. We need ","\t\thandleDirectionalChanges: function() {","\t\t\tif (!this.isHorizontal()) {","\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array","\t\t\t\tthis.ticks.reverse();","\t\t\t}","\t\t},","\t\tgetLabelForIndex: function(index, datasetIndex) {","\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);","\t\t},","\t\t// Utils","\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {","\t\t\t// This must be called after fit has been run so that","\t\t\t//      this.left, this.top, this.right, and this.bottom have been defined","\t\t\tvar me = this;","\t\t\tvar paddingLeft = me.paddingLeft;","\t\t\tvar paddingBottom = me.paddingBottom;","\t\t\tvar start = me.start;","","\t\t\tvar rightValue = +me.getRightValue(value);","\t\t\tvar pixel;","\t\t\tvar innerDimension;","\t\t\tvar range = me.end - start;","","\t\t\tif (me.isHorizontal()) {","\t\t\t\tinnerDimension = me.width - (paddingLeft + me.paddingRight);","\t\t\t\tpixel = me.left + (innerDimension / range * (rightValue - start));","\t\t\t\treturn Math.round(pixel + paddingLeft);","\t\t\t} else {","\t\t\t\tinnerDimension = me.height - (me.paddingTop + paddingBottom);","\t\t\t\tpixel = (me.bottom - paddingBottom) - (innerDimension / range * (rightValue - start));","\t\t\t\treturn Math.round(pixel);","\t\t\t}","\t\t},","\t\tgetValueForPixel: function(pixel) {","\t\t\tvar me = this;","\t\t\tvar isHorizontal = me.isHorizontal();","\t\t\tvar paddingLeft = me.paddingLeft;","\t\t\tvar paddingBottom = me.paddingBottom;","\t\t\tvar innerDimension = isHorizontal ? me.width - (paddingLeft + me.paddingRight) : me.height - (me.paddingTop + paddingBottom);","\t\t\tvar offset = (isHorizontal ? pixel - me.left - paddingLeft : me.bottom - paddingBottom - pixel) / innerDimension;","\t\t\treturn me.start + ((me.end - me.start) * offset);","\t\t},","\t\tgetPixelForTick: function(index, includeOffset) {","\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index], null, null, includeOffset);","\t\t}","\t});","\tChart.scaleService.registerScaleType(\"linear\", LinearScale, defaultConfig);","","};","},{}],40:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers,","\t\tnoop = helpers.noop;","","\tChart.LinearScaleBase = Chart.Scale.extend({","\t\thandleTickRangeOptions: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar tickOpts = opts.ticks;","","\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,","\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart","\t\t\t// axis, they can manually override it","\t\t\tif (tickOpts.beginAtZero) {","\t\t\t\tvar minSign = helpers.sign(me.min);","\t\t\t\tvar maxSign = helpers.sign(me.max);","","\t\t\t\tif (minSign < 0 && maxSign < 0) {","\t\t\t\t\t// move the top up to 0","\t\t\t\t\tme.max = 0;","\t\t\t\t} else if (minSign > 0 && maxSign > 0) {","\t\t\t\t\t// move the botttom down to 0","\t\t\t\t\tme.min = 0;","\t\t\t\t}","\t\t\t}","","\t\t\tif (tickOpts.min !== undefined) {","\t\t\t\tme.min = tickOpts.min;","\t\t\t} else if (tickOpts.suggestedMin !== undefined) {","\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);","\t\t\t}","","\t\t\tif (tickOpts.max !== undefined) {","\t\t\t\tme.max = tickOpts.max;","\t\t\t} else if (tickOpts.suggestedMax !== undefined) {","\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);","\t\t\t}","","\t\t\tif (me.min === me.max) {","\t\t\t\tme.max++;","","\t\t\t\tif (!tickOpts.beginAtZero) {","\t\t\t\t\tme.min--;","\t\t\t\t}","\t\t\t}","\t\t},","\t\tgetTickLimit: noop,","\t\thandleDirectionalChanges: noop,","","\t\tbuildTicks: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar tickOpts = opts.ticks;","\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;","\t\t\tvar isHorizontal = me.isHorizontal();","","\t\t\tvar ticks = me.ticks = [];","","\t\t\t// Figure out what the max number of ticks we can support it is based on the size of","\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50","\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on","\t\t\t// the graph","","\t\t\tvar maxTicks = me.getTickLimit();","","\t\t\t// Make sure we always have at least 2 ticks","\t\t\tmaxTicks = Math.max(2, maxTicks);","","\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named","\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks","\t\t\t// for details.","","\t\t\tvar spacing;","\t\t\tvar fixedStepSizeSet = (tickOpts.fixedStepSize && tickOpts.fixedStepSize > 0) || (tickOpts.stepSize && tickOpts.stepSize > 0);","\t\t\tif (fixedStepSizeSet) {","\t\t\t\tspacing = getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize);","\t\t\t} else {","\t\t\t\tvar niceRange = helpers.niceNum(me.max - me.min, false);","\t\t\t\tspacing = helpers.niceNum(niceRange / (maxTicks - 1), true);","\t\t\t}","\t\t\tvar niceMin = Math.floor(me.min / spacing) * spacing;","\t\t\tvar niceMax = Math.ceil(me.max / spacing) * spacing;","\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;","","\t\t\t// If very close to our rounded value, use it.","\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {","\t\t\t\tnumSpaces = Math.round(numSpaces);","\t\t\t} else {","\t\t\t\tnumSpaces = Math.ceil(numSpaces);","\t\t\t}","","\t\t\t// Put the values into the ticks array","\t\t\tticks.push(tickOpts.min !== undefined ? tickOpts.min : niceMin);","\t\t\tfor (var j = 1; j < numSpaces; ++j) {","\t\t\t\tticks.push(niceMin + (j * spacing));","\t\t\t}","\t\t\tticks.push(tickOpts.max !== undefined ? tickOpts.max : niceMax);","","\t\t\tme.handleDirectionalChanges();","","\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the","\t\t\t// range of the scale","\t\t\tme.max = helpers.max(ticks);","\t\t\tme.min = helpers.min(ticks);","","\t\t\tif (tickOpts.reverse) {","\t\t\t\tticks.reverse();","","\t\t\t\tme.start = me.max;","\t\t\t\tme.end = me.min;","\t\t\t} else {","\t\t\t\tme.start = me.min;","\t\t\t\tme.end = me.max;","\t\t\t}","\t\t},","\t\tconvertTicksToLabels: function() {","\t\t\tvar me = this;","\t\t\tme.ticksAsNumbers = me.ticks.slice();","\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);","","\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);","\t\t},","\t});","};","},{}],41:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","","\tvar defaultConfig = {","\t\tposition: \"left\",","","\t\t// label settings","\t\tticks: {","\t\t\tcallback: function(value, index, arr) {","\t\t\t\tvar remain = value / (Math.pow(10, Math.floor(helpers.log10(value))));","","\t\t\t\tif (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === arr.length - 1) {","\t\t\t\t\treturn value.toExponential();","\t\t\t\t} else {","\t\t\t\t\treturn '';","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\tvar LogarithmicScale = Chart.Scale.extend({","\t\tdetermineDataLimits: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar tickOpts = opts.ticks;","\t\t\tvar chart = me.chart;","\t\t\tvar data = chart.data;","\t\t\tvar datasets = data.datasets;","\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;","\t\t\tvar isHorizontal = me.isHorizontal();","\t\t\tfunction IDMatches(meta) {","\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;","\t\t\t}","","\t\t\t// Calculate Range","\t\t\tme.min = null;","\t\t\tme.max = null;","","\t\t\tif (opts.stacked) {","\t\t\t\tvar valuesPerType = {};","","\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {","\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);","\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {","\t\t\t\t\t\tif (valuesPerType[meta.type] === undefined) {","\t\t\t\t\t\t\tvaluesPerType[meta.type] = [];","\t\t\t\t\t\t}","","\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {","\t\t\t\t\t\t\tvar values = valuesPerType[meta.type];","\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);","\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {","\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tvalues[index] = values[index] || 0;","","\t\t\t\t\t\t\tif (opts.relativePoints) {","\t\t\t\t\t\t\t\tvalues[index] = 100;","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing","\t\t\t\t\t\t\t\tvalues[index] += value;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t});","\t\t\t\t\t}","\t\t\t\t});","","\t\t\t\thelpers.each(valuesPerType, function(valuesForType) {","\t\t\t\t\tvar minVal = helpers.min(valuesForType);","\t\t\t\t\tvar maxVal = helpers.max(valuesForType);","\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);","\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);","\t\t\t\t});","","\t\t\t} else {","\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {","\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);","\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {","\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {","\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);","\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {","\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tif (me.min === null) {","\t\t\t\t\t\t\t\tme.min = value;","\t\t\t\t\t\t\t} else if (value < me.min) {","\t\t\t\t\t\t\t\tme.min = value;","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tif (me.max === null) {","\t\t\t\t\t\t\t\tme.max = value;","\t\t\t\t\t\t\t} else if (value > me.max) {","\t\t\t\t\t\t\t\tme.max = value;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t});","\t\t\t\t\t}","\t\t\t\t});","\t\t\t}","","\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);","\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);","","\t\t\tif (me.min === me.max) {","\t\t\t\tif (me.min !== 0 && me.min !== null) {","\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);","\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);","\t\t\t\t} else {","\t\t\t\t\tme.min = 1;","\t\t\t\t\tme.max = 10;","\t\t\t\t}","\t\t\t}","\t\t},","\t\tbuildTicks: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar tickOpts = opts.ticks;","\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;","","\t\t\t// Reset the ticks array. Later on, we will draw a grid line at these positions","\t\t\t// The array simply contains the numerical value of the spots where ticks will be","\t\t\tvar ticks = me.ticks = [];","","\t\t\t// Figure out what the max number of ticks we can support it is based on the size of","\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50","\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on","\t\t\t// the graph","","\t\t\tvar tickVal = getValueOrDefault(tickOpts.min, Math.pow(10, Math.floor(helpers.log10(me.min))));","","\t\t\twhile (tickVal < me.max) {","\t\t\t\tticks.push(tickVal);","","\t\t\t\tvar exp = Math.floor(helpers.log10(tickVal));","\t\t\t\tvar significand = Math.floor(tickVal / Math.pow(10, exp)) + 1;","","\t\t\t\tif (significand === 10) {","\t\t\t\t\tsignificand = 1;","\t\t\t\t\t++exp;","\t\t\t\t}","","\t\t\t\ttickVal = significand * Math.pow(10, exp);","\t\t\t}","","\t\t\tvar lastTick = getValueOrDefault(tickOpts.max, tickVal);","\t\t\tticks.push(lastTick);","","\t\t\tif (!me.isHorizontal()) {","\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array","\t\t\t\tticks.reverse();","\t\t\t}","","\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the","\t\t\t// range of the scale","\t\t\tme.max = helpers.max(ticks);","\t\t\tme.min = helpers.min(ticks);","","\t\t\tif (tickOpts.reverse) {","\t\t\t\tticks.reverse();","","\t\t\t\tme.start = me.max;","\t\t\t\tme.end = me.min;","\t\t\t} else {","\t\t\t\tme.start = me.min;","\t\t\t\tme.end = me.max;","\t\t\t}","\t\t},","\t\tconvertTicksToLabels: function() {","\t\t\tthis.tickValues = this.ticks.slice();","","\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);","\t\t},","\t\t// Get the correct tooltip label","\t\tgetLabelForIndex: function(index, datasetIndex) {","\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);","\t\t},","\t\tgetPixelForTick: function(index, includeOffset) {","\t\t\treturn this.getPixelForValue(this.tickValues[index], null, null, includeOffset);","\t\t},","\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {","\t\t\tvar me = this;","\t\t\tvar innerDimension;","\t\t\tvar pixel;","","\t\t\tvar start = me.start;","\t\t\tvar newVal = +me.getRightValue(value);","\t\t\tvar range = helpers.log10(me.end) - helpers.log10(start);","\t\t\tvar paddingTop = me.paddingTop;","\t\t\tvar paddingBottom = me.paddingBottom;","\t\t\tvar paddingLeft = me.paddingLeft;","","\t\t\tif (me.isHorizontal()) {","","\t\t\t\tif (newVal === 0) {","\t\t\t\t\tpixel = me.left + paddingLeft;","\t\t\t\t} else {","\t\t\t\t\tinnerDimension = me.width - (paddingLeft + me.paddingRight);","\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));","\t\t\t\t\tpixel += paddingLeft;","\t\t\t\t}","\t\t\t} else {","\t\t\t\t// Bottom - top since pixels increase downard on a screen","\t\t\t\tif (newVal === 0) {","\t\t\t\t\tpixel = me.top + paddingTop;","\t\t\t\t} else {","\t\t\t\t\tinnerDimension = me.height - (paddingTop + paddingBottom);","\t\t\t\t\tpixel = (me.bottom - paddingBottom) - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));","\t\t\t\t}","\t\t\t}","","\t\t\treturn pixel;","\t\t},","\t\tgetValueForPixel: function(pixel) {","\t\t\tvar me = this;","\t\t\tvar offset;","\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);","\t\t\tvar value;","\t\t\tvar innerDimension;","","\t\t\tif (me.isHorizontal()) {","\t\t\t\tinnerDimension = me.width - (me.paddingLeft + me.paddingRight);","\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left - me.paddingLeft) * range / innerDimension);","\t\t\t} else {","\t\t\t\tinnerDimension = me.height - (me.paddingTop + me.paddingBottom);","\t\t\t\tvalue = Math.pow(10, (me.bottom - me.paddingBottom - pixel) * range / innerDimension) / me.start;","\t\t\t}","","\t\t\treturn value;","\t\t}","\t});","\tChart.scaleService.registerScaleType(\"logarithmic\", LogarithmicScale, defaultConfig);","","};","},{}],42:[function(require,module,exports){","\"use strict\";","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\tvar globalDefaults = Chart.defaults.global;","","\tvar defaultConfig = {","\t\tdisplay: true,","","\t\t//Boolean - Whether to animate scaling the chart from the centre","\t\tanimate: true,","\t\tlineArc: false,","\t\tposition: \"chartArea\",","","\t\tangleLines: {","\t\t\tdisplay: true,","\t\t\tcolor: \"rgba(0, 0, 0, 0.1)\",","\t\t\tlineWidth: 1","\t\t},","","\t\t// label settings","\t\tticks: {","\t\t\t//Boolean - Show a backdrop to the scale label","\t\t\tshowLabelBackdrop: true,","","\t\t\t//String - The colour of the label backdrop","\t\t\tbackdropColor: \"rgba(255,255,255,0.75)\",","","\t\t\t//Number - The backdrop padding above & below the label in pixels","\t\t\tbackdropPaddingY: 2,","","\t\t\t//Number - The backdrop padding to the side of the label in pixels","\t\t\tbackdropPaddingX: 2","\t\t},","","\t\tpointLabels: {","\t\t\t//Number - Point label font size in pixels","\t\t\tfontSize: 10,","","\t\t\t//Function - Used to convert point labels","\t\t\tcallback: function(label) {","\t\t\t\treturn label;","\t\t\t}","\t\t}","\t};","","\tvar LinearRadialScale = Chart.LinearScaleBase.extend({","\t\tgetValueCount: function() {","\t\t\treturn this.chart.data.labels.length;","\t\t},","\t\tsetDimensions: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar tickOpts = opts.ticks;","\t\t\t// Set the unconstrained dimension before label rotation","\t\t\tme.width = me.maxWidth;","\t\t\tme.height = me.maxHeight;","\t\t\tme.xCenter = Math.round(me.width / 2);","\t\t\tme.yCenter = Math.round(me.height / 2);","","\t\t\tvar minSize = helpers.min([me.height, me.width]);","\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);","\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);","\t\t},","\t\tdetermineDataLimits: function() {","\t\t\tvar me = this;","\t\t\tvar chart = me.chart;","\t\t\tme.min = null;","\t\t\tme.max = null;","","","\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {","\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);","","\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {","\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);","\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {","\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t}","","\t\t\t\t\t\tif (me.min === null) {","\t\t\t\t\t\t\tme.min = value;","\t\t\t\t\t\t} else if (value < me.min) {","\t\t\t\t\t\t\tme.min = value;","\t\t\t\t\t\t}","","\t\t\t\t\t\tif (me.max === null) {","\t\t\t\t\t\t\tme.max = value;","\t\t\t\t\t\t} else if (value > me.max) {","\t\t\t\t\t\t\tme.max = value;","\t\t\t\t\t\t}","\t\t\t\t\t});","\t\t\t\t}","\t\t\t});","","\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero","\t\t\tme.handleTickRangeOptions();","\t\t},","\t\tgetTickLimit: function() {","\t\t\tvar tickOpts = this.options.ticks;","\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);","\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));","\t\t},","\t\tconvertTicksToLabels: function() {","\t\t\tvar me = this;","\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);","","\t\t\t// Point labels","\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);","\t\t},","\t\tgetLabelForIndex: function(index, datasetIndex) {","\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);","\t\t},","\t\tfit: function() {","\t\t\t/*","\t\t\t * Right, this is really confusing and there is a lot of maths going on here","\t\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9","\t\t\t *","\t\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif","\t\t\t *","\t\t\t * Solution:","\t\t\t *","\t\t\t * We assume the radius of the polygon is half the size of the canvas at first","\t\t\t * at each index we check if the text overlaps.","\t\t\t *","\t\t\t * Where it does, we store that angle and that index.","\t\t\t *","\t\t\t * After finding the largest index and angle we calculate how much we need to remove","\t\t\t * from the shape radius to move the point inwards by that x.","\t\t\t *","\t\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box","\t\t\t * along with labels.","\t\t\t *","\t\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion","\t\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.","\t\t\t *","\t\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels","\t\t\t * and position it in the most space efficient manner","\t\t\t *","\t\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif","\t\t\t */","","\t\t\tvar pointLabels = this.options.pointLabels;","\t\t\tvar pointLabelFontSize = helpers.getValueOrDefault(pointLabels.fontSize, globalDefaults.defaultFontSize);","\t\t\tvar pointLabeFontStyle = helpers.getValueOrDefault(pointLabels.fontStyle, globalDefaults.defaultFontStyle);","\t\t\tvar pointLabeFontFamily = helpers.getValueOrDefault(pointLabels.fontFamily, globalDefaults.defaultFontFamily);","\t\t\tvar pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);","","\t\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.","\t\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points","\t\t\tvar largestPossibleRadius = helpers.min([(this.height / 2 - pointLabelFontSize - 5), this.width / 2]),","\t\t\t\tpointPosition,","\t\t\t\ti,","\t\t\t\ttextWidth,","\t\t\t\thalfTextWidth,","\t\t\t\tfurthestRight = this.width,","\t\t\t\tfurthestRightIndex,","\t\t\t\tfurthestRightAngle,","\t\t\t\tfurthestLeft = 0,","\t\t\t\tfurthestLeftIndex,","\t\t\t\tfurthestLeftAngle,","\t\t\t\txProtrusionLeft,","\t\t\t\txProtrusionRight,","\t\t\t\tradiusReductionRight,","\t\t\t\tradiusReductionLeft,","\t\t\t\tmaxWidthRadius;","\t\t\tthis.ctx.font = pointLabeFont;","","\t\t\tfor (i = 0; i < this.getValueCount(); i++) {","\t\t\t\t// 5px to space the text slightly out - similar to what we do in the draw function.","\t\t\t\tpointPosition = this.getPointPosition(i, largestPossibleRadius);","\t\t\t\ttextWidth = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : '').width + 5;","\t\t\t\tif (i === 0 || i === this.getValueCount() / 2) {","\t\t\t\t\t// If we're at index zero, or exactly the middle, we're at exactly the top/bottom","\t\t\t\t\t// of the radar chart, so text will be aligned centrally, so we'll half it and compare","\t\t\t\t\t// w/left and right text sizes","\t\t\t\t\thalfTextWidth = textWidth / 2;","\t\t\t\t\tif (pointPosition.x + halfTextWidth > furthestRight) {","\t\t\t\t\t\tfurthestRight = pointPosition.x + halfTextWidth;","\t\t\t\t\t\tfurthestRightIndex = i;","\t\t\t\t\t}","\t\t\t\t\tif (pointPosition.x - halfTextWidth < furthestLeft) {","\t\t\t\t\t\tfurthestLeft = pointPosition.x - halfTextWidth;","\t\t\t\t\t\tfurthestLeftIndex = i;","\t\t\t\t\t}","\t\t\t\t} else if (i < this.getValueCount() / 2) {","\t\t\t\t\t// Less than half the values means we'll left align the text","\t\t\t\t\tif (pointPosition.x + textWidth > furthestRight) {","\t\t\t\t\t\tfurthestRight = pointPosition.x + textWidth;","\t\t\t\t\t\tfurthestRightIndex = i;","\t\t\t\t\t}","\t\t\t\t} else if (i > this.getValueCount() / 2) {","\t\t\t\t\t// More than half the values means we'll right align the text","\t\t\t\t\tif (pointPosition.x - textWidth < furthestLeft) {","\t\t\t\t\t\tfurthestLeft = pointPosition.x - textWidth;","\t\t\t\t\t\tfurthestLeftIndex = i;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\txProtrusionLeft = furthestLeft;","\t\t\txProtrusionRight = Math.ceil(furthestRight - this.width);","","\t\t\tfurthestRightAngle = this.getIndexAngle(furthestRightIndex);","\t\t\tfurthestLeftAngle = this.getIndexAngle(furthestLeftIndex);","","\t\t\tradiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);","\t\t\tradiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);","","\t\t\t// Ensure we actually need to reduce the size of the chart","\t\t\tradiusReductionRight = (helpers.isNumber(radiusReductionRight)) ? radiusReductionRight : 0;","\t\t\tradiusReductionLeft = (helpers.isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;","","\t\t\tthis.drawingArea = Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2);","\t\t\tthis.setCenterPoint(radiusReductionLeft, radiusReductionRight);","\t\t},","\t\tsetCenterPoint: function(leftMovement, rightMovement) {","\t\t\tvar me = this;","\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,","\t\t\t\tmaxLeft = leftMovement + me.drawingArea;","","\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);","\t\t\t// Always vertically in the centre as the text height doesn't change","\t\t\tme.yCenter = Math.round((me.height / 2) + me.top);","\t\t},","","\t\tgetIndexAngle: function(index) {","\t\t\tvar angleMultiplier = (Math.PI * 2) / this.getValueCount();","\t\t\t// Start from the top instead of right, so remove a quarter of the circle","","\t\t\treturn index * angleMultiplier - (Math.PI / 2);","\t\t},","\t\tgetDistanceFromCenterForValue: function(value) {","\t\t\tvar me = this;","","\t\t\tif (value === null) {","\t\t\t\treturn 0; // null always in center","\t\t\t}","","\t\t\t// Take into account half font size + the yPadding of the top value","\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);","\t\t\tif (me.options.reverse) {","\t\t\t\treturn (me.max - value) * scalingFactor;","\t\t\t} else {","\t\t\t\treturn (value - me.min) * scalingFactor;","\t\t\t}","\t\t},","\t\tgetPointPosition: function(index, distanceFromCenter) {","\t\t\tvar me = this;","\t\t\tvar thisAngle = me.getIndexAngle(index);","\t\t\treturn {","\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,","\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter","\t\t\t};","\t\t},","\t\tgetPointPositionForValue: function(index, value) {","\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));","\t\t},","","\t\tgetBasePosition: function() {","\t\t\tvar me = this;","\t\t\tvar min = me.min;","\t\t\tvar max = me.max;","","\t\t\treturn me.getPointPositionForValue(0,","\t\t\t\tme.beginAtZero? 0:","\t\t\t\tmin < 0 && max < 0? max :","\t\t\t\tmin > 0 && max > 0? min :","\t\t\t\t0);","\t\t},","","\t\tdraw: function() {","\t\t\tvar me = this;","\t\t\tvar opts = me.options;","\t\t\tvar gridLineOpts = opts.gridLines;","\t\t\tvar tickOpts = opts.ticks;","\t\t\tvar angleLineOpts = opts.angleLines;","\t\t\tvar pointLabelOpts = opts.pointLabels;","\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;","","\t\t\tif (opts.display) {","\t\t\t\tvar ctx = me.ctx;","","\t\t\t\t// Tick Font","\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);","\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);","\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);","\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);","","\t\t\t\thelpers.each(me.ticks, function(label, index) {","\t\t\t\t\t// Don't draw a centre value (if it is minimum)","\t\t\t\t\tif (index > 0 || opts.reverse) {","\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);","\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;","","\t\t\t\t\t\t// Draw circular lines around the scale","\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {","\t\t\t\t\t\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);","\t\t\t\t\t\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);","","\t\t\t\t\t\t\tif (opts.lineArc) {","\t\t\t\t\t\t\t\t// Draw circular arcs between the points","\t\t\t\t\t\t\t\tctx.beginPath();","\t\t\t\t\t\t\t\tctx.arc(me.xCenter, me.yCenter, yCenterOffset, 0, Math.PI * 2);","\t\t\t\t\t\t\t\tctx.closePath();","\t\t\t\t\t\t\t\tctx.stroke();","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t// Draw straight lines connecting each index","\t\t\t\t\t\t\t\tctx.beginPath();","\t\t\t\t\t\t\t\tfor (var i = 0; i < me.getValueCount(); i++) {","\t\t\t\t\t\t\t\t\tvar pointPosition = me.getPointPosition(i, yCenterOffset);","\t\t\t\t\t\t\t\t\tif (i === 0) {","\t\t\t\t\t\t\t\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);","\t\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);","\t\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\tctx.closePath();","\t\t\t\t\t\t\t\tctx.stroke();","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","","\t\t\t\t\t\tif (tickOpts.display) {","\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);","\t\t\t\t\t\t\tctx.font = tickLabelFont;","","\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {","\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;","\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;","\t\t\t\t\t\t\t\tctx.fillRect(","\t\t\t\t\t\t\t\t\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,","\t\t\t\t\t\t\t\t\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,","\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,","\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2","\t\t\t\t\t\t\t\t);","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tctx.textAlign = 'center';","\t\t\t\t\t\t\tctx.textBaseline = \"middle\";","\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;","\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t});","","\t\t\t\tif (!opts.lineArc) {","\t\t\t\t\tctx.lineWidth = angleLineOpts.lineWidth;","\t\t\t\t\tctx.strokeStyle = angleLineOpts.color;","","\t\t\t\t\tvar outerDistance = me.getDistanceFromCenterForValue(opts.reverse ? me.min : me.max);","","\t\t\t\t\t// Point Label Font","\t\t\t\t\tvar pointLabelFontSize = getValueOrDefault(pointLabelOpts.fontSize, globalDefaults.defaultFontSize);","\t\t\t\t\tvar pointLabeFontStyle = getValueOrDefault(pointLabelOpts.fontStyle, globalDefaults.defaultFontStyle);","\t\t\t\t\tvar pointLabeFontFamily = getValueOrDefault(pointLabelOpts.fontFamily, globalDefaults.defaultFontFamily);","\t\t\t\t\tvar pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);","","\t\t\t\t\tfor (var i = me.getValueCount() - 1; i >= 0; i--) {","\t\t\t\t\t\tif (angleLineOpts.display) {","\t\t\t\t\t\t\tvar outerPosition = me.getPointPosition(i, outerDistance);","\t\t\t\t\t\t\tctx.beginPath();","\t\t\t\t\t\t\tctx.moveTo(me.xCenter, me.yCenter);","\t\t\t\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);","\t\t\t\t\t\t\tctx.stroke();","\t\t\t\t\t\t\tctx.closePath();","\t\t\t\t\t\t}","\t\t\t\t\t\t// Extra 3px out for some label spacing","\t\t\t\t\t\tvar pointLabelPosition = me.getPointPosition(i, outerDistance + 5);","","\t\t\t\t\t\t// Keep this in loop since we may support array properties here","\t\t\t\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);","\t\t\t\t\t\tctx.font = pointLabeFont;","\t\t\t\t\t\tctx.fillStyle = pointLabelFontColor;","","\t\t\t\t\t\tvar pointLabels = me.pointLabels,","\t\t\t\t\t\t\tlabelsCount = pointLabels.length,","\t\t\t\t\t\t\thalfLabelsCount = pointLabels.length / 2,","\t\t\t\t\t\t\tquarterLabelsCount = halfLabelsCount / 2,","\t\t\t\t\t\t\tupperHalf = (i < quarterLabelsCount || i > labelsCount - quarterLabelsCount),","\t\t\t\t\t\t\texactQuarter = (i === quarterLabelsCount || i === labelsCount - quarterLabelsCount);","\t\t\t\t\t\tif (i === 0) {","\t\t\t\t\t\t\tctx.textAlign = 'center';","\t\t\t\t\t\t} else if (i === halfLabelsCount) {","\t\t\t\t\t\t\tctx.textAlign = 'center';","\t\t\t\t\t\t} else if (i < halfLabelsCount) {","\t\t\t\t\t\t\tctx.textAlign = 'left';","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tctx.textAlign = 'right';","\t\t\t\t\t\t}","","\t\t\t\t\t\t// Set the correct text baseline based on outer positioning","\t\t\t\t\t\tif (exactQuarter) {","\t\t\t\t\t\t\tctx.textBaseline = 'middle';","\t\t\t\t\t\t} else if (upperHalf) {","\t\t\t\t\t\t\tctx.textBaseline = 'bottom';","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tctx.textBaseline = 'top';","\t\t\t\t\t\t}","","\t\t\t\t\t\tctx.fillText(pointLabels[i] ? pointLabels[i] : '', pointLabelPosition.x, pointLabelPosition.y);","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t});","\tChart.scaleService.registerScaleType(\"radialLinear\", LinearRadialScale, defaultConfig);","","};","","},{}],43:[function(require,module,exports){","/*global window: false */","\"use strict\";","","var moment = require(6);","moment = typeof(moment) === 'function' ? moment : window.moment;","","module.exports = function(Chart) {","","\tvar helpers = Chart.helpers;","\tvar time = {","\t\tunits: [{","\t\t\tname: 'millisecond',","\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]","\t\t}, {","\t\t\tname: 'second',","\t\t\tsteps: [1, 2, 5, 10, 30]","\t\t}, {","\t\t\tname: 'minute',","\t\t\tsteps: [1, 2, 5, 10, 30]","\t\t}, {","\t\t\tname: 'hour',","\t\t\tsteps: [1, 2, 3, 6, 12]","\t\t}, {","\t\t\tname: 'day',","\t\t\tsteps: [1, 2, 5]","\t\t}, {","\t\t\tname: 'week',","\t\t\tmaxStep: 4","\t\t}, {","\t\t\tname: 'month',","\t\t\tmaxStep: 3","\t\t}, {","\t\t\tname: 'quarter',","\t\t\tmaxStep: 4","\t\t}, {","\t\t\tname: 'year',","\t\t\tmaxStep: false","\t\t}]","\t};","","\tvar defaultConfig = {","\t\tposition: \"bottom\",","","\t\ttime: {","\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment","\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/","\t\t\tunit: false, // false == automatic or override with week, month, year, etc.","\t\t\tround: false, // none, or override with week, month, year, etc.","\t\t\tdisplayFormat: false, // DEPRECATED","\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/","","\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/","\t\t\tdisplayFormats: {","\t\t\t\t'millisecond': 'h:mm:ss.SSS a', // 11:20:01.123 AM,","\t\t\t\t'second': 'h:mm:ss a', // 11:20:01 AM","\t\t\t\t'minute': 'h:mm:ss a', // 11:20:01 AM","\t\t\t\t'hour': 'MMM D, hA', // Sept 4, 5PM","\t\t\t\t'day': 'll', // Sep 4 2015","\t\t\t\t'week': 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?","\t\t\t\t'month': 'MMM YYYY', // Sept 2015","\t\t\t\t'quarter': '[Q]Q - YYYY', // Q3","\t\t\t\t'year': 'YYYY' // 2015","\t\t\t}","\t\t},","\t\tticks: {","\t\t\tautoSkip: false","\t\t}","\t};","","\tvar TimeScale = Chart.Scale.extend({","\t\tinitialize: function() {","\t\t\tif (!moment) {","\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');","\t\t\t}","","\t\t\tChart.Scale.prototype.initialize.call(this);","\t\t},","\t\tgetLabelMoment: function(datasetIndex, index) {","\t\t\treturn this.labelMoments[datasetIndex][index];","\t\t},","\t\tgetMomentStartOf: function(tick) {","\t\t\tvar me = this;","\t\t\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {","\t\t\t\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);","\t\t\t} else {","\t\t\t\treturn tick.clone().startOf(me.tickUnit);","\t\t\t}","\t\t},","\t\tdetermineDataLimits: function() {","\t\t\tvar me = this;","\t\t\tme.labelMoments = [];","","\t\t\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use","\t\t\t// these","\t\t\tvar scaleLabelMoments = [];","\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {","\t\t\t\thelpers.each(me.chart.data.labels, function(label, index) {","\t\t\t\t\tvar labelMoment = me.parseTime(label);","","\t\t\t\t\tif (labelMoment.isValid()) {","\t\t\t\t\t\tif (me.options.time.round) {","\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);","\t\t\t\t\t\t}","\t\t\t\t\t\tscaleLabelMoments.push(labelMoment);","\t\t\t\t\t}","\t\t\t\t}, me);","","\t\t\t\tme.firstTick = moment.min.call(me, scaleLabelMoments);","\t\t\t\tme.lastTick = moment.max.call(me, scaleLabelMoments);","\t\t\t} else {","\t\t\t\tme.firstTick = null;","\t\t\t\tme.lastTick = null;","\t\t\t}","","\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tvar momentsForDataset = [];","\t\t\t\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);","","\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {","\t\t\t\t\thelpers.each(dataset.data, function(value, index) {","\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));","","\t\t\t\t\t\tif (labelMoment.isValid()) {","\t\t\t\t\t\t\tif (me.options.time.round) {","\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\tmomentsForDataset.push(labelMoment);","","\t\t\t\t\t\t\tif (datasetVisible) {","\t\t\t\t\t\t\t\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated","\t\t\t\t\t\t\t\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;","\t\t\t\t\t\t\t\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}, me);","\t\t\t\t} else {","\t\t\t\t\t// We have no labels. Use the ones from the scale","\t\t\t\t\tmomentsForDataset = scaleLabelMoments;","\t\t\t\t}","","\t\t\t\tme.labelMoments.push(momentsForDataset);","\t\t\t}, me);","","\t\t\t// Set these after we've done all the data","\t\t\tif (me.options.time.min) {","\t\t\t\tme.firstTick = me.parseTime(me.options.time.min);","\t\t\t}","","\t\t\tif (me.options.time.max) {","\t\t\t\tme.lastTick = me.parseTime(me.options.time.max);","\t\t\t}","","\t\t\t// We will modify these, so clone for later","\t\t\tme.firstTick = (me.firstTick || moment()).clone();","\t\t\tme.lastTick = (me.lastTick || moment()).clone();","\t\t},","\t\tbuildTicks: function(index) {","\t\t\tvar me = this;","","\t\t\tme.ctx.save();","\t\t\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);","\t\t\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);","\t\t\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);","\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);","\t\t\tme.ctx.font = tickLabelFont;","","\t\t\tme.ticks = [];","\t\t\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step","\t\t\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)","","\t\t\t// Set unit override if applicable","\t\t\tif (me.options.time.unit) {","\t\t\t\tme.tickUnit = me.options.time.unit || 'day';","\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];","\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);","\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);","\t\t\t} else {","\t\t\t\t// Determine the smallest needed unit of the time","\t\t\t\tvar innerWidth = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);","","\t\t\t\t// Crude approximation of what the label length might be","\t\t\t\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);","\t\t\t\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;","\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));","\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));","\t\t\t\ttickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);","\t\t\t\tvar labelCapacity = innerWidth / (tickLabelWidth);","","\t\t\t\t// Start as small as possible","\t\t\t\tme.tickUnit = 'millisecond';","\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);","\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];","","\t\t\t\tvar unitDefinitionIndex = 0;","\t\t\t\tvar unitDefinition = time.units[unitDefinitionIndex];","","\t\t\t\t// While we aren't ideal and we don't have units left","\t\t\t\twhile (unitDefinitionIndex < time.units.length) {","\t\t\t\t\t// Can we scale this unit. If `false` we can scale infinitely","\t\t\t\t\tme.unitScale = 1;","","\t\t\t\t\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {","\t\t\t\t\t\t// Use one of the prefedined steps","\t\t\t\t\t\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {","\t\t\t\t\t\t\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {","\t\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);","\t\t\t\t\t\t\t\tbreak;","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","","\t\t\t\t\t\tbreak;","\t\t\t\t\t} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {","\t\t\t\t\t\t// We have a max step. Scale this unit","\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));","\t\t\t\t\t\tbreak;","\t\t\t\t\t} else {","\t\t\t\t\t\t// Move to the next unit up","\t\t\t\t\t\t++unitDefinitionIndex;","\t\t\t\t\t\tunitDefinition = time.units[unitDefinitionIndex];","","\t\t\t\t\t\tme.tickUnit = unitDefinition.name;","\t\t\t\t\t\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);","\t\t\t\t\t\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);","\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;","\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\tvar roundedStart;","","\t\t\t// Only round the first tick if we have no hard minimum","\t\t\tif (!me.options.time.min) {","\t\t\t\tme.firstTick = me.getMomentStartOf(me.firstTick);","\t\t\t\troundedStart = me.firstTick;","\t\t\t} else {","\t\t\t\troundedStart = me.getMomentStartOf(me.firstTick);","\t\t\t}","","\t\t\t// Only round the last tick if we have no hard maximum","\t\t\tif (!me.options.time.max) {","\t\t\t\tvar roundedEnd = me.getMomentStartOf(me.lastTick);","\t\t\t\tif (roundedEnd.diff(me.lastTick, me.tickUnit, true) !== 0) {","\t\t\t\t\t// Do not use end of because we need me to be in the next time unit","\t\t\t\t\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));","\t\t\t\t}","\t\t\t}","","\t\t\tme.smallestLabelSeparation = me.width;","","\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {","\t\t\t\tfor (var i = 1; i < me.labelMoments[datasetIndex].length; i++) {","\t\t\t\t\tme.smallestLabelSeparation = Math.min(me.smallestLabelSeparation, me.labelMoments[datasetIndex][i].diff(me.labelMoments[datasetIndex][i - 1], me.tickUnit, true));","\t\t\t\t}","\t\t\t}, me);","","\t\t\t// Tick displayFormat override","\t\t\tif (me.options.time.displayFormat) {","\t\t\t\tme.displayFormat = me.options.time.displayFormat;","\t\t\t}","","\t\t\t// first tick. will have been rounded correctly if options.time.min is not specified","\t\t\tme.ticks.push(me.firstTick.clone());","","\t\t\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick","\t\t\tfor (var i = 1; i <= me.scaleSizeInUnits; ++i) {","\t\t\t\tvar newTick = roundedStart.clone().add(i, me.tickUnit);","","\t\t\t\t// Are we greater than the max time","\t\t\t\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {","\t\t\t\t\tbreak;","\t\t\t\t}","","\t\t\t\tif (i % me.unitScale === 0) {","\t\t\t\t\tme.ticks.push(newTick);","\t\t\t\t}","\t\t\t}","","\t\t\t// Always show the right tick","\t\t\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);","\t\t\tif (diff !== 0 || me.scaleSizeInUnits === 0) {","\t\t\t\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart","\t\t\t\t// but the last tick was not rounded.","\t\t\t\tif (me.options.time.max) {","\t\t\t\t\tme.ticks.push(me.lastTick.clone());","\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);","\t\t\t\t} else {","\t\t\t\t\tme.ticks.push(me.lastTick.clone());","\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);","\t\t\t\t}","\t\t\t}","","\t\t\tme.ctx.restore();","\t\t},","\t\t// Get tooltip label","\t\tgetLabelForIndex: function(index, datasetIndex) {","\t\t\tvar me = this;","\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';","","\t\t\tif (typeof me.chart.data.datasets[datasetIndex].data[0] === 'object') {","\t\t\t\tlabel = me.getRightValue(me.chart.data.datasets[datasetIndex].data[index]);","\t\t\t}","","\t\t\t// Format nicely","\t\t\tif (me.options.time.tooltipFormat) {","\t\t\t\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);","\t\t\t}","","\t\t\treturn label;","\t\t},","\t\t// Function to format an individual tick mark","\t\ttickFormatFunction: function tickFormatFunction(tick, index, ticks) {","\t\t\tvar formattedTick = tick.format(this.displayFormat);","\t\t\tvar tickOpts = this.options.ticks;","\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);","","\t\t\tif (callback) {","\t\t\t\treturn callback(formattedTick, index, ticks);","\t\t\t} else {","\t\t\t\treturn formattedTick;","\t\t\t}","\t\t},","\t\tconvertTicksToLabels: function() {","\t\t\tvar me = this;","\t\t\tme.tickMoments = me.ticks;","\t\t\tme.ticks = me.ticks.map(me.tickFormatFunction, me);","\t\t},","\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {","\t\t\tvar me = this;","\t\t\tvar labelMoment = value && value.isValid && value.isValid() ? value : me.getLabelMoment(datasetIndex, index);","","\t\t\tif (labelMoment) {","\t\t\t\tvar offset = labelMoment.diff(me.firstTick, me.tickUnit, true);","","\t\t\t\tvar decimal = offset / me.scaleSizeInUnits;","","\t\t\t\tif (me.isHorizontal()) {","\t\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);","\t\t\t\t\tvar valueWidth = innerWidth / Math.max(me.ticks.length - 1, 1);","\t\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;","","\t\t\t\t\treturn me.left + Math.round(valueOffset);","\t\t\t\t} else {","\t\t\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);","\t\t\t\t\tvar valueHeight = innerHeight / Math.max(me.ticks.length - 1, 1);","\t\t\t\t\tvar heightOffset = (innerHeight * decimal) + me.paddingTop;","","\t\t\t\t\treturn me.top + Math.round(heightOffset);","\t\t\t\t}","\t\t\t}","\t\t},","\t\tgetPixelForTick: function(index, includeOffset) {","\t\t\treturn this.getPixelForValue(this.tickMoments[index], null, null, includeOffset);","\t\t},","\t\tgetValueForPixel: function(pixel) {","\t\t\tvar me = this;","\t\t\tvar innerDimension = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);","\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left + me.paddingLeft : me.top + me.paddingTop)) / innerDimension;","\t\t\toffset *= me.scaleSizeInUnits;","\t\t\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');","\t\t},","\t\tparseTime: function(label) {","\t\t\tvar me = this;","\t\t\tif (typeof me.options.time.parser === 'string') {","\t\t\t\treturn moment(label, me.options.time.parser);","\t\t\t}","\t\t\tif (typeof me.options.time.parser === 'function') {","\t\t\t\treturn me.options.time.parser(label);","\t\t\t}","\t\t\t// Date objects","\t\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {","\t\t\t\treturn moment(label);","\t\t\t}","\t\t\t// Moment support","\t\t\tif (label.isValid && label.isValid()) {","\t\t\t\treturn label;","\t\t\t}","\t\t\t// Custom parsing (return an instance of moment)","\t\t\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {","\t\t\t\tconsole.warn(\"options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale\");","\t\t\t\treturn me.options.time.format(label);","\t\t\t}","\t\t\t// Moment format parsing","\t\t\treturn moment(label, me.options.time.format);","\t\t}","\t});","\tChart.scaleService.registerScaleType(\"time\", TimeScale, defaultConfig);","","};","","},{\"6\":6}]},{},[7])(7)","});"],"id":1}]]},"ace":{"folds":[],"scrolltop":199390,"scrollleft":0,"selection":{"start":{"row":14281,"column":3},"end":{"row":14281,"column":3},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":14241,"state":"start","mode":"ace/mode/javascript"}},"timestamp":1466689155845,"hash":"96f2240cc1e500ded70228e356681cb26f7ae122"}